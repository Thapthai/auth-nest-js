
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model verification_token
 * 
 */
export type verification_token = $Result.DefaultSelection<Prisma.$verification_tokenPayload>
/**
 * Model password_reset_token
 * 
 */
export type password_reset_token = $Result.DefaultSelection<Prisma.$password_reset_tokenPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model sale_offices
 * 
 */
export type sale_offices = $Result.DefaultSelection<Prisma.$sale_officesPayload>
/**
 * Model departments
 * 
 */
export type departments = $Result.DefaultSelection<Prisma.$departmentsPayload>
/**
 * Model factory_sale_office
 * 
 */
export type factory_sale_office = $Result.DefaultSelection<Prisma.$factory_sale_officePayload>
/**
 * Model factories
 * 
 */
export type factories = $Result.DefaultSelection<Prisma.$factoriesPayload>
/**
 * Model machines
 * 
 */
export type machines = $Result.DefaultSelection<Prisma.$machinesPayload>
/**
 * Model contact
 * 
 */
export type contact = $Result.DefaultSelection<Prisma.$contactPayload>
/**
 * Model materials
 * 
 */
export type materials = $Result.DefaultSelection<Prisma.$materialsPayload>
/**
 * Model material_types
 * 
 */
export type material_types = $Result.DefaultSelection<Prisma.$material_typesPayload>
/**
 * Model item_units_meaures
 * 
 */
export type item_units_meaures = $Result.DefaultSelection<Prisma.$item_units_meauresPayload>
/**
 * Model items
 * 
 */
export type items = $Result.DefaultSelection<Prisma.$itemsPayload>
/**
 * Model items_details
 * 
 */
export type items_details = $Result.DefaultSelection<Prisma.$items_detailsPayload>
/**
 * Model item_categories
 * 
 */
export type item_categories = $Result.DefaultSelection<Prisma.$item_categoriesPayload>
/**
 * Model types
 * 
 */
export type types = $Result.DefaultSelection<Prisma.$typesPayload>
/**
 * Model item_prices
 * 
 */
export type item_prices = $Result.DefaultSelection<Prisma.$item_pricesPayload>
/**
 * Model dirties
 * 
 */
export type dirties = $Result.DefaultSelection<Prisma.$dirtiesPayload>
/**
 * Model dirty_details
 * 
 */
export type dirty_details = $Result.DefaultSelection<Prisma.$dirty_detailsPayload>
/**
 * Model customer_group_types
 * 
 */
export type customer_group_types = $Result.DefaultSelection<Prisma.$customer_group_typesPayload>
/**
 * Model customer_groups
 * 
 */
export type customer_groups = $Result.DefaultSelection<Prisma.$customer_groupsPayload>
/**
 * Model stock_locations
 * 
 */
export type stock_locations = $Result.DefaultSelection<Prisma.$stock_locationsPayload>
/**
 * Model shelfcounts
 * 
 */
export type shelfcounts = $Result.DefaultSelection<Prisma.$shelfcountsPayload>
/**
 * Model shelfcount_details
 * 
 */
export type shelfcount_details = $Result.DefaultSelection<Prisma.$shelfcount_detailsPayload>
/**
 * Model damages
 * 
 */
export type damages = $Result.DefaultSelection<Prisma.$damagesPayload>
/**
 * Model damage_details
 * 
 */
export type damage_details = $Result.DefaultSelection<Prisma.$damage_detailsPayload>
/**
 * Model ships
 * 
 */
export type ships = $Result.DefaultSelection<Prisma.$shipsPayload>
/**
 * Model new_linens
 * 
 */
export type new_linens = $Result.DefaultSelection<Prisma.$new_linensPayload>
/**
 * Model new_linen_details
 * 
 */
export type new_linen_details = $Result.DefaultSelection<Prisma.$new_linen_detailsPayload>
/**
 * Model repair_washs
 * 
 */
export type repair_washs = $Result.DefaultSelection<Prisma.$repair_washsPayload>
/**
 * Model repair_wash_details
 * 
 */
export type repair_wash_details = $Result.DefaultSelection<Prisma.$repair_wash_detailsPayload>
/**
 * Model cleans
 * 
 */
export type cleans = $Result.DefaultSelection<Prisma.$cleansPayload>
/**
 * Model clean_details
 * 
 */
export type clean_details = $Result.DefaultSelection<Prisma.$clean_detailsPayload>
/**
 * Model return_washs
 * 
 */
export type return_washs = $Result.DefaultSelection<Prisma.$return_washsPayload>
/**
 * Model retrun_wash_details
 * 
 */
export type retrun_wash_details = $Result.DefaultSelection<Prisma.$retrun_wash_detailsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification_token`: Exposes CRUD operations for the **verification_token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verification_tokens
    * const verification_tokens = await prisma.verification_token.findMany()
    * ```
    */
  get verification_token(): Prisma.verification_tokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password_reset_token`: Exposes CRUD operations for the **password_reset_token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_reset_tokens
    * const password_reset_tokens = await prisma.password_reset_token.findMany()
    * ```
    */
  get password_reset_token(): Prisma.password_reset_tokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale_offices`: Exposes CRUD operations for the **sale_offices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sale_offices
    * const sale_offices = await prisma.sale_offices.findMany()
    * ```
    */
  get sale_offices(): Prisma.sale_officesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.departments`: Exposes CRUD operations for the **departments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.departments.findMany()
    * ```
    */
  get departments(): Prisma.departmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.factory_sale_office`: Exposes CRUD operations for the **factory_sale_office** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Factory_sale_offices
    * const factory_sale_offices = await prisma.factory_sale_office.findMany()
    * ```
    */
  get factory_sale_office(): Prisma.factory_sale_officeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.factories`: Exposes CRUD operations for the **factories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Factories
    * const factories = await prisma.factories.findMany()
    * ```
    */
  get factories(): Prisma.factoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.machines`: Exposes CRUD operations for the **machines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Machines
    * const machines = await prisma.machines.findMany()
    * ```
    */
  get machines(): Prisma.machinesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.contactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.materials`: Exposes CRUD operations for the **materials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.materials.findMany()
    * ```
    */
  get materials(): Prisma.materialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material_types`: Exposes CRUD operations for the **material_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Material_types
    * const material_types = await prisma.material_types.findMany()
    * ```
    */
  get material_types(): Prisma.material_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item_units_meaures`: Exposes CRUD operations for the **item_units_meaures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Item_units_meaures
    * const item_units_meaures = await prisma.item_units_meaures.findMany()
    * ```
    */
  get item_units_meaures(): Prisma.item_units_meauresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.items`: Exposes CRUD operations for the **items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.items.findMany()
    * ```
    */
  get items(): Prisma.itemsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.items_details`: Exposes CRUD operations for the **items_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items_details
    * const items_details = await prisma.items_details.findMany()
    * ```
    */
  get items_details(): Prisma.items_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item_categories`: Exposes CRUD operations for the **item_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Item_categories
    * const item_categories = await prisma.item_categories.findMany()
    * ```
    */
  get item_categories(): Prisma.item_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.types`: Exposes CRUD operations for the **types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Types
    * const types = await prisma.types.findMany()
    * ```
    */
  get types(): Prisma.typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item_prices`: Exposes CRUD operations for the **item_prices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Item_prices
    * const item_prices = await prisma.item_prices.findMany()
    * ```
    */
  get item_prices(): Prisma.item_pricesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dirties`: Exposes CRUD operations for the **dirties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dirties
    * const dirties = await prisma.dirties.findMany()
    * ```
    */
  get dirties(): Prisma.dirtiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dirty_details`: Exposes CRUD operations for the **dirty_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dirty_details
    * const dirty_details = await prisma.dirty_details.findMany()
    * ```
    */
  get dirty_details(): Prisma.dirty_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer_group_types`: Exposes CRUD operations for the **customer_group_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customer_group_types
    * const customer_group_types = await prisma.customer_group_types.findMany()
    * ```
    */
  get customer_group_types(): Prisma.customer_group_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer_groups`: Exposes CRUD operations for the **customer_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customer_groups
    * const customer_groups = await prisma.customer_groups.findMany()
    * ```
    */
  get customer_groups(): Prisma.customer_groupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock_locations`: Exposes CRUD operations for the **stock_locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stock_locations
    * const stock_locations = await prisma.stock_locations.findMany()
    * ```
    */
  get stock_locations(): Prisma.stock_locationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shelfcounts`: Exposes CRUD operations for the **shelfcounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shelfcounts
    * const shelfcounts = await prisma.shelfcounts.findMany()
    * ```
    */
  get shelfcounts(): Prisma.shelfcountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shelfcount_details`: Exposes CRUD operations for the **shelfcount_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shelfcount_details
    * const shelfcount_details = await prisma.shelfcount_details.findMany()
    * ```
    */
  get shelfcount_details(): Prisma.shelfcount_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.damages`: Exposes CRUD operations for the **damages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Damages
    * const damages = await prisma.damages.findMany()
    * ```
    */
  get damages(): Prisma.damagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.damage_details`: Exposes CRUD operations for the **damage_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Damage_details
    * const damage_details = await prisma.damage_details.findMany()
    * ```
    */
  get damage_details(): Prisma.damage_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ships`: Exposes CRUD operations for the **ships** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ships
    * const ships = await prisma.ships.findMany()
    * ```
    */
  get ships(): Prisma.shipsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.new_linens`: Exposes CRUD operations for the **new_linens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more New_linens
    * const new_linens = await prisma.new_linens.findMany()
    * ```
    */
  get new_linens(): Prisma.new_linensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.new_linen_details`: Exposes CRUD operations for the **new_linen_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more New_linen_details
    * const new_linen_details = await prisma.new_linen_details.findMany()
    * ```
    */
  get new_linen_details(): Prisma.new_linen_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.repair_washs`: Exposes CRUD operations for the **repair_washs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Repair_washs
    * const repair_washs = await prisma.repair_washs.findMany()
    * ```
    */
  get repair_washs(): Prisma.repair_washsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.repair_wash_details`: Exposes CRUD operations for the **repair_wash_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Repair_wash_details
    * const repair_wash_details = await prisma.repair_wash_details.findMany()
    * ```
    */
  get repair_wash_details(): Prisma.repair_wash_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleans`: Exposes CRUD operations for the **cleans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cleans
    * const cleans = await prisma.cleans.findMany()
    * ```
    */
  get cleans(): Prisma.cleansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clean_details`: Exposes CRUD operations for the **clean_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clean_details
    * const clean_details = await prisma.clean_details.findMany()
    * ```
    */
  get clean_details(): Prisma.clean_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.return_washs`: Exposes CRUD operations for the **return_washs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Return_washs
    * const return_washs = await prisma.return_washs.findMany()
    * ```
    */
  get return_washs(): Prisma.return_washsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.retrun_wash_details`: Exposes CRUD operations for the **retrun_wash_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Retrun_wash_details
    * const retrun_wash_details = await prisma.retrun_wash_details.findMany()
    * ```
    */
  get retrun_wash_details(): Prisma.retrun_wash_detailsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    verification_token: 'verification_token',
    password_reset_token: 'password_reset_token',
    notifications: 'notifications',
    sale_offices: 'sale_offices',
    departments: 'departments',
    factory_sale_office: 'factory_sale_office',
    factories: 'factories',
    machines: 'machines',
    contact: 'contact',
    materials: 'materials',
    material_types: 'material_types',
    item_units_meaures: 'item_units_meaures',
    items: 'items',
    items_details: 'items_details',
    item_categories: 'item_categories',
    types: 'types',
    item_prices: 'item_prices',
    dirties: 'dirties',
    dirty_details: 'dirty_details',
    customer_group_types: 'customer_group_types',
    customer_groups: 'customer_groups',
    stock_locations: 'stock_locations',
    shelfcounts: 'shelfcounts',
    shelfcount_details: 'shelfcount_details',
    damages: 'damages',
    damage_details: 'damage_details',
    ships: 'ships',
    new_linens: 'new_linens',
    new_linen_details: 'new_linen_details',
    repair_washs: 'repair_washs',
    repair_wash_details: 'repair_wash_details',
    cleans: 'cleans',
    clean_details: 'clean_details',
    return_washs: 'return_washs',
    retrun_wash_details: 'retrun_wash_details'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "verification_token" | "password_reset_token" | "notifications" | "sale_offices" | "departments" | "factory_sale_office" | "factories" | "machines" | "contact" | "materials" | "material_types" | "item_units_meaures" | "items" | "items_details" | "item_categories" | "types" | "item_prices" | "dirties" | "dirty_details" | "customer_group_types" | "customer_groups" | "stock_locations" | "shelfcounts" | "shelfcount_details" | "damages" | "damage_details" | "ships" | "new_linens" | "new_linen_details" | "repair_washs" | "repair_wash_details" | "cleans" | "clean_details" | "return_washs" | "retrun_wash_details"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      verification_token: {
        payload: Prisma.$verification_tokenPayload<ExtArgs>
        fields: Prisma.verification_tokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.verification_tokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_tokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.verification_tokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_tokenPayload>
          }
          findFirst: {
            args: Prisma.verification_tokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_tokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.verification_tokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_tokenPayload>
          }
          findMany: {
            args: Prisma.verification_tokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_tokenPayload>[]
          }
          create: {
            args: Prisma.verification_tokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_tokenPayload>
          }
          createMany: {
            args: Prisma.verification_tokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.verification_tokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_tokenPayload>
          }
          update: {
            args: Prisma.verification_tokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_tokenPayload>
          }
          deleteMany: {
            args: Prisma.verification_tokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.verification_tokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.verification_tokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$verification_tokenPayload>
          }
          aggregate: {
            args: Prisma.Verification_tokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification_token>
          }
          groupBy: {
            args: Prisma.verification_tokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Verification_tokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.verification_tokenCountArgs<ExtArgs>
            result: $Utils.Optional<Verification_tokenCountAggregateOutputType> | number
          }
        }
      }
      password_reset_token: {
        payload: Prisma.$password_reset_tokenPayload<ExtArgs>
        fields: Prisma.password_reset_tokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.password_reset_tokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.password_reset_tokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokenPayload>
          }
          findFirst: {
            args: Prisma.password_reset_tokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.password_reset_tokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokenPayload>
          }
          findMany: {
            args: Prisma.password_reset_tokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokenPayload>[]
          }
          create: {
            args: Prisma.password_reset_tokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokenPayload>
          }
          createMany: {
            args: Prisma.password_reset_tokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.password_reset_tokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokenPayload>
          }
          update: {
            args: Prisma.password_reset_tokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokenPayload>
          }
          deleteMany: {
            args: Prisma.password_reset_tokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.password_reset_tokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.password_reset_tokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokenPayload>
          }
          aggregate: {
            args: Prisma.Password_reset_tokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword_reset_token>
          }
          groupBy: {
            args: Prisma.password_reset_tokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.password_reset_tokenCountArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokenCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      sale_offices: {
        payload: Prisma.$sale_officesPayload<ExtArgs>
        fields: Prisma.sale_officesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sale_officesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_officesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sale_officesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_officesPayload>
          }
          findFirst: {
            args: Prisma.sale_officesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_officesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sale_officesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_officesPayload>
          }
          findMany: {
            args: Prisma.sale_officesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_officesPayload>[]
          }
          create: {
            args: Prisma.sale_officesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_officesPayload>
          }
          createMany: {
            args: Prisma.sale_officesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sale_officesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_officesPayload>
          }
          update: {
            args: Prisma.sale_officesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_officesPayload>
          }
          deleteMany: {
            args: Prisma.sale_officesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sale_officesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sale_officesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sale_officesPayload>
          }
          aggregate: {
            args: Prisma.Sale_officesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale_offices>
          }
          groupBy: {
            args: Prisma.sale_officesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sale_officesGroupByOutputType>[]
          }
          count: {
            args: Prisma.sale_officesCountArgs<ExtArgs>
            result: $Utils.Optional<Sale_officesCountAggregateOutputType> | number
          }
        }
      }
      departments: {
        payload: Prisma.$departmentsPayload<ExtArgs>
        fields: Prisma.departmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          findFirst: {
            args: Prisma.departmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          findMany: {
            args: Prisma.departmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>[]
          }
          create: {
            args: Prisma.departmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          createMany: {
            args: Prisma.departmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.departmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          update: {
            args: Prisma.departmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          deleteMany: {
            args: Prisma.departmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.departmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.departmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentsPayload>
          }
          aggregate: {
            args: Prisma.DepartmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartments>
          }
          groupBy: {
            args: Prisma.departmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.departmentsCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsCountAggregateOutputType> | number
          }
        }
      }
      factory_sale_office: {
        payload: Prisma.$factory_sale_officePayload<ExtArgs>
        fields: Prisma.factory_sale_officeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.factory_sale_officeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factory_sale_officePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.factory_sale_officeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factory_sale_officePayload>
          }
          findFirst: {
            args: Prisma.factory_sale_officeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factory_sale_officePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.factory_sale_officeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factory_sale_officePayload>
          }
          findMany: {
            args: Prisma.factory_sale_officeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factory_sale_officePayload>[]
          }
          create: {
            args: Prisma.factory_sale_officeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factory_sale_officePayload>
          }
          createMany: {
            args: Prisma.factory_sale_officeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.factory_sale_officeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factory_sale_officePayload>
          }
          update: {
            args: Prisma.factory_sale_officeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factory_sale_officePayload>
          }
          deleteMany: {
            args: Prisma.factory_sale_officeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.factory_sale_officeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.factory_sale_officeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factory_sale_officePayload>
          }
          aggregate: {
            args: Prisma.Factory_sale_officeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactory_sale_office>
          }
          groupBy: {
            args: Prisma.factory_sale_officeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Factory_sale_officeGroupByOutputType>[]
          }
          count: {
            args: Prisma.factory_sale_officeCountArgs<ExtArgs>
            result: $Utils.Optional<Factory_sale_officeCountAggregateOutputType> | number
          }
        }
      }
      factories: {
        payload: Prisma.$factoriesPayload<ExtArgs>
        fields: Prisma.factoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.factoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.factoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factoriesPayload>
          }
          findFirst: {
            args: Prisma.factoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.factoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factoriesPayload>
          }
          findMany: {
            args: Prisma.factoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factoriesPayload>[]
          }
          create: {
            args: Prisma.factoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factoriesPayload>
          }
          createMany: {
            args: Prisma.factoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.factoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factoriesPayload>
          }
          update: {
            args: Prisma.factoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factoriesPayload>
          }
          deleteMany: {
            args: Prisma.factoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.factoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.factoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$factoriesPayload>
          }
          aggregate: {
            args: Prisma.FactoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFactories>
          }
          groupBy: {
            args: Prisma.factoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.factoriesCountArgs<ExtArgs>
            result: $Utils.Optional<FactoriesCountAggregateOutputType> | number
          }
        }
      }
      machines: {
        payload: Prisma.$machinesPayload<ExtArgs>
        fields: Prisma.machinesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.machinesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.machinesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinesPayload>
          }
          findFirst: {
            args: Prisma.machinesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.machinesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinesPayload>
          }
          findMany: {
            args: Prisma.machinesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinesPayload>[]
          }
          create: {
            args: Prisma.machinesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinesPayload>
          }
          createMany: {
            args: Prisma.machinesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.machinesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinesPayload>
          }
          update: {
            args: Prisma.machinesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinesPayload>
          }
          deleteMany: {
            args: Prisma.machinesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.machinesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.machinesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinesPayload>
          }
          aggregate: {
            args: Prisma.MachinesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachines>
          }
          groupBy: {
            args: Prisma.machinesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachinesGroupByOutputType>[]
          }
          count: {
            args: Prisma.machinesCountArgs<ExtArgs>
            result: $Utils.Optional<MachinesCountAggregateOutputType> | number
          }
        }
      }
      contact: {
        payload: Prisma.$contactPayload<ExtArgs>
        fields: Prisma.contactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          findFirst: {
            args: Prisma.contactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          findMany: {
            args: Prisma.contactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>[]
          }
          create: {
            args: Prisma.contactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          createMany: {
            args: Prisma.contactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          update: {
            args: Prisma.contactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          deleteMany: {
            args: Prisma.contactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.contactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      materials: {
        payload: Prisma.$materialsPayload<ExtArgs>
        fields: Prisma.materialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.materialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.materialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialsPayload>
          }
          findFirst: {
            args: Prisma.materialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.materialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialsPayload>
          }
          findMany: {
            args: Prisma.materialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialsPayload>[]
          }
          create: {
            args: Prisma.materialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialsPayload>
          }
          createMany: {
            args: Prisma.materialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.materialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialsPayload>
          }
          update: {
            args: Prisma.materialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialsPayload>
          }
          deleteMany: {
            args: Prisma.materialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.materialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.materialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$materialsPayload>
          }
          aggregate: {
            args: Prisma.MaterialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterials>
          }
          groupBy: {
            args: Prisma.materialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.materialsCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialsCountAggregateOutputType> | number
          }
        }
      }
      material_types: {
        payload: Prisma.$material_typesPayload<ExtArgs>
        fields: Prisma.material_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.material_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$material_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.material_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$material_typesPayload>
          }
          findFirst: {
            args: Prisma.material_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$material_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.material_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$material_typesPayload>
          }
          findMany: {
            args: Prisma.material_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$material_typesPayload>[]
          }
          create: {
            args: Prisma.material_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$material_typesPayload>
          }
          createMany: {
            args: Prisma.material_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.material_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$material_typesPayload>
          }
          update: {
            args: Prisma.material_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$material_typesPayload>
          }
          deleteMany: {
            args: Prisma.material_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.material_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.material_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$material_typesPayload>
          }
          aggregate: {
            args: Prisma.Material_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial_types>
          }
          groupBy: {
            args: Prisma.material_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Material_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.material_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Material_typesCountAggregateOutputType> | number
          }
        }
      }
      item_units_meaures: {
        payload: Prisma.$item_units_meauresPayload<ExtArgs>
        fields: Prisma.item_units_meauresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.item_units_meauresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_units_meauresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.item_units_meauresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_units_meauresPayload>
          }
          findFirst: {
            args: Prisma.item_units_meauresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_units_meauresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.item_units_meauresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_units_meauresPayload>
          }
          findMany: {
            args: Prisma.item_units_meauresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_units_meauresPayload>[]
          }
          create: {
            args: Prisma.item_units_meauresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_units_meauresPayload>
          }
          createMany: {
            args: Prisma.item_units_meauresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.item_units_meauresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_units_meauresPayload>
          }
          update: {
            args: Prisma.item_units_meauresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_units_meauresPayload>
          }
          deleteMany: {
            args: Prisma.item_units_meauresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.item_units_meauresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.item_units_meauresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_units_meauresPayload>
          }
          aggregate: {
            args: Prisma.Item_units_meauresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem_units_meaures>
          }
          groupBy: {
            args: Prisma.item_units_meauresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Item_units_meauresGroupByOutputType>[]
          }
          count: {
            args: Prisma.item_units_meauresCountArgs<ExtArgs>
            result: $Utils.Optional<Item_units_meauresCountAggregateOutputType> | number
          }
        }
      }
      items: {
        payload: Prisma.$itemsPayload<ExtArgs>
        fields: Prisma.itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findFirst: {
            args: Prisma.itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          findMany: {
            args: Prisma.itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>[]
          }
          create: {
            args: Prisma.itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          createMany: {
            args: Prisma.itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          update: {
            args: Prisma.itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          deleteMany: {
            args: Prisma.itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$itemsPayload>
          }
          aggregate: {
            args: Prisma.ItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItems>
          }
          groupBy: {
            args: Prisma.itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.itemsCountArgs<ExtArgs>
            result: $Utils.Optional<ItemsCountAggregateOutputType> | number
          }
        }
      }
      items_details: {
        payload: Prisma.$items_detailsPayload<ExtArgs>
        fields: Prisma.items_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.items_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$items_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.items_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$items_detailsPayload>
          }
          findFirst: {
            args: Prisma.items_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$items_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.items_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$items_detailsPayload>
          }
          findMany: {
            args: Prisma.items_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$items_detailsPayload>[]
          }
          create: {
            args: Prisma.items_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$items_detailsPayload>
          }
          createMany: {
            args: Prisma.items_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.items_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$items_detailsPayload>
          }
          update: {
            args: Prisma.items_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$items_detailsPayload>
          }
          deleteMany: {
            args: Prisma.items_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.items_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.items_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$items_detailsPayload>
          }
          aggregate: {
            args: Prisma.Items_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItems_details>
          }
          groupBy: {
            args: Prisma.items_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Items_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.items_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Items_detailsCountAggregateOutputType> | number
          }
        }
      }
      item_categories: {
        payload: Prisma.$item_categoriesPayload<ExtArgs>
        fields: Prisma.item_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.item_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.item_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_categoriesPayload>
          }
          findFirst: {
            args: Prisma.item_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.item_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_categoriesPayload>
          }
          findMany: {
            args: Prisma.item_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_categoriesPayload>[]
          }
          create: {
            args: Prisma.item_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_categoriesPayload>
          }
          createMany: {
            args: Prisma.item_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.item_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_categoriesPayload>
          }
          update: {
            args: Prisma.item_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.item_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.item_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.item_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Item_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem_categories>
          }
          groupBy: {
            args: Prisma.item_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Item_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.item_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Item_categoriesCountAggregateOutputType> | number
          }
        }
      }
      types: {
        payload: Prisma.$typesPayload<ExtArgs>
        fields: Prisma.typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typesPayload>
          }
          findFirst: {
            args: Prisma.typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typesPayload>
          }
          findMany: {
            args: Prisma.typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typesPayload>[]
          }
          create: {
            args: Prisma.typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typesPayload>
          }
          createMany: {
            args: Prisma.typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typesPayload>
          }
          update: {
            args: Prisma.typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typesPayload>
          }
          deleteMany: {
            args: Prisma.typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$typesPayload>
          }
          aggregate: {
            args: Prisma.TypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTypes>
          }
          groupBy: {
            args: Prisma.typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.typesCountArgs<ExtArgs>
            result: $Utils.Optional<TypesCountAggregateOutputType> | number
          }
        }
      }
      item_prices: {
        payload: Prisma.$item_pricesPayload<ExtArgs>
        fields: Prisma.item_pricesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.item_pricesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_pricesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.item_pricesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_pricesPayload>
          }
          findFirst: {
            args: Prisma.item_pricesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_pricesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.item_pricesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_pricesPayload>
          }
          findMany: {
            args: Prisma.item_pricesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_pricesPayload>[]
          }
          create: {
            args: Prisma.item_pricesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_pricesPayload>
          }
          createMany: {
            args: Prisma.item_pricesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.item_pricesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_pricesPayload>
          }
          update: {
            args: Prisma.item_pricesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_pricesPayload>
          }
          deleteMany: {
            args: Prisma.item_pricesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.item_pricesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.item_pricesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$item_pricesPayload>
          }
          aggregate: {
            args: Prisma.Item_pricesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem_prices>
          }
          groupBy: {
            args: Prisma.item_pricesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Item_pricesGroupByOutputType>[]
          }
          count: {
            args: Prisma.item_pricesCountArgs<ExtArgs>
            result: $Utils.Optional<Item_pricesCountAggregateOutputType> | number
          }
        }
      }
      dirties: {
        payload: Prisma.$dirtiesPayload<ExtArgs>
        fields: Prisma.dirtiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dirtiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirtiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dirtiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirtiesPayload>
          }
          findFirst: {
            args: Prisma.dirtiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirtiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dirtiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirtiesPayload>
          }
          findMany: {
            args: Prisma.dirtiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirtiesPayload>[]
          }
          create: {
            args: Prisma.dirtiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirtiesPayload>
          }
          createMany: {
            args: Prisma.dirtiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.dirtiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirtiesPayload>
          }
          update: {
            args: Prisma.dirtiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirtiesPayload>
          }
          deleteMany: {
            args: Prisma.dirtiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dirtiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dirtiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirtiesPayload>
          }
          aggregate: {
            args: Prisma.DirtiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirties>
          }
          groupBy: {
            args: Prisma.dirtiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirtiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.dirtiesCountArgs<ExtArgs>
            result: $Utils.Optional<DirtiesCountAggregateOutputType> | number
          }
        }
      }
      dirty_details: {
        payload: Prisma.$dirty_detailsPayload<ExtArgs>
        fields: Prisma.dirty_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dirty_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirty_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dirty_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirty_detailsPayload>
          }
          findFirst: {
            args: Prisma.dirty_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirty_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dirty_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirty_detailsPayload>
          }
          findMany: {
            args: Prisma.dirty_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirty_detailsPayload>[]
          }
          create: {
            args: Prisma.dirty_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirty_detailsPayload>
          }
          createMany: {
            args: Prisma.dirty_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.dirty_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirty_detailsPayload>
          }
          update: {
            args: Prisma.dirty_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirty_detailsPayload>
          }
          deleteMany: {
            args: Prisma.dirty_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dirty_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dirty_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dirty_detailsPayload>
          }
          aggregate: {
            args: Prisma.Dirty_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirty_details>
          }
          groupBy: {
            args: Prisma.dirty_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dirty_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.dirty_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Dirty_detailsCountAggregateOutputType> | number
          }
        }
      }
      customer_group_types: {
        payload: Prisma.$customer_group_typesPayload<ExtArgs>
        fields: Prisma.customer_group_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customer_group_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_group_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customer_group_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_group_typesPayload>
          }
          findFirst: {
            args: Prisma.customer_group_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_group_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customer_group_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_group_typesPayload>
          }
          findMany: {
            args: Prisma.customer_group_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_group_typesPayload>[]
          }
          create: {
            args: Prisma.customer_group_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_group_typesPayload>
          }
          createMany: {
            args: Prisma.customer_group_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.customer_group_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_group_typesPayload>
          }
          update: {
            args: Prisma.customer_group_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_group_typesPayload>
          }
          deleteMany: {
            args: Prisma.customer_group_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customer_group_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customer_group_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_group_typesPayload>
          }
          aggregate: {
            args: Prisma.Customer_group_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer_group_types>
          }
          groupBy: {
            args: Prisma.customer_group_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Customer_group_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.customer_group_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Customer_group_typesCountAggregateOutputType> | number
          }
        }
      }
      customer_groups: {
        payload: Prisma.$customer_groupsPayload<ExtArgs>
        fields: Prisma.customer_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customer_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customer_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_groupsPayload>
          }
          findFirst: {
            args: Prisma.customer_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customer_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_groupsPayload>
          }
          findMany: {
            args: Prisma.customer_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_groupsPayload>[]
          }
          create: {
            args: Prisma.customer_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_groupsPayload>
          }
          createMany: {
            args: Prisma.customer_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.customer_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_groupsPayload>
          }
          update: {
            args: Prisma.customer_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_groupsPayload>
          }
          deleteMany: {
            args: Prisma.customer_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customer_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customer_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customer_groupsPayload>
          }
          aggregate: {
            args: Prisma.Customer_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer_groups>
          }
          groupBy: {
            args: Prisma.customer_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Customer_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.customer_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Customer_groupsCountAggregateOutputType> | number
          }
        }
      }
      stock_locations: {
        payload: Prisma.$stock_locationsPayload<ExtArgs>
        fields: Prisma.stock_locationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stock_locationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_locationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stock_locationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_locationsPayload>
          }
          findFirst: {
            args: Prisma.stock_locationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_locationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stock_locationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_locationsPayload>
          }
          findMany: {
            args: Prisma.stock_locationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_locationsPayload>[]
          }
          create: {
            args: Prisma.stock_locationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_locationsPayload>
          }
          createMany: {
            args: Prisma.stock_locationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.stock_locationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_locationsPayload>
          }
          update: {
            args: Prisma.stock_locationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_locationsPayload>
          }
          deleteMany: {
            args: Prisma.stock_locationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stock_locationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.stock_locationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stock_locationsPayload>
          }
          aggregate: {
            args: Prisma.Stock_locationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock_locations>
          }
          groupBy: {
            args: Prisma.stock_locationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Stock_locationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.stock_locationsCountArgs<ExtArgs>
            result: $Utils.Optional<Stock_locationsCountAggregateOutputType> | number
          }
        }
      }
      shelfcounts: {
        payload: Prisma.$shelfcountsPayload<ExtArgs>
        fields: Prisma.shelfcountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shelfcountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shelfcountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcountsPayload>
          }
          findFirst: {
            args: Prisma.shelfcountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shelfcountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcountsPayload>
          }
          findMany: {
            args: Prisma.shelfcountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcountsPayload>[]
          }
          create: {
            args: Prisma.shelfcountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcountsPayload>
          }
          createMany: {
            args: Prisma.shelfcountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shelfcountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcountsPayload>
          }
          update: {
            args: Prisma.shelfcountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcountsPayload>
          }
          deleteMany: {
            args: Prisma.shelfcountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shelfcountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shelfcountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcountsPayload>
          }
          aggregate: {
            args: Prisma.ShelfcountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShelfcounts>
          }
          groupBy: {
            args: Prisma.shelfcountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShelfcountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.shelfcountsCountArgs<ExtArgs>
            result: $Utils.Optional<ShelfcountsCountAggregateOutputType> | number
          }
        }
      }
      shelfcount_details: {
        payload: Prisma.$shelfcount_detailsPayload<ExtArgs>
        fields: Prisma.shelfcount_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shelfcount_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcount_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shelfcount_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcount_detailsPayload>
          }
          findFirst: {
            args: Prisma.shelfcount_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcount_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shelfcount_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcount_detailsPayload>
          }
          findMany: {
            args: Prisma.shelfcount_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcount_detailsPayload>[]
          }
          create: {
            args: Prisma.shelfcount_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcount_detailsPayload>
          }
          createMany: {
            args: Prisma.shelfcount_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shelfcount_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcount_detailsPayload>
          }
          update: {
            args: Prisma.shelfcount_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcount_detailsPayload>
          }
          deleteMany: {
            args: Prisma.shelfcount_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shelfcount_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shelfcount_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shelfcount_detailsPayload>
          }
          aggregate: {
            args: Prisma.Shelfcount_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShelfcount_details>
          }
          groupBy: {
            args: Prisma.shelfcount_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Shelfcount_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.shelfcount_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Shelfcount_detailsCountAggregateOutputType> | number
          }
        }
      }
      damages: {
        payload: Prisma.$damagesPayload<ExtArgs>
        fields: Prisma.damagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.damagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.damagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damagesPayload>
          }
          findFirst: {
            args: Prisma.damagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.damagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damagesPayload>
          }
          findMany: {
            args: Prisma.damagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damagesPayload>[]
          }
          create: {
            args: Prisma.damagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damagesPayload>
          }
          createMany: {
            args: Prisma.damagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.damagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damagesPayload>
          }
          update: {
            args: Prisma.damagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damagesPayload>
          }
          deleteMany: {
            args: Prisma.damagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.damagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.damagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damagesPayload>
          }
          aggregate: {
            args: Prisma.DamagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDamages>
          }
          groupBy: {
            args: Prisma.damagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DamagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.damagesCountArgs<ExtArgs>
            result: $Utils.Optional<DamagesCountAggregateOutputType> | number
          }
        }
      }
      damage_details: {
        payload: Prisma.$damage_detailsPayload<ExtArgs>
        fields: Prisma.damage_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.damage_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damage_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.damage_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damage_detailsPayload>
          }
          findFirst: {
            args: Prisma.damage_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damage_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.damage_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damage_detailsPayload>
          }
          findMany: {
            args: Prisma.damage_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damage_detailsPayload>[]
          }
          create: {
            args: Prisma.damage_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damage_detailsPayload>
          }
          createMany: {
            args: Prisma.damage_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.damage_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damage_detailsPayload>
          }
          update: {
            args: Prisma.damage_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damage_detailsPayload>
          }
          deleteMany: {
            args: Prisma.damage_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.damage_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.damage_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$damage_detailsPayload>
          }
          aggregate: {
            args: Prisma.Damage_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDamage_details>
          }
          groupBy: {
            args: Prisma.damage_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Damage_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.damage_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Damage_detailsCountAggregateOutputType> | number
          }
        }
      }
      ships: {
        payload: Prisma.$shipsPayload<ExtArgs>
        fields: Prisma.shipsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shipsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shipsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shipsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shipsPayload>
          }
          findFirst: {
            args: Prisma.shipsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shipsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shipsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shipsPayload>
          }
          findMany: {
            args: Prisma.shipsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shipsPayload>[]
          }
          create: {
            args: Prisma.shipsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shipsPayload>
          }
          createMany: {
            args: Prisma.shipsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shipsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shipsPayload>
          }
          update: {
            args: Prisma.shipsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shipsPayload>
          }
          deleteMany: {
            args: Prisma.shipsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shipsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shipsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shipsPayload>
          }
          aggregate: {
            args: Prisma.ShipsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShips>
          }
          groupBy: {
            args: Prisma.shipsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShipsGroupByOutputType>[]
          }
          count: {
            args: Prisma.shipsCountArgs<ExtArgs>
            result: $Utils.Optional<ShipsCountAggregateOutputType> | number
          }
        }
      }
      new_linens: {
        payload: Prisma.$new_linensPayload<ExtArgs>
        fields: Prisma.new_linensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.new_linensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.new_linensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linensPayload>
          }
          findFirst: {
            args: Prisma.new_linensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.new_linensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linensPayload>
          }
          findMany: {
            args: Prisma.new_linensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linensPayload>[]
          }
          create: {
            args: Prisma.new_linensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linensPayload>
          }
          createMany: {
            args: Prisma.new_linensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.new_linensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linensPayload>
          }
          update: {
            args: Prisma.new_linensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linensPayload>
          }
          deleteMany: {
            args: Prisma.new_linensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.new_linensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.new_linensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linensPayload>
          }
          aggregate: {
            args: Prisma.New_linensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNew_linens>
          }
          groupBy: {
            args: Prisma.new_linensGroupByArgs<ExtArgs>
            result: $Utils.Optional<New_linensGroupByOutputType>[]
          }
          count: {
            args: Prisma.new_linensCountArgs<ExtArgs>
            result: $Utils.Optional<New_linensCountAggregateOutputType> | number
          }
        }
      }
      new_linen_details: {
        payload: Prisma.$new_linen_detailsPayload<ExtArgs>
        fields: Prisma.new_linen_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.new_linen_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linen_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.new_linen_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linen_detailsPayload>
          }
          findFirst: {
            args: Prisma.new_linen_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linen_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.new_linen_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linen_detailsPayload>
          }
          findMany: {
            args: Prisma.new_linen_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linen_detailsPayload>[]
          }
          create: {
            args: Prisma.new_linen_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linen_detailsPayload>
          }
          createMany: {
            args: Prisma.new_linen_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.new_linen_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linen_detailsPayload>
          }
          update: {
            args: Prisma.new_linen_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linen_detailsPayload>
          }
          deleteMany: {
            args: Prisma.new_linen_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.new_linen_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.new_linen_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$new_linen_detailsPayload>
          }
          aggregate: {
            args: Prisma.New_linen_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNew_linen_details>
          }
          groupBy: {
            args: Prisma.new_linen_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<New_linen_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.new_linen_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<New_linen_detailsCountAggregateOutputType> | number
          }
        }
      }
      repair_washs: {
        payload: Prisma.$repair_washsPayload<ExtArgs>
        fields: Prisma.repair_washsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.repair_washsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_washsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.repair_washsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_washsPayload>
          }
          findFirst: {
            args: Prisma.repair_washsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_washsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.repair_washsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_washsPayload>
          }
          findMany: {
            args: Prisma.repair_washsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_washsPayload>[]
          }
          create: {
            args: Prisma.repair_washsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_washsPayload>
          }
          createMany: {
            args: Prisma.repair_washsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.repair_washsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_washsPayload>
          }
          update: {
            args: Prisma.repair_washsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_washsPayload>
          }
          deleteMany: {
            args: Prisma.repair_washsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.repair_washsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.repair_washsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_washsPayload>
          }
          aggregate: {
            args: Prisma.Repair_washsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepair_washs>
          }
          groupBy: {
            args: Prisma.repair_washsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Repair_washsGroupByOutputType>[]
          }
          count: {
            args: Prisma.repair_washsCountArgs<ExtArgs>
            result: $Utils.Optional<Repair_washsCountAggregateOutputType> | number
          }
        }
      }
      repair_wash_details: {
        payload: Prisma.$repair_wash_detailsPayload<ExtArgs>
        fields: Prisma.repair_wash_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.repair_wash_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_wash_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.repair_wash_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_wash_detailsPayload>
          }
          findFirst: {
            args: Prisma.repair_wash_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_wash_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.repair_wash_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_wash_detailsPayload>
          }
          findMany: {
            args: Prisma.repair_wash_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_wash_detailsPayload>[]
          }
          create: {
            args: Prisma.repair_wash_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_wash_detailsPayload>
          }
          createMany: {
            args: Prisma.repair_wash_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.repair_wash_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_wash_detailsPayload>
          }
          update: {
            args: Prisma.repair_wash_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_wash_detailsPayload>
          }
          deleteMany: {
            args: Prisma.repair_wash_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.repair_wash_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.repair_wash_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$repair_wash_detailsPayload>
          }
          aggregate: {
            args: Prisma.Repair_wash_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepair_wash_details>
          }
          groupBy: {
            args: Prisma.repair_wash_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Repair_wash_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.repair_wash_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Repair_wash_detailsCountAggregateOutputType> | number
          }
        }
      }
      cleans: {
        payload: Prisma.$cleansPayload<ExtArgs>
        fields: Prisma.cleansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cleansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cleansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleansPayload>
          }
          findFirst: {
            args: Prisma.cleansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cleansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleansPayload>
          }
          findMany: {
            args: Prisma.cleansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleansPayload>[]
          }
          create: {
            args: Prisma.cleansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleansPayload>
          }
          createMany: {
            args: Prisma.cleansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cleansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleansPayload>
          }
          update: {
            args: Prisma.cleansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleansPayload>
          }
          deleteMany: {
            args: Prisma.cleansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cleansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cleansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleansPayload>
          }
          aggregate: {
            args: Prisma.CleansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleans>
          }
          groupBy: {
            args: Prisma.cleansGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleansGroupByOutputType>[]
          }
          count: {
            args: Prisma.cleansCountArgs<ExtArgs>
            result: $Utils.Optional<CleansCountAggregateOutputType> | number
          }
        }
      }
      clean_details: {
        payload: Prisma.$clean_detailsPayload<ExtArgs>
        fields: Prisma.clean_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clean_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clean_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clean_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clean_detailsPayload>
          }
          findFirst: {
            args: Prisma.clean_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clean_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clean_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clean_detailsPayload>
          }
          findMany: {
            args: Prisma.clean_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clean_detailsPayload>[]
          }
          create: {
            args: Prisma.clean_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clean_detailsPayload>
          }
          createMany: {
            args: Prisma.clean_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clean_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clean_detailsPayload>
          }
          update: {
            args: Prisma.clean_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clean_detailsPayload>
          }
          deleteMany: {
            args: Prisma.clean_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clean_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clean_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clean_detailsPayload>
          }
          aggregate: {
            args: Prisma.Clean_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClean_details>
          }
          groupBy: {
            args: Prisma.clean_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Clean_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.clean_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Clean_detailsCountAggregateOutputType> | number
          }
        }
      }
      return_washs: {
        payload: Prisma.$return_washsPayload<ExtArgs>
        fields: Prisma.return_washsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.return_washsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_washsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.return_washsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_washsPayload>
          }
          findFirst: {
            args: Prisma.return_washsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_washsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.return_washsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_washsPayload>
          }
          findMany: {
            args: Prisma.return_washsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_washsPayload>[]
          }
          create: {
            args: Prisma.return_washsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_washsPayload>
          }
          createMany: {
            args: Prisma.return_washsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.return_washsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_washsPayload>
          }
          update: {
            args: Prisma.return_washsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_washsPayload>
          }
          deleteMany: {
            args: Prisma.return_washsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.return_washsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.return_washsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_washsPayload>
          }
          aggregate: {
            args: Prisma.Return_washsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturn_washs>
          }
          groupBy: {
            args: Prisma.return_washsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Return_washsGroupByOutputType>[]
          }
          count: {
            args: Prisma.return_washsCountArgs<ExtArgs>
            result: $Utils.Optional<Return_washsCountAggregateOutputType> | number
          }
        }
      }
      retrun_wash_details: {
        payload: Prisma.$retrun_wash_detailsPayload<ExtArgs>
        fields: Prisma.retrun_wash_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.retrun_wash_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$retrun_wash_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.retrun_wash_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$retrun_wash_detailsPayload>
          }
          findFirst: {
            args: Prisma.retrun_wash_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$retrun_wash_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.retrun_wash_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$retrun_wash_detailsPayload>
          }
          findMany: {
            args: Prisma.retrun_wash_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$retrun_wash_detailsPayload>[]
          }
          create: {
            args: Prisma.retrun_wash_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$retrun_wash_detailsPayload>
          }
          createMany: {
            args: Prisma.retrun_wash_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.retrun_wash_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$retrun_wash_detailsPayload>
          }
          update: {
            args: Prisma.retrun_wash_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$retrun_wash_detailsPayload>
          }
          deleteMany: {
            args: Prisma.retrun_wash_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.retrun_wash_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.retrun_wash_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$retrun_wash_detailsPayload>
          }
          aggregate: {
            args: Prisma.Retrun_wash_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRetrun_wash_details>
          }
          groupBy: {
            args: Prisma.retrun_wash_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Retrun_wash_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.retrun_wash_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Retrun_wash_detailsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: userOmit
    verification_token?: verification_tokenOmit
    password_reset_token?: password_reset_tokenOmit
    notifications?: notificationsOmit
    sale_offices?: sale_officesOmit
    departments?: departmentsOmit
    factory_sale_office?: factory_sale_officeOmit
    factories?: factoriesOmit
    machines?: machinesOmit
    contact?: contactOmit
    materials?: materialsOmit
    material_types?: material_typesOmit
    item_units_meaures?: item_units_meauresOmit
    items?: itemsOmit
    items_details?: items_detailsOmit
    item_categories?: item_categoriesOmit
    types?: typesOmit
    item_prices?: item_pricesOmit
    dirties?: dirtiesOmit
    dirty_details?: dirty_detailsOmit
    customer_group_types?: customer_group_typesOmit
    customer_groups?: customer_groupsOmit
    stock_locations?: stock_locationsOmit
    shelfcounts?: shelfcountsOmit
    shelfcount_details?: shelfcount_detailsOmit
    damages?: damagesOmit
    damage_details?: damage_detailsOmit
    ships?: shipsOmit
    new_linens?: new_linensOmit
    new_linen_details?: new_linen_detailsOmit
    repair_washs?: repair_washsOmit
    repair_wash_details?: repair_wash_detailsOmit
    cleans?: cleansOmit
    clean_details?: clean_detailsOmit
    return_washs?: return_washsOmit
    retrun_wash_details?: retrun_wash_detailsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    permission_id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    permission_id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    permission_id: number | null
    email_verified_at: Date | null
    password: string | null
    two_factor_secret: string | null
    two_factor_recovery_codes: string | null
    two_factor_confirmed_at: Date | null
    is_two_factor_enabled: boolean | null
    remember_token: string | null
    create_at: Date | null
    update_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    permission_id: number | null
    email_verified_at: Date | null
    password: string | null
    two_factor_secret: string | null
    two_factor_recovery_codes: string | null
    two_factor_confirmed_at: Date | null
    is_two_factor_enabled: boolean | null
    remember_token: string | null
    create_at: Date | null
    update_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    permission_id: number
    email_verified_at: number
    password: number
    two_factor_secret: number
    two_factor_recovery_codes: number
    two_factor_confirmed_at: number
    is_two_factor_enabled: number
    remember_token: number
    create_at: number
    update_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    permission_id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    permission_id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    permission_id?: true
    email_verified_at?: true
    password?: true
    two_factor_secret?: true
    two_factor_recovery_codes?: true
    two_factor_confirmed_at?: true
    is_two_factor_enabled?: true
    remember_token?: true
    create_at?: true
    update_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    permission_id?: true
    email_verified_at?: true
    password?: true
    two_factor_secret?: true
    two_factor_recovery_codes?: true
    two_factor_confirmed_at?: true
    is_two_factor_enabled?: true
    remember_token?: true
    create_at?: true
    update_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    permission_id?: true
    email_verified_at?: true
    password?: true
    two_factor_secret?: true
    two_factor_recovery_codes?: true
    two_factor_confirmed_at?: true
    is_two_factor_enabled?: true
    remember_token?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    name: string
    email: string
    permission_id: number
    email_verified_at: Date | null
    password: string
    two_factor_secret: string | null
    two_factor_recovery_codes: string | null
    two_factor_confirmed_at: Date | null
    is_two_factor_enabled: boolean
    remember_token: string | null
    create_at: Date
    update_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    permission_id?: boolean
    email_verified_at?: boolean
    password?: boolean
    two_factor_secret?: boolean
    two_factor_recovery_codes?: boolean
    two_factor_confirmed_at?: boolean
    is_two_factor_enabled?: boolean
    remember_token?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    permission_id?: boolean
    email_verified_at?: boolean
    password?: boolean
    two_factor_secret?: boolean
    two_factor_recovery_codes?: boolean
    two_factor_confirmed_at?: boolean
    is_two_factor_enabled?: boolean
    remember_token?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "permission_id" | "email_verified_at" | "password" | "two_factor_secret" | "two_factor_recovery_codes" | "two_factor_confirmed_at" | "is_two_factor_enabled" | "remember_token" | "create_at" | "update_at", ExtArgs["result"]["user"]>

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      permission_id: number
      email_verified_at: Date | null
      password: string
      two_factor_secret: string | null
      two_factor_recovery_codes: string | null
      two_factor_confirmed_at: Date | null
      is_two_factor_enabled: boolean
      remember_token: string | null
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly permission_id: FieldRef<"user", 'Int'>
    readonly email_verified_at: FieldRef<"user", 'DateTime'>
    readonly password: FieldRef<"user", 'String'>
    readonly two_factor_secret: FieldRef<"user", 'String'>
    readonly two_factor_recovery_codes: FieldRef<"user", 'String'>
    readonly two_factor_confirmed_at: FieldRef<"user", 'DateTime'>
    readonly is_two_factor_enabled: FieldRef<"user", 'Boolean'>
    readonly remember_token: FieldRef<"user", 'String'>
    readonly create_at: FieldRef<"user", 'DateTime'>
    readonly update_at: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
  }


  /**
   * Model verification_token
   */

  export type AggregateVerification_token = {
    _count: Verification_tokenCountAggregateOutputType | null
    _avg: Verification_tokenAvgAggregateOutputType | null
    _sum: Verification_tokenSumAggregateOutputType | null
    _min: Verification_tokenMinAggregateOutputType | null
    _max: Verification_tokenMaxAggregateOutputType | null
  }

  export type Verification_tokenAvgAggregateOutputType = {
    id: number | null
  }

  export type Verification_tokenSumAggregateOutputType = {
    id: number | null
  }

  export type Verification_tokenMinAggregateOutputType = {
    id: number | null
    email: string | null
    token: string | null
    expires: Date | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Verification_tokenMaxAggregateOutputType = {
    id: number | null
    email: string | null
    token: string | null
    expires: Date | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Verification_tokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Verification_tokenAvgAggregateInputType = {
    id?: true
  }

  export type Verification_tokenSumAggregateInputType = {
    id?: true
  }

  export type Verification_tokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    create_at?: true
    update_at?: true
  }

  export type Verification_tokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    create_at?: true
    update_at?: true
  }

  export type Verification_tokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Verification_tokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verification_token to aggregate.
     */
    where?: verification_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verification_tokens to fetch.
     */
    orderBy?: verification_tokenOrderByWithRelationInput | verification_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: verification_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verification_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned verification_tokens
    **/
    _count?: true | Verification_tokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Verification_tokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Verification_tokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Verification_tokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Verification_tokenMaxAggregateInputType
  }

  export type GetVerification_tokenAggregateType<T extends Verification_tokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification_token]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification_token[P]>
      : GetScalarType<T[P], AggregateVerification_token[P]>
  }




  export type verification_tokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: verification_tokenWhereInput
    orderBy?: verification_tokenOrderByWithAggregationInput | verification_tokenOrderByWithAggregationInput[]
    by: Verification_tokenScalarFieldEnum[] | Verification_tokenScalarFieldEnum
    having?: verification_tokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Verification_tokenCountAggregateInputType | true
    _avg?: Verification_tokenAvgAggregateInputType
    _sum?: Verification_tokenSumAggregateInputType
    _min?: Verification_tokenMinAggregateInputType
    _max?: Verification_tokenMaxAggregateInputType
  }

  export type Verification_tokenGroupByOutputType = {
    id: number
    email: string
    token: string
    expires: Date
    create_at: Date
    update_at: Date
    _count: Verification_tokenCountAggregateOutputType | null
    _avg: Verification_tokenAvgAggregateOutputType | null
    _sum: Verification_tokenSumAggregateOutputType | null
    _min: Verification_tokenMinAggregateOutputType | null
    _max: Verification_tokenMaxAggregateOutputType | null
  }

  type GetVerification_tokenGroupByPayload<T extends verification_tokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Verification_tokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Verification_tokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Verification_tokenGroupByOutputType[P]>
            : GetScalarType<T[P], Verification_tokenGroupByOutputType[P]>
        }
      >
    >


  export type verification_tokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["verification_token"]>



  export type verification_tokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type verification_tokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires" | "create_at" | "update_at", ExtArgs["result"]["verification_token"]>

  export type $verification_tokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "verification_token"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      token: string
      expires: Date
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["verification_token"]>
    composites: {}
  }

  type verification_tokenGetPayload<S extends boolean | null | undefined | verification_tokenDefaultArgs> = $Result.GetResult<Prisma.$verification_tokenPayload, S>

  type verification_tokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<verification_tokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Verification_tokenCountAggregateInputType | true
    }

  export interface verification_tokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['verification_token'], meta: { name: 'verification_token' } }
    /**
     * Find zero or one Verification_token that matches the filter.
     * @param {verification_tokenFindUniqueArgs} args - Arguments to find a Verification_token
     * @example
     * // Get one Verification_token
     * const verification_token = await prisma.verification_token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends verification_tokenFindUniqueArgs>(args: SelectSubset<T, verification_tokenFindUniqueArgs<ExtArgs>>): Prisma__verification_tokenClient<$Result.GetResult<Prisma.$verification_tokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification_token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {verification_tokenFindUniqueOrThrowArgs} args - Arguments to find a Verification_token
     * @example
     * // Get one Verification_token
     * const verification_token = await prisma.verification_token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends verification_tokenFindUniqueOrThrowArgs>(args: SelectSubset<T, verification_tokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__verification_tokenClient<$Result.GetResult<Prisma.$verification_tokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification_token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_tokenFindFirstArgs} args - Arguments to find a Verification_token
     * @example
     * // Get one Verification_token
     * const verification_token = await prisma.verification_token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends verification_tokenFindFirstArgs>(args?: SelectSubset<T, verification_tokenFindFirstArgs<ExtArgs>>): Prisma__verification_tokenClient<$Result.GetResult<Prisma.$verification_tokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification_token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_tokenFindFirstOrThrowArgs} args - Arguments to find a Verification_token
     * @example
     * // Get one Verification_token
     * const verification_token = await prisma.verification_token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends verification_tokenFindFirstOrThrowArgs>(args?: SelectSubset<T, verification_tokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__verification_tokenClient<$Result.GetResult<Prisma.$verification_tokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verification_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_tokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verification_tokens
     * const verification_tokens = await prisma.verification_token.findMany()
     * 
     * // Get first 10 Verification_tokens
     * const verification_tokens = await prisma.verification_token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verification_tokenWithIdOnly = await prisma.verification_token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends verification_tokenFindManyArgs>(args?: SelectSubset<T, verification_tokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$verification_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification_token.
     * @param {verification_tokenCreateArgs} args - Arguments to create a Verification_token.
     * @example
     * // Create one Verification_token
     * const Verification_token = await prisma.verification_token.create({
     *   data: {
     *     // ... data to create a Verification_token
     *   }
     * })
     * 
     */
    create<T extends verification_tokenCreateArgs>(args: SelectSubset<T, verification_tokenCreateArgs<ExtArgs>>): Prisma__verification_tokenClient<$Result.GetResult<Prisma.$verification_tokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verification_tokens.
     * @param {verification_tokenCreateManyArgs} args - Arguments to create many Verification_tokens.
     * @example
     * // Create many Verification_tokens
     * const verification_token = await prisma.verification_token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends verification_tokenCreateManyArgs>(args?: SelectSubset<T, verification_tokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Verification_token.
     * @param {verification_tokenDeleteArgs} args - Arguments to delete one Verification_token.
     * @example
     * // Delete one Verification_token
     * const Verification_token = await prisma.verification_token.delete({
     *   where: {
     *     // ... filter to delete one Verification_token
     *   }
     * })
     * 
     */
    delete<T extends verification_tokenDeleteArgs>(args: SelectSubset<T, verification_tokenDeleteArgs<ExtArgs>>): Prisma__verification_tokenClient<$Result.GetResult<Prisma.$verification_tokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification_token.
     * @param {verification_tokenUpdateArgs} args - Arguments to update one Verification_token.
     * @example
     * // Update one Verification_token
     * const verification_token = await prisma.verification_token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends verification_tokenUpdateArgs>(args: SelectSubset<T, verification_tokenUpdateArgs<ExtArgs>>): Prisma__verification_tokenClient<$Result.GetResult<Prisma.$verification_tokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verification_tokens.
     * @param {verification_tokenDeleteManyArgs} args - Arguments to filter Verification_tokens to delete.
     * @example
     * // Delete a few Verification_tokens
     * const { count } = await prisma.verification_token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends verification_tokenDeleteManyArgs>(args?: SelectSubset<T, verification_tokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_tokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verification_tokens
     * const verification_token = await prisma.verification_token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends verification_tokenUpdateManyArgs>(args: SelectSubset<T, verification_tokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Verification_token.
     * @param {verification_tokenUpsertArgs} args - Arguments to update or create a Verification_token.
     * @example
     * // Update or create a Verification_token
     * const verification_token = await prisma.verification_token.upsert({
     *   create: {
     *     // ... data to create a Verification_token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification_token we want to update
     *   }
     * })
     */
    upsert<T extends verification_tokenUpsertArgs>(args: SelectSubset<T, verification_tokenUpsertArgs<ExtArgs>>): Prisma__verification_tokenClient<$Result.GetResult<Prisma.$verification_tokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verification_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_tokenCountArgs} args - Arguments to filter Verification_tokens to count.
     * @example
     * // Count the number of Verification_tokens
     * const count = await prisma.verification_token.count({
     *   where: {
     *     // ... the filter for the Verification_tokens we want to count
     *   }
     * })
    **/
    count<T extends verification_tokenCountArgs>(
      args?: Subset<T, verification_tokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Verification_tokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Verification_tokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Verification_tokenAggregateArgs>(args: Subset<T, Verification_tokenAggregateArgs>): Prisma.PrismaPromise<GetVerification_tokenAggregateType<T>>

    /**
     * Group by Verification_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {verification_tokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends verification_tokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: verification_tokenGroupByArgs['orderBy'] }
        : { orderBy?: verification_tokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, verification_tokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerification_tokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the verification_token model
   */
  readonly fields: verification_tokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for verification_token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__verification_tokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the verification_token model
   */
  interface verification_tokenFieldRefs {
    readonly id: FieldRef<"verification_token", 'Int'>
    readonly email: FieldRef<"verification_token", 'String'>
    readonly token: FieldRef<"verification_token", 'String'>
    readonly expires: FieldRef<"verification_token", 'DateTime'>
    readonly create_at: FieldRef<"verification_token", 'DateTime'>
    readonly update_at: FieldRef<"verification_token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * verification_token findUnique
   */
  export type verification_tokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
    /**
     * Filter, which verification_token to fetch.
     */
    where: verification_tokenWhereUniqueInput
  }

  /**
   * verification_token findUniqueOrThrow
   */
  export type verification_tokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
    /**
     * Filter, which verification_token to fetch.
     */
    where: verification_tokenWhereUniqueInput
  }

  /**
   * verification_token findFirst
   */
  export type verification_tokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
    /**
     * Filter, which verification_token to fetch.
     */
    where?: verification_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verification_tokens to fetch.
     */
    orderBy?: verification_tokenOrderByWithRelationInput | verification_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verification_tokens.
     */
    cursor?: verification_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verification_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verification_tokens.
     */
    distinct?: Verification_tokenScalarFieldEnum | Verification_tokenScalarFieldEnum[]
  }

  /**
   * verification_token findFirstOrThrow
   */
  export type verification_tokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
    /**
     * Filter, which verification_token to fetch.
     */
    where?: verification_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verification_tokens to fetch.
     */
    orderBy?: verification_tokenOrderByWithRelationInput | verification_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for verification_tokens.
     */
    cursor?: verification_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verification_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of verification_tokens.
     */
    distinct?: Verification_tokenScalarFieldEnum | Verification_tokenScalarFieldEnum[]
  }

  /**
   * verification_token findMany
   */
  export type verification_tokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
    /**
     * Filter, which verification_tokens to fetch.
     */
    where?: verification_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of verification_tokens to fetch.
     */
    orderBy?: verification_tokenOrderByWithRelationInput | verification_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing verification_tokens.
     */
    cursor?: verification_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` verification_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` verification_tokens.
     */
    skip?: number
    distinct?: Verification_tokenScalarFieldEnum | Verification_tokenScalarFieldEnum[]
  }

  /**
   * verification_token create
   */
  export type verification_tokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
    /**
     * The data needed to create a verification_token.
     */
    data: XOR<verification_tokenCreateInput, verification_tokenUncheckedCreateInput>
  }

  /**
   * verification_token createMany
   */
  export type verification_tokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many verification_tokens.
     */
    data: verification_tokenCreateManyInput | verification_tokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * verification_token update
   */
  export type verification_tokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
    /**
     * The data needed to update a verification_token.
     */
    data: XOR<verification_tokenUpdateInput, verification_tokenUncheckedUpdateInput>
    /**
     * Choose, which verification_token to update.
     */
    where: verification_tokenWhereUniqueInput
  }

  /**
   * verification_token updateMany
   */
  export type verification_tokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update verification_tokens.
     */
    data: XOR<verification_tokenUpdateManyMutationInput, verification_tokenUncheckedUpdateManyInput>
    /**
     * Filter which verification_tokens to update
     */
    where?: verification_tokenWhereInput
    /**
     * Limit how many verification_tokens to update.
     */
    limit?: number
  }

  /**
   * verification_token upsert
   */
  export type verification_tokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
    /**
     * The filter to search for the verification_token to update in case it exists.
     */
    where: verification_tokenWhereUniqueInput
    /**
     * In case the verification_token found by the `where` argument doesn't exist, create a new verification_token with this data.
     */
    create: XOR<verification_tokenCreateInput, verification_tokenUncheckedCreateInput>
    /**
     * In case the verification_token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<verification_tokenUpdateInput, verification_tokenUncheckedUpdateInput>
  }

  /**
   * verification_token delete
   */
  export type verification_tokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
    /**
     * Filter which verification_token to delete.
     */
    where: verification_tokenWhereUniqueInput
  }

  /**
   * verification_token deleteMany
   */
  export type verification_tokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which verification_tokens to delete
     */
    where?: verification_tokenWhereInput
    /**
     * Limit how many verification_tokens to delete.
     */
    limit?: number
  }

  /**
   * verification_token without action
   */
  export type verification_tokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the verification_token
     */
    select?: verification_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the verification_token
     */
    omit?: verification_tokenOmit<ExtArgs> | null
  }


  /**
   * Model password_reset_token
   */

  export type AggregatePassword_reset_token = {
    _count: Password_reset_tokenCountAggregateOutputType | null
    _min: Password_reset_tokenMinAggregateOutputType | null
    _max: Password_reset_tokenMaxAggregateOutputType | null
  }

  export type Password_reset_tokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Password_reset_tokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Password_reset_tokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Password_reset_tokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    create_at?: true
    update_at?: true
  }

  export type Password_reset_tokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    create_at?: true
    update_at?: true
  }

  export type Password_reset_tokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Password_reset_tokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_token to aggregate.
     */
    where?: password_reset_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokenOrderByWithRelationInput | password_reset_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: password_reset_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned password_reset_tokens
    **/
    _count?: true | Password_reset_tokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_reset_tokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_reset_tokenMaxAggregateInputType
  }

  export type GetPassword_reset_tokenAggregateType<T extends Password_reset_tokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_reset_token]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_reset_token[P]>
      : GetScalarType<T[P], AggregatePassword_reset_token[P]>
  }




  export type password_reset_tokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_reset_tokenWhereInput
    orderBy?: password_reset_tokenOrderByWithAggregationInput | password_reset_tokenOrderByWithAggregationInput[]
    by: Password_reset_tokenScalarFieldEnum[] | Password_reset_tokenScalarFieldEnum
    having?: password_reset_tokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_reset_tokenCountAggregateInputType | true
    _min?: Password_reset_tokenMinAggregateInputType
    _max?: Password_reset_tokenMaxAggregateInputType
  }

  export type Password_reset_tokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    create_at: Date
    update_at: Date
    _count: Password_reset_tokenCountAggregateOutputType | null
    _min: Password_reset_tokenMinAggregateOutputType | null
    _max: Password_reset_tokenMaxAggregateOutputType | null
  }

  type GetPassword_reset_tokenGroupByPayload<T extends password_reset_tokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Password_reset_tokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Password_reset_tokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Password_reset_tokenGroupByOutputType[P]>
            : GetScalarType<T[P], Password_reset_tokenGroupByOutputType[P]>
        }
      >
    >


  export type password_reset_tokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["password_reset_token"]>



  export type password_reset_tokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type password_reset_tokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires" | "create_at" | "update_at", ExtArgs["result"]["password_reset_token"]>

  export type $password_reset_tokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "password_reset_token"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["password_reset_token"]>
    composites: {}
  }

  type password_reset_tokenGetPayload<S extends boolean | null | undefined | password_reset_tokenDefaultArgs> = $Result.GetResult<Prisma.$password_reset_tokenPayload, S>

  type password_reset_tokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<password_reset_tokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Password_reset_tokenCountAggregateInputType | true
    }

  export interface password_reset_tokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['password_reset_token'], meta: { name: 'password_reset_token' } }
    /**
     * Find zero or one Password_reset_token that matches the filter.
     * @param {password_reset_tokenFindUniqueArgs} args - Arguments to find a Password_reset_token
     * @example
     * // Get one Password_reset_token
     * const password_reset_token = await prisma.password_reset_token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends password_reset_tokenFindUniqueArgs>(args: SelectSubset<T, password_reset_tokenFindUniqueArgs<ExtArgs>>): Prisma__password_reset_tokenClient<$Result.GetResult<Prisma.$password_reset_tokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password_reset_token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {password_reset_tokenFindUniqueOrThrowArgs} args - Arguments to find a Password_reset_token
     * @example
     * // Get one Password_reset_token
     * const password_reset_token = await prisma.password_reset_token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends password_reset_tokenFindUniqueOrThrowArgs>(args: SelectSubset<T, password_reset_tokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokenClient<$Result.GetResult<Prisma.$password_reset_tokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokenFindFirstArgs} args - Arguments to find a Password_reset_token
     * @example
     * // Get one Password_reset_token
     * const password_reset_token = await prisma.password_reset_token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends password_reset_tokenFindFirstArgs>(args?: SelectSubset<T, password_reset_tokenFindFirstArgs<ExtArgs>>): Prisma__password_reset_tokenClient<$Result.GetResult<Prisma.$password_reset_tokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokenFindFirstOrThrowArgs} args - Arguments to find a Password_reset_token
     * @example
     * // Get one Password_reset_token
     * const password_reset_token = await prisma.password_reset_token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends password_reset_tokenFindFirstOrThrowArgs>(args?: SelectSubset<T, password_reset_tokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokenClient<$Result.GetResult<Prisma.$password_reset_tokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_token.findMany()
     * 
     * // Get first 10 Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const password_reset_tokenWithIdOnly = await prisma.password_reset_token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends password_reset_tokenFindManyArgs>(args?: SelectSubset<T, password_reset_tokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password_reset_token.
     * @param {password_reset_tokenCreateArgs} args - Arguments to create a Password_reset_token.
     * @example
     * // Create one Password_reset_token
     * const Password_reset_token = await prisma.password_reset_token.create({
     *   data: {
     *     // ... data to create a Password_reset_token
     *   }
     * })
     * 
     */
    create<T extends password_reset_tokenCreateArgs>(args: SelectSubset<T, password_reset_tokenCreateArgs<ExtArgs>>): Prisma__password_reset_tokenClient<$Result.GetResult<Prisma.$password_reset_tokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Password_reset_tokens.
     * @param {password_reset_tokenCreateManyArgs} args - Arguments to create many Password_reset_tokens.
     * @example
     * // Create many Password_reset_tokens
     * const password_reset_token = await prisma.password_reset_token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends password_reset_tokenCreateManyArgs>(args?: SelectSubset<T, password_reset_tokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Password_reset_token.
     * @param {password_reset_tokenDeleteArgs} args - Arguments to delete one Password_reset_token.
     * @example
     * // Delete one Password_reset_token
     * const Password_reset_token = await prisma.password_reset_token.delete({
     *   where: {
     *     // ... filter to delete one Password_reset_token
     *   }
     * })
     * 
     */
    delete<T extends password_reset_tokenDeleteArgs>(args: SelectSubset<T, password_reset_tokenDeleteArgs<ExtArgs>>): Prisma__password_reset_tokenClient<$Result.GetResult<Prisma.$password_reset_tokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password_reset_token.
     * @param {password_reset_tokenUpdateArgs} args - Arguments to update one Password_reset_token.
     * @example
     * // Update one Password_reset_token
     * const password_reset_token = await prisma.password_reset_token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends password_reset_tokenUpdateArgs>(args: SelectSubset<T, password_reset_tokenUpdateArgs<ExtArgs>>): Prisma__password_reset_tokenClient<$Result.GetResult<Prisma.$password_reset_tokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Password_reset_tokens.
     * @param {password_reset_tokenDeleteManyArgs} args - Arguments to filter Password_reset_tokens to delete.
     * @example
     * // Delete a few Password_reset_tokens
     * const { count } = await prisma.password_reset_token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends password_reset_tokenDeleteManyArgs>(args?: SelectSubset<T, password_reset_tokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_reset_tokens
     * const password_reset_token = await prisma.password_reset_token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends password_reset_tokenUpdateManyArgs>(args: SelectSubset<T, password_reset_tokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Password_reset_token.
     * @param {password_reset_tokenUpsertArgs} args - Arguments to update or create a Password_reset_token.
     * @example
     * // Update or create a Password_reset_token
     * const password_reset_token = await prisma.password_reset_token.upsert({
     *   create: {
     *     // ... data to create a Password_reset_token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_reset_token we want to update
     *   }
     * })
     */
    upsert<T extends password_reset_tokenUpsertArgs>(args: SelectSubset<T, password_reset_tokenUpsertArgs<ExtArgs>>): Prisma__password_reset_tokenClient<$Result.GetResult<Prisma.$password_reset_tokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokenCountArgs} args - Arguments to filter Password_reset_tokens to count.
     * @example
     * // Count the number of Password_reset_tokens
     * const count = await prisma.password_reset_token.count({
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to count
     *   }
     * })
    **/
    count<T extends password_reset_tokenCountArgs>(
      args?: Subset<T, password_reset_tokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_reset_tokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_reset_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_reset_tokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_reset_tokenAggregateArgs>(args: Subset<T, Password_reset_tokenAggregateArgs>): Prisma.PrismaPromise<GetPassword_reset_tokenAggregateType<T>>

    /**
     * Group by Password_reset_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends password_reset_tokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: password_reset_tokenGroupByArgs['orderBy'] }
        : { orderBy?: password_reset_tokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, password_reset_tokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_reset_tokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the password_reset_token model
   */
  readonly fields: password_reset_tokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for password_reset_token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__password_reset_tokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the password_reset_token model
   */
  interface password_reset_tokenFieldRefs {
    readonly id: FieldRef<"password_reset_token", 'String'>
    readonly email: FieldRef<"password_reset_token", 'String'>
    readonly token: FieldRef<"password_reset_token", 'String'>
    readonly expires: FieldRef<"password_reset_token", 'DateTime'>
    readonly create_at: FieldRef<"password_reset_token", 'DateTime'>
    readonly update_at: FieldRef<"password_reset_token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * password_reset_token findUnique
   */
  export type password_reset_tokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_token to fetch.
     */
    where: password_reset_tokenWhereUniqueInput
  }

  /**
   * password_reset_token findUniqueOrThrow
   */
  export type password_reset_tokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_token to fetch.
     */
    where: password_reset_tokenWhereUniqueInput
  }

  /**
   * password_reset_token findFirst
   */
  export type password_reset_tokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_token to fetch.
     */
    where?: password_reset_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokenOrderByWithRelationInput | password_reset_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokenScalarFieldEnum | Password_reset_tokenScalarFieldEnum[]
  }

  /**
   * password_reset_token findFirstOrThrow
   */
  export type password_reset_tokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_token to fetch.
     */
    where?: password_reset_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokenOrderByWithRelationInput | password_reset_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokenScalarFieldEnum | Password_reset_tokenScalarFieldEnum[]
  }

  /**
   * password_reset_token findMany
   */
  export type password_reset_tokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokenOrderByWithRelationInput | password_reset_tokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing password_reset_tokens.
     */
    cursor?: password_reset_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    distinct?: Password_reset_tokenScalarFieldEnum | Password_reset_tokenScalarFieldEnum[]
  }

  /**
   * password_reset_token create
   */
  export type password_reset_tokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
    /**
     * The data needed to create a password_reset_token.
     */
    data: XOR<password_reset_tokenCreateInput, password_reset_tokenUncheckedCreateInput>
  }

  /**
   * password_reset_token createMany
   */
  export type password_reset_tokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many password_reset_tokens.
     */
    data: password_reset_tokenCreateManyInput | password_reset_tokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * password_reset_token update
   */
  export type password_reset_tokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
    /**
     * The data needed to update a password_reset_token.
     */
    data: XOR<password_reset_tokenUpdateInput, password_reset_tokenUncheckedUpdateInput>
    /**
     * Choose, which password_reset_token to update.
     */
    where: password_reset_tokenWhereUniqueInput
  }

  /**
   * password_reset_token updateMany
   */
  export type password_reset_tokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update password_reset_tokens.
     */
    data: XOR<password_reset_tokenUpdateManyMutationInput, password_reset_tokenUncheckedUpdateManyInput>
    /**
     * Filter which password_reset_tokens to update
     */
    where?: password_reset_tokenWhereInput
    /**
     * Limit how many password_reset_tokens to update.
     */
    limit?: number
  }

  /**
   * password_reset_token upsert
   */
  export type password_reset_tokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
    /**
     * The filter to search for the password_reset_token to update in case it exists.
     */
    where: password_reset_tokenWhereUniqueInput
    /**
     * In case the password_reset_token found by the `where` argument doesn't exist, create a new password_reset_token with this data.
     */
    create: XOR<password_reset_tokenCreateInput, password_reset_tokenUncheckedCreateInput>
    /**
     * In case the password_reset_token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<password_reset_tokenUpdateInput, password_reset_tokenUncheckedUpdateInput>
  }

  /**
   * password_reset_token delete
   */
  export type password_reset_tokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
    /**
     * Filter which password_reset_token to delete.
     */
    where: password_reset_tokenWhereUniqueInput
  }

  /**
   * password_reset_token deleteMany
   */
  export type password_reset_tokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to delete
     */
    where?: password_reset_tokenWhereInput
    /**
     * Limit how many password_reset_tokens to delete.
     */
    limit?: number
  }

  /**
   * password_reset_token without action
   */
  export type password_reset_tokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_token
     */
    select?: password_reset_tokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_token
     */
    omit?: password_reset_tokenOmit<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    message: string | null
    type: string | null
    is_read: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    message: string | null
    type: string | null
    is_read: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    message: number
    type: number
    is_read: number
    create_at: number
    update_at: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    message?: true
    type?: true
    is_read?: true
    create_at?: true
    update_at?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    message?: true
    type?: true
    is_read?: true
    create_at?: true
    update_at?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    message?: true
    type?: true
    is_read?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    user_id: number
    title: string
    message: string
    type: string
    is_read: boolean
    create_at: Date
    update_at: Date
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    is_read?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["notifications"]>



  export type notificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    is_read?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "message" | "type" | "is_read" | "create_at" | "update_at", ExtArgs["result"]["notifications"]>

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      title: string
      message: string
      type: string
      is_read: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'Int'>
    readonly user_id: FieldRef<"notifications", 'Int'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly type: FieldRef<"notifications", 'String'>
    readonly is_read: FieldRef<"notifications", 'Boolean'>
    readonly create_at: FieldRef<"notifications", 'DateTime'>
    readonly update_at: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
  }


  /**
   * Model sale_offices
   */

  export type AggregateSale_offices = {
    _count: Sale_officesCountAggregateOutputType | null
    _avg: Sale_officesAvgAggregateOutputType | null
    _sum: Sale_officesSumAggregateOutputType | null
    _min: Sale_officesMinAggregateOutputType | null
    _max: Sale_officesMaxAggregateOutputType | null
  }

  export type Sale_officesAvgAggregateOutputType = {
    id: number | null
  }

  export type Sale_officesSumAggregateOutputType = {
    id: number | null
  }

  export type Sale_officesMinAggregateOutputType = {
    id: number | null
    site_code: string | null
    site_office_name_th: string | null
    site_office_name_en: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Sale_officesMaxAggregateOutputType = {
    id: number | null
    site_code: string | null
    site_office_name_th: string | null
    site_office_name_en: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Sale_officesCountAggregateOutputType = {
    id: number
    site_code: number
    site_office_name_th: number
    site_office_name_en: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Sale_officesAvgAggregateInputType = {
    id?: true
  }

  export type Sale_officesSumAggregateInputType = {
    id?: true
  }

  export type Sale_officesMinAggregateInputType = {
    id?: true
    site_code?: true
    site_office_name_th?: true
    site_office_name_en?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Sale_officesMaxAggregateInputType = {
    id?: true
    site_code?: true
    site_office_name_th?: true
    site_office_name_en?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Sale_officesCountAggregateInputType = {
    id?: true
    site_code?: true
    site_office_name_th?: true
    site_office_name_en?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Sale_officesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sale_offices to aggregate.
     */
    where?: sale_officesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_offices to fetch.
     */
    orderBy?: sale_officesOrderByWithRelationInput | sale_officesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sale_officesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_offices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sale_offices
    **/
    _count?: true | Sale_officesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sale_officesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sale_officesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sale_officesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sale_officesMaxAggregateInputType
  }

  export type GetSale_officesAggregateType<T extends Sale_officesAggregateArgs> = {
        [P in keyof T & keyof AggregateSale_offices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale_offices[P]>
      : GetScalarType<T[P], AggregateSale_offices[P]>
  }




  export type sale_officesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sale_officesWhereInput
    orderBy?: sale_officesOrderByWithAggregationInput | sale_officesOrderByWithAggregationInput[]
    by: Sale_officesScalarFieldEnum[] | Sale_officesScalarFieldEnum
    having?: sale_officesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sale_officesCountAggregateInputType | true
    _avg?: Sale_officesAvgAggregateInputType
    _sum?: Sale_officesSumAggregateInputType
    _min?: Sale_officesMinAggregateInputType
    _max?: Sale_officesMaxAggregateInputType
  }

  export type Sale_officesGroupByOutputType = {
    id: number
    site_code: string
    site_office_name_th: string
    site_office_name_en: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Sale_officesCountAggregateOutputType | null
    _avg: Sale_officesAvgAggregateOutputType | null
    _sum: Sale_officesSumAggregateOutputType | null
    _min: Sale_officesMinAggregateOutputType | null
    _max: Sale_officesMaxAggregateOutputType | null
  }

  type GetSale_officesGroupByPayload<T extends sale_officesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sale_officesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sale_officesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sale_officesGroupByOutputType[P]>
            : GetScalarType<T[P], Sale_officesGroupByOutputType[P]>
        }
      >
    >


  export type sale_officesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    site_code?: boolean
    site_office_name_th?: boolean
    site_office_name_en?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["sale_offices"]>



  export type sale_officesSelectScalar = {
    id?: boolean
    site_code?: boolean
    site_office_name_th?: boolean
    site_office_name_en?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type sale_officesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "site_code" | "site_office_name_th" | "site_office_name_en" | "status" | "create_at" | "update_at", ExtArgs["result"]["sale_offices"]>

  export type $sale_officesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sale_offices"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      site_code: string
      site_office_name_th: string
      site_office_name_en: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["sale_offices"]>
    composites: {}
  }

  type sale_officesGetPayload<S extends boolean | null | undefined | sale_officesDefaultArgs> = $Result.GetResult<Prisma.$sale_officesPayload, S>

  type sale_officesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sale_officesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sale_officesCountAggregateInputType | true
    }

  export interface sale_officesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sale_offices'], meta: { name: 'sale_offices' } }
    /**
     * Find zero or one Sale_offices that matches the filter.
     * @param {sale_officesFindUniqueArgs} args - Arguments to find a Sale_offices
     * @example
     * // Get one Sale_offices
     * const sale_offices = await prisma.sale_offices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sale_officesFindUniqueArgs>(args: SelectSubset<T, sale_officesFindUniqueArgs<ExtArgs>>): Prisma__sale_officesClient<$Result.GetResult<Prisma.$sale_officesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale_offices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sale_officesFindUniqueOrThrowArgs} args - Arguments to find a Sale_offices
     * @example
     * // Get one Sale_offices
     * const sale_offices = await prisma.sale_offices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sale_officesFindUniqueOrThrowArgs>(args: SelectSubset<T, sale_officesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sale_officesClient<$Result.GetResult<Prisma.$sale_officesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale_offices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_officesFindFirstArgs} args - Arguments to find a Sale_offices
     * @example
     * // Get one Sale_offices
     * const sale_offices = await prisma.sale_offices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sale_officesFindFirstArgs>(args?: SelectSubset<T, sale_officesFindFirstArgs<ExtArgs>>): Prisma__sale_officesClient<$Result.GetResult<Prisma.$sale_officesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale_offices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_officesFindFirstOrThrowArgs} args - Arguments to find a Sale_offices
     * @example
     * // Get one Sale_offices
     * const sale_offices = await prisma.sale_offices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sale_officesFindFirstOrThrowArgs>(args?: SelectSubset<T, sale_officesFindFirstOrThrowArgs<ExtArgs>>): Prisma__sale_officesClient<$Result.GetResult<Prisma.$sale_officesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sale_offices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_officesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sale_offices
     * const sale_offices = await prisma.sale_offices.findMany()
     * 
     * // Get first 10 Sale_offices
     * const sale_offices = await prisma.sale_offices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sale_officesWithIdOnly = await prisma.sale_offices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sale_officesFindManyArgs>(args?: SelectSubset<T, sale_officesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sale_officesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale_offices.
     * @param {sale_officesCreateArgs} args - Arguments to create a Sale_offices.
     * @example
     * // Create one Sale_offices
     * const Sale_offices = await prisma.sale_offices.create({
     *   data: {
     *     // ... data to create a Sale_offices
     *   }
     * })
     * 
     */
    create<T extends sale_officesCreateArgs>(args: SelectSubset<T, sale_officesCreateArgs<ExtArgs>>): Prisma__sale_officesClient<$Result.GetResult<Prisma.$sale_officesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sale_offices.
     * @param {sale_officesCreateManyArgs} args - Arguments to create many Sale_offices.
     * @example
     * // Create many Sale_offices
     * const sale_offices = await prisma.sale_offices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sale_officesCreateManyArgs>(args?: SelectSubset<T, sale_officesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sale_offices.
     * @param {sale_officesDeleteArgs} args - Arguments to delete one Sale_offices.
     * @example
     * // Delete one Sale_offices
     * const Sale_offices = await prisma.sale_offices.delete({
     *   where: {
     *     // ... filter to delete one Sale_offices
     *   }
     * })
     * 
     */
    delete<T extends sale_officesDeleteArgs>(args: SelectSubset<T, sale_officesDeleteArgs<ExtArgs>>): Prisma__sale_officesClient<$Result.GetResult<Prisma.$sale_officesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale_offices.
     * @param {sale_officesUpdateArgs} args - Arguments to update one Sale_offices.
     * @example
     * // Update one Sale_offices
     * const sale_offices = await prisma.sale_offices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sale_officesUpdateArgs>(args: SelectSubset<T, sale_officesUpdateArgs<ExtArgs>>): Prisma__sale_officesClient<$Result.GetResult<Prisma.$sale_officesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sale_offices.
     * @param {sale_officesDeleteManyArgs} args - Arguments to filter Sale_offices to delete.
     * @example
     * // Delete a few Sale_offices
     * const { count } = await prisma.sale_offices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sale_officesDeleteManyArgs>(args?: SelectSubset<T, sale_officesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sale_offices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_officesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sale_offices
     * const sale_offices = await prisma.sale_offices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sale_officesUpdateManyArgs>(args: SelectSubset<T, sale_officesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sale_offices.
     * @param {sale_officesUpsertArgs} args - Arguments to update or create a Sale_offices.
     * @example
     * // Update or create a Sale_offices
     * const sale_offices = await prisma.sale_offices.upsert({
     *   create: {
     *     // ... data to create a Sale_offices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale_offices we want to update
     *   }
     * })
     */
    upsert<T extends sale_officesUpsertArgs>(args: SelectSubset<T, sale_officesUpsertArgs<ExtArgs>>): Prisma__sale_officesClient<$Result.GetResult<Prisma.$sale_officesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sale_offices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_officesCountArgs} args - Arguments to filter Sale_offices to count.
     * @example
     * // Count the number of Sale_offices
     * const count = await prisma.sale_offices.count({
     *   where: {
     *     // ... the filter for the Sale_offices we want to count
     *   }
     * })
    **/
    count<T extends sale_officesCountArgs>(
      args?: Subset<T, sale_officesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sale_officesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale_offices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sale_officesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sale_officesAggregateArgs>(args: Subset<T, Sale_officesAggregateArgs>): Prisma.PrismaPromise<GetSale_officesAggregateType<T>>

    /**
     * Group by Sale_offices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sale_officesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sale_officesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sale_officesGroupByArgs['orderBy'] }
        : { orderBy?: sale_officesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sale_officesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSale_officesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sale_offices model
   */
  readonly fields: sale_officesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sale_offices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sale_officesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sale_offices model
   */
  interface sale_officesFieldRefs {
    readonly id: FieldRef<"sale_offices", 'Int'>
    readonly site_code: FieldRef<"sale_offices", 'String'>
    readonly site_office_name_th: FieldRef<"sale_offices", 'String'>
    readonly site_office_name_en: FieldRef<"sale_offices", 'String'>
    readonly status: FieldRef<"sale_offices", 'Boolean'>
    readonly create_at: FieldRef<"sale_offices", 'DateTime'>
    readonly update_at: FieldRef<"sale_offices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sale_offices findUnique
   */
  export type sale_officesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
    /**
     * Filter, which sale_offices to fetch.
     */
    where: sale_officesWhereUniqueInput
  }

  /**
   * sale_offices findUniqueOrThrow
   */
  export type sale_officesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
    /**
     * Filter, which sale_offices to fetch.
     */
    where: sale_officesWhereUniqueInput
  }

  /**
   * sale_offices findFirst
   */
  export type sale_officesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
    /**
     * Filter, which sale_offices to fetch.
     */
    where?: sale_officesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_offices to fetch.
     */
    orderBy?: sale_officesOrderByWithRelationInput | sale_officesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sale_offices.
     */
    cursor?: sale_officesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_offices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sale_offices.
     */
    distinct?: Sale_officesScalarFieldEnum | Sale_officesScalarFieldEnum[]
  }

  /**
   * sale_offices findFirstOrThrow
   */
  export type sale_officesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
    /**
     * Filter, which sale_offices to fetch.
     */
    where?: sale_officesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_offices to fetch.
     */
    orderBy?: sale_officesOrderByWithRelationInput | sale_officesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sale_offices.
     */
    cursor?: sale_officesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_offices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sale_offices.
     */
    distinct?: Sale_officesScalarFieldEnum | Sale_officesScalarFieldEnum[]
  }

  /**
   * sale_offices findMany
   */
  export type sale_officesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
    /**
     * Filter, which sale_offices to fetch.
     */
    where?: sale_officesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sale_offices to fetch.
     */
    orderBy?: sale_officesOrderByWithRelationInput | sale_officesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sale_offices.
     */
    cursor?: sale_officesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sale_offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sale_offices.
     */
    skip?: number
    distinct?: Sale_officesScalarFieldEnum | Sale_officesScalarFieldEnum[]
  }

  /**
   * sale_offices create
   */
  export type sale_officesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
    /**
     * The data needed to create a sale_offices.
     */
    data: XOR<sale_officesCreateInput, sale_officesUncheckedCreateInput>
  }

  /**
   * sale_offices createMany
   */
  export type sale_officesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sale_offices.
     */
    data: sale_officesCreateManyInput | sale_officesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sale_offices update
   */
  export type sale_officesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
    /**
     * The data needed to update a sale_offices.
     */
    data: XOR<sale_officesUpdateInput, sale_officesUncheckedUpdateInput>
    /**
     * Choose, which sale_offices to update.
     */
    where: sale_officesWhereUniqueInput
  }

  /**
   * sale_offices updateMany
   */
  export type sale_officesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sale_offices.
     */
    data: XOR<sale_officesUpdateManyMutationInput, sale_officesUncheckedUpdateManyInput>
    /**
     * Filter which sale_offices to update
     */
    where?: sale_officesWhereInput
    /**
     * Limit how many sale_offices to update.
     */
    limit?: number
  }

  /**
   * sale_offices upsert
   */
  export type sale_officesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
    /**
     * The filter to search for the sale_offices to update in case it exists.
     */
    where: sale_officesWhereUniqueInput
    /**
     * In case the sale_offices found by the `where` argument doesn't exist, create a new sale_offices with this data.
     */
    create: XOR<sale_officesCreateInput, sale_officesUncheckedCreateInput>
    /**
     * In case the sale_offices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sale_officesUpdateInput, sale_officesUncheckedUpdateInput>
  }

  /**
   * sale_offices delete
   */
  export type sale_officesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
    /**
     * Filter which sale_offices to delete.
     */
    where: sale_officesWhereUniqueInput
  }

  /**
   * sale_offices deleteMany
   */
  export type sale_officesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sale_offices to delete
     */
    where?: sale_officesWhereInput
    /**
     * Limit how many sale_offices to delete.
     */
    limit?: number
  }

  /**
   * sale_offices without action
   */
  export type sale_officesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sale_offices
     */
    select?: sale_officesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sale_offices
     */
    omit?: sale_officesOmit<ExtArgs> | null
  }


  /**
   * Model departments
   */

  export type AggregateDepartments = {
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  export type DepartmentsAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    ship_id: number | null
  }

  export type DepartmentsSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    ship_id: number | null
  }

  export type DepartmentsMinAggregateOutputType = {
    id: number | null
    department_code: string | null
    sale_office_id: number | null
    description: string | null
    group_code: string | null
    ship_id: number | null
    is_default: boolean | null
    name_th: string | null
    name_en: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type DepartmentsMaxAggregateOutputType = {
    id: number | null
    department_code: string | null
    sale_office_id: number | null
    description: string | null
    group_code: string | null
    ship_id: number | null
    is_default: boolean | null
    name_th: string | null
    name_en: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type DepartmentsCountAggregateOutputType = {
    id: number
    department_code: number
    sale_office_id: number
    description: number
    group_code: number
    ship_id: number
    is_default: number
    name_th: number
    name_en: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type DepartmentsAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    ship_id?: true
  }

  export type DepartmentsSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    ship_id?: true
  }

  export type DepartmentsMinAggregateInputType = {
    id?: true
    department_code?: true
    sale_office_id?: true
    description?: true
    group_code?: true
    ship_id?: true
    is_default?: true
    name_th?: true
    name_en?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type DepartmentsMaxAggregateInputType = {
    id?: true
    department_code?: true
    sale_office_id?: true
    description?: true
    group_code?: true
    ship_id?: true
    is_default?: true
    name_th?: true
    name_en?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type DepartmentsCountAggregateInputType = {
    id?: true
    department_code?: true
    sale_office_id?: true
    description?: true
    group_code?: true
    ship_id?: true
    is_default?: true
    name_th?: true
    name_en?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type DepartmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to aggregate.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departments
    **/
    _count?: true | DepartmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentsMaxAggregateInputType
  }

  export type GetDepartmentsAggregateType<T extends DepartmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartments[P]>
      : GetScalarType<T[P], AggregateDepartments[P]>
  }




  export type departmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentsWhereInput
    orderBy?: departmentsOrderByWithAggregationInput | departmentsOrderByWithAggregationInput[]
    by: DepartmentsScalarFieldEnum[] | DepartmentsScalarFieldEnum
    having?: departmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentsCountAggregateInputType | true
    _avg?: DepartmentsAvgAggregateInputType
    _sum?: DepartmentsSumAggregateInputType
    _min?: DepartmentsMinAggregateInputType
    _max?: DepartmentsMaxAggregateInputType
  }

  export type DepartmentsGroupByOutputType = {
    id: number
    department_code: string
    sale_office_id: number
    description: string
    group_code: string
    ship_id: number
    is_default: boolean
    name_th: string
    name_en: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  type GetDepartmentsGroupByPayload<T extends departmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
        }
      >
    >


  export type departmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    department_code?: boolean
    sale_office_id?: boolean
    description?: boolean
    group_code?: boolean
    ship_id?: boolean
    is_default?: boolean
    name_th?: boolean
    name_en?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["departments"]>



  export type departmentsSelectScalar = {
    id?: boolean
    department_code?: boolean
    sale_office_id?: boolean
    description?: boolean
    group_code?: boolean
    ship_id?: boolean
    is_default?: boolean
    name_th?: boolean
    name_en?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type departmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "department_code" | "sale_office_id" | "description" | "group_code" | "ship_id" | "is_default" | "name_th" | "name_en" | "status" | "create_at" | "update_at", ExtArgs["result"]["departments"]>

  export type $departmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "departments"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      department_code: string
      sale_office_id: number
      description: string
      group_code: string
      ship_id: number
      is_default: boolean
      name_th: string
      name_en: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["departments"]>
    composites: {}
  }

  type departmentsGetPayload<S extends boolean | null | undefined | departmentsDefaultArgs> = $Result.GetResult<Prisma.$departmentsPayload, S>

  type departmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<departmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentsCountAggregateInputType | true
    }

  export interface departmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['departments'], meta: { name: 'departments' } }
    /**
     * Find zero or one Departments that matches the filter.
     * @param {departmentsFindUniqueArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends departmentsFindUniqueArgs>(args: SelectSubset<T, departmentsFindUniqueArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Departments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {departmentsFindUniqueOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends departmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, departmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindFirstArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends departmentsFindFirstArgs>(args?: SelectSubset<T, departmentsFindFirstArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Departments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindFirstOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends departmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, departmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.departments.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.departments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentsWithIdOnly = await prisma.departments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends departmentsFindManyArgs>(args?: SelectSubset<T, departmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Departments.
     * @param {departmentsCreateArgs} args - Arguments to create a Departments.
     * @example
     * // Create one Departments
     * const Departments = await prisma.departments.create({
     *   data: {
     *     // ... data to create a Departments
     *   }
     * })
     * 
     */
    create<T extends departmentsCreateArgs>(args: SelectSubset<T, departmentsCreateArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {departmentsCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const departments = await prisma.departments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends departmentsCreateManyArgs>(args?: SelectSubset<T, departmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Departments.
     * @param {departmentsDeleteArgs} args - Arguments to delete one Departments.
     * @example
     * // Delete one Departments
     * const Departments = await prisma.departments.delete({
     *   where: {
     *     // ... filter to delete one Departments
     *   }
     * })
     * 
     */
    delete<T extends departmentsDeleteArgs>(args: SelectSubset<T, departmentsDeleteArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Departments.
     * @param {departmentsUpdateArgs} args - Arguments to update one Departments.
     * @example
     * // Update one Departments
     * const departments = await prisma.departments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends departmentsUpdateArgs>(args: SelectSubset<T, departmentsUpdateArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {departmentsDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.departments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends departmentsDeleteManyArgs>(args?: SelectSubset<T, departmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const departments = await prisma.departments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends departmentsUpdateManyArgs>(args: SelectSubset<T, departmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Departments.
     * @param {departmentsUpsertArgs} args - Arguments to update or create a Departments.
     * @example
     * // Update or create a Departments
     * const departments = await prisma.departments.upsert({
     *   create: {
     *     // ... data to create a Departments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departments we want to update
     *   }
     * })
     */
    upsert<T extends departmentsUpsertArgs>(args: SelectSubset<T, departmentsUpsertArgs<ExtArgs>>): Prisma__departmentsClient<$Result.GetResult<Prisma.$departmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.departments.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends departmentsCountArgs>(
      args?: Subset<T, departmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentsAggregateArgs>(args: Subset<T, DepartmentsAggregateArgs>): Prisma.PrismaPromise<GetDepartmentsAggregateType<T>>

    /**
     * Group by Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departmentsGroupByArgs['orderBy'] }
        : { orderBy?: departmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the departments model
   */
  readonly fields: departmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for departments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__departmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the departments model
   */
  interface departmentsFieldRefs {
    readonly id: FieldRef<"departments", 'Int'>
    readonly department_code: FieldRef<"departments", 'String'>
    readonly sale_office_id: FieldRef<"departments", 'Int'>
    readonly description: FieldRef<"departments", 'String'>
    readonly group_code: FieldRef<"departments", 'String'>
    readonly ship_id: FieldRef<"departments", 'Int'>
    readonly is_default: FieldRef<"departments", 'Boolean'>
    readonly name_th: FieldRef<"departments", 'String'>
    readonly name_en: FieldRef<"departments", 'String'>
    readonly status: FieldRef<"departments", 'Boolean'>
    readonly create_at: FieldRef<"departments", 'DateTime'>
    readonly update_at: FieldRef<"departments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * departments findUnique
   */
  export type departmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments findUniqueOrThrow
   */
  export type departmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments findFirst
   */
  export type departmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments findFirstOrThrow
   */
  export type departmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments findMany
   */
  export type departmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentsOrderByWithRelationInput | departmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departments.
     */
    cursor?: departmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * departments create
   */
  export type departmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * The data needed to create a departments.
     */
    data: XOR<departmentsCreateInput, departmentsUncheckedCreateInput>
  }

  /**
   * departments createMany
   */
  export type departmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departments.
     */
    data: departmentsCreateManyInput | departmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * departments update
   */
  export type departmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * The data needed to update a departments.
     */
    data: XOR<departmentsUpdateInput, departmentsUncheckedUpdateInput>
    /**
     * Choose, which departments to update.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments updateMany
   */
  export type departmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departments.
     */
    data: XOR<departmentsUpdateManyMutationInput, departmentsUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentsWhereInput
    /**
     * Limit how many departments to update.
     */
    limit?: number
  }

  /**
   * departments upsert
   */
  export type departmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * The filter to search for the departments to update in case it exists.
     */
    where: departmentsWhereUniqueInput
    /**
     * In case the departments found by the `where` argument doesn't exist, create a new departments with this data.
     */
    create: XOR<departmentsCreateInput, departmentsUncheckedCreateInput>
    /**
     * In case the departments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departmentsUpdateInput, departmentsUncheckedUpdateInput>
  }

  /**
   * departments delete
   */
  export type departmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
    /**
     * Filter which departments to delete.
     */
    where: departmentsWhereUniqueInput
  }

  /**
   * departments deleteMany
   */
  export type departmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to delete
     */
    where?: departmentsWhereInput
    /**
     * Limit how many departments to delete.
     */
    limit?: number
  }

  /**
   * departments without action
   */
  export type departmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the departments
     */
    select?: departmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the departments
     */
    omit?: departmentsOmit<ExtArgs> | null
  }


  /**
   * Model factory_sale_office
   */

  export type AggregateFactory_sale_office = {
    _count: Factory_sale_officeCountAggregateOutputType | null
    _avg: Factory_sale_officeAvgAggregateOutputType | null
    _sum: Factory_sale_officeSumAggregateOutputType | null
    _min: Factory_sale_officeMinAggregateOutputType | null
    _max: Factory_sale_officeMaxAggregateOutputType | null
  }

  export type Factory_sale_officeAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    factory_id: number | null
  }

  export type Factory_sale_officeSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    factory_id: number | null
  }

  export type Factory_sale_officeMinAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Factory_sale_officeMaxAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Factory_sale_officeCountAggregateOutputType = {
    id: number
    sale_office_id: number
    factory_id: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Factory_sale_officeAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_id?: true
  }

  export type Factory_sale_officeSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_id?: true
  }

  export type Factory_sale_officeMinAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Factory_sale_officeMaxAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Factory_sale_officeCountAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Factory_sale_officeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which factory_sale_office to aggregate.
     */
    where?: factory_sale_officeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factory_sale_offices to fetch.
     */
    orderBy?: factory_sale_officeOrderByWithRelationInput | factory_sale_officeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: factory_sale_officeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factory_sale_offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factory_sale_offices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned factory_sale_offices
    **/
    _count?: true | Factory_sale_officeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Factory_sale_officeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Factory_sale_officeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Factory_sale_officeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Factory_sale_officeMaxAggregateInputType
  }

  export type GetFactory_sale_officeAggregateType<T extends Factory_sale_officeAggregateArgs> = {
        [P in keyof T & keyof AggregateFactory_sale_office]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactory_sale_office[P]>
      : GetScalarType<T[P], AggregateFactory_sale_office[P]>
  }




  export type factory_sale_officeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: factory_sale_officeWhereInput
    orderBy?: factory_sale_officeOrderByWithAggregationInput | factory_sale_officeOrderByWithAggregationInput[]
    by: Factory_sale_officeScalarFieldEnum[] | Factory_sale_officeScalarFieldEnum
    having?: factory_sale_officeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Factory_sale_officeCountAggregateInputType | true
    _avg?: Factory_sale_officeAvgAggregateInputType
    _sum?: Factory_sale_officeSumAggregateInputType
    _min?: Factory_sale_officeMinAggregateInputType
    _max?: Factory_sale_officeMaxAggregateInputType
  }

  export type Factory_sale_officeGroupByOutputType = {
    id: number
    sale_office_id: number
    factory_id: number
    status: boolean
    create_at: Date
    update_at: Date
    _count: Factory_sale_officeCountAggregateOutputType | null
    _avg: Factory_sale_officeAvgAggregateOutputType | null
    _sum: Factory_sale_officeSumAggregateOutputType | null
    _min: Factory_sale_officeMinAggregateOutputType | null
    _max: Factory_sale_officeMaxAggregateOutputType | null
  }

  type GetFactory_sale_officeGroupByPayload<T extends factory_sale_officeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Factory_sale_officeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Factory_sale_officeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Factory_sale_officeGroupByOutputType[P]>
            : GetScalarType<T[P], Factory_sale_officeGroupByOutputType[P]>
        }
      >
    >


  export type factory_sale_officeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_office_id?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["factory_sale_office"]>



  export type factory_sale_officeSelectScalar = {
    id?: boolean
    sale_office_id?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type factory_sale_officeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_office_id" | "factory_id" | "status" | "create_at" | "update_at", ExtArgs["result"]["factory_sale_office"]>

  export type $factory_sale_officePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "factory_sale_office"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_office_id: number
      factory_id: number
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["factory_sale_office"]>
    composites: {}
  }

  type factory_sale_officeGetPayload<S extends boolean | null | undefined | factory_sale_officeDefaultArgs> = $Result.GetResult<Prisma.$factory_sale_officePayload, S>

  type factory_sale_officeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<factory_sale_officeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Factory_sale_officeCountAggregateInputType | true
    }

  export interface factory_sale_officeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['factory_sale_office'], meta: { name: 'factory_sale_office' } }
    /**
     * Find zero or one Factory_sale_office that matches the filter.
     * @param {factory_sale_officeFindUniqueArgs} args - Arguments to find a Factory_sale_office
     * @example
     * // Get one Factory_sale_office
     * const factory_sale_office = await prisma.factory_sale_office.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends factory_sale_officeFindUniqueArgs>(args: SelectSubset<T, factory_sale_officeFindUniqueArgs<ExtArgs>>): Prisma__factory_sale_officeClient<$Result.GetResult<Prisma.$factory_sale_officePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Factory_sale_office that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {factory_sale_officeFindUniqueOrThrowArgs} args - Arguments to find a Factory_sale_office
     * @example
     * // Get one Factory_sale_office
     * const factory_sale_office = await prisma.factory_sale_office.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends factory_sale_officeFindUniqueOrThrowArgs>(args: SelectSubset<T, factory_sale_officeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__factory_sale_officeClient<$Result.GetResult<Prisma.$factory_sale_officePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Factory_sale_office that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factory_sale_officeFindFirstArgs} args - Arguments to find a Factory_sale_office
     * @example
     * // Get one Factory_sale_office
     * const factory_sale_office = await prisma.factory_sale_office.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends factory_sale_officeFindFirstArgs>(args?: SelectSubset<T, factory_sale_officeFindFirstArgs<ExtArgs>>): Prisma__factory_sale_officeClient<$Result.GetResult<Prisma.$factory_sale_officePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Factory_sale_office that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factory_sale_officeFindFirstOrThrowArgs} args - Arguments to find a Factory_sale_office
     * @example
     * // Get one Factory_sale_office
     * const factory_sale_office = await prisma.factory_sale_office.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends factory_sale_officeFindFirstOrThrowArgs>(args?: SelectSubset<T, factory_sale_officeFindFirstOrThrowArgs<ExtArgs>>): Prisma__factory_sale_officeClient<$Result.GetResult<Prisma.$factory_sale_officePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Factory_sale_offices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factory_sale_officeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Factory_sale_offices
     * const factory_sale_offices = await prisma.factory_sale_office.findMany()
     * 
     * // Get first 10 Factory_sale_offices
     * const factory_sale_offices = await prisma.factory_sale_office.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factory_sale_officeWithIdOnly = await prisma.factory_sale_office.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends factory_sale_officeFindManyArgs>(args?: SelectSubset<T, factory_sale_officeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$factory_sale_officePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Factory_sale_office.
     * @param {factory_sale_officeCreateArgs} args - Arguments to create a Factory_sale_office.
     * @example
     * // Create one Factory_sale_office
     * const Factory_sale_office = await prisma.factory_sale_office.create({
     *   data: {
     *     // ... data to create a Factory_sale_office
     *   }
     * })
     * 
     */
    create<T extends factory_sale_officeCreateArgs>(args: SelectSubset<T, factory_sale_officeCreateArgs<ExtArgs>>): Prisma__factory_sale_officeClient<$Result.GetResult<Prisma.$factory_sale_officePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Factory_sale_offices.
     * @param {factory_sale_officeCreateManyArgs} args - Arguments to create many Factory_sale_offices.
     * @example
     * // Create many Factory_sale_offices
     * const factory_sale_office = await prisma.factory_sale_office.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends factory_sale_officeCreateManyArgs>(args?: SelectSubset<T, factory_sale_officeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Factory_sale_office.
     * @param {factory_sale_officeDeleteArgs} args - Arguments to delete one Factory_sale_office.
     * @example
     * // Delete one Factory_sale_office
     * const Factory_sale_office = await prisma.factory_sale_office.delete({
     *   where: {
     *     // ... filter to delete one Factory_sale_office
     *   }
     * })
     * 
     */
    delete<T extends factory_sale_officeDeleteArgs>(args: SelectSubset<T, factory_sale_officeDeleteArgs<ExtArgs>>): Prisma__factory_sale_officeClient<$Result.GetResult<Prisma.$factory_sale_officePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Factory_sale_office.
     * @param {factory_sale_officeUpdateArgs} args - Arguments to update one Factory_sale_office.
     * @example
     * // Update one Factory_sale_office
     * const factory_sale_office = await prisma.factory_sale_office.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends factory_sale_officeUpdateArgs>(args: SelectSubset<T, factory_sale_officeUpdateArgs<ExtArgs>>): Prisma__factory_sale_officeClient<$Result.GetResult<Prisma.$factory_sale_officePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Factory_sale_offices.
     * @param {factory_sale_officeDeleteManyArgs} args - Arguments to filter Factory_sale_offices to delete.
     * @example
     * // Delete a few Factory_sale_offices
     * const { count } = await prisma.factory_sale_office.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends factory_sale_officeDeleteManyArgs>(args?: SelectSubset<T, factory_sale_officeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factory_sale_offices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factory_sale_officeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Factory_sale_offices
     * const factory_sale_office = await prisma.factory_sale_office.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends factory_sale_officeUpdateManyArgs>(args: SelectSubset<T, factory_sale_officeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Factory_sale_office.
     * @param {factory_sale_officeUpsertArgs} args - Arguments to update or create a Factory_sale_office.
     * @example
     * // Update or create a Factory_sale_office
     * const factory_sale_office = await prisma.factory_sale_office.upsert({
     *   create: {
     *     // ... data to create a Factory_sale_office
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Factory_sale_office we want to update
     *   }
     * })
     */
    upsert<T extends factory_sale_officeUpsertArgs>(args: SelectSubset<T, factory_sale_officeUpsertArgs<ExtArgs>>): Prisma__factory_sale_officeClient<$Result.GetResult<Prisma.$factory_sale_officePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Factory_sale_offices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factory_sale_officeCountArgs} args - Arguments to filter Factory_sale_offices to count.
     * @example
     * // Count the number of Factory_sale_offices
     * const count = await prisma.factory_sale_office.count({
     *   where: {
     *     // ... the filter for the Factory_sale_offices we want to count
     *   }
     * })
    **/
    count<T extends factory_sale_officeCountArgs>(
      args?: Subset<T, factory_sale_officeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Factory_sale_officeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Factory_sale_office.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Factory_sale_officeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Factory_sale_officeAggregateArgs>(args: Subset<T, Factory_sale_officeAggregateArgs>): Prisma.PrismaPromise<GetFactory_sale_officeAggregateType<T>>

    /**
     * Group by Factory_sale_office.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factory_sale_officeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends factory_sale_officeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: factory_sale_officeGroupByArgs['orderBy'] }
        : { orderBy?: factory_sale_officeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, factory_sale_officeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactory_sale_officeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the factory_sale_office model
   */
  readonly fields: factory_sale_officeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for factory_sale_office.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__factory_sale_officeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the factory_sale_office model
   */
  interface factory_sale_officeFieldRefs {
    readonly id: FieldRef<"factory_sale_office", 'Int'>
    readonly sale_office_id: FieldRef<"factory_sale_office", 'Int'>
    readonly factory_id: FieldRef<"factory_sale_office", 'Int'>
    readonly status: FieldRef<"factory_sale_office", 'Boolean'>
    readonly create_at: FieldRef<"factory_sale_office", 'DateTime'>
    readonly update_at: FieldRef<"factory_sale_office", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * factory_sale_office findUnique
   */
  export type factory_sale_officeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
    /**
     * Filter, which factory_sale_office to fetch.
     */
    where: factory_sale_officeWhereUniqueInput
  }

  /**
   * factory_sale_office findUniqueOrThrow
   */
  export type factory_sale_officeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
    /**
     * Filter, which factory_sale_office to fetch.
     */
    where: factory_sale_officeWhereUniqueInput
  }

  /**
   * factory_sale_office findFirst
   */
  export type factory_sale_officeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
    /**
     * Filter, which factory_sale_office to fetch.
     */
    where?: factory_sale_officeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factory_sale_offices to fetch.
     */
    orderBy?: factory_sale_officeOrderByWithRelationInput | factory_sale_officeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for factory_sale_offices.
     */
    cursor?: factory_sale_officeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factory_sale_offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factory_sale_offices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of factory_sale_offices.
     */
    distinct?: Factory_sale_officeScalarFieldEnum | Factory_sale_officeScalarFieldEnum[]
  }

  /**
   * factory_sale_office findFirstOrThrow
   */
  export type factory_sale_officeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
    /**
     * Filter, which factory_sale_office to fetch.
     */
    where?: factory_sale_officeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factory_sale_offices to fetch.
     */
    orderBy?: factory_sale_officeOrderByWithRelationInput | factory_sale_officeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for factory_sale_offices.
     */
    cursor?: factory_sale_officeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factory_sale_offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factory_sale_offices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of factory_sale_offices.
     */
    distinct?: Factory_sale_officeScalarFieldEnum | Factory_sale_officeScalarFieldEnum[]
  }

  /**
   * factory_sale_office findMany
   */
  export type factory_sale_officeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
    /**
     * Filter, which factory_sale_offices to fetch.
     */
    where?: factory_sale_officeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factory_sale_offices to fetch.
     */
    orderBy?: factory_sale_officeOrderByWithRelationInput | factory_sale_officeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing factory_sale_offices.
     */
    cursor?: factory_sale_officeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factory_sale_offices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factory_sale_offices.
     */
    skip?: number
    distinct?: Factory_sale_officeScalarFieldEnum | Factory_sale_officeScalarFieldEnum[]
  }

  /**
   * factory_sale_office create
   */
  export type factory_sale_officeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
    /**
     * The data needed to create a factory_sale_office.
     */
    data: XOR<factory_sale_officeCreateInput, factory_sale_officeUncheckedCreateInput>
  }

  /**
   * factory_sale_office createMany
   */
  export type factory_sale_officeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many factory_sale_offices.
     */
    data: factory_sale_officeCreateManyInput | factory_sale_officeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * factory_sale_office update
   */
  export type factory_sale_officeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
    /**
     * The data needed to update a factory_sale_office.
     */
    data: XOR<factory_sale_officeUpdateInput, factory_sale_officeUncheckedUpdateInput>
    /**
     * Choose, which factory_sale_office to update.
     */
    where: factory_sale_officeWhereUniqueInput
  }

  /**
   * factory_sale_office updateMany
   */
  export type factory_sale_officeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update factory_sale_offices.
     */
    data: XOR<factory_sale_officeUpdateManyMutationInput, factory_sale_officeUncheckedUpdateManyInput>
    /**
     * Filter which factory_sale_offices to update
     */
    where?: factory_sale_officeWhereInput
    /**
     * Limit how many factory_sale_offices to update.
     */
    limit?: number
  }

  /**
   * factory_sale_office upsert
   */
  export type factory_sale_officeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
    /**
     * The filter to search for the factory_sale_office to update in case it exists.
     */
    where: factory_sale_officeWhereUniqueInput
    /**
     * In case the factory_sale_office found by the `where` argument doesn't exist, create a new factory_sale_office with this data.
     */
    create: XOR<factory_sale_officeCreateInput, factory_sale_officeUncheckedCreateInput>
    /**
     * In case the factory_sale_office was found with the provided `where` argument, update it with this data.
     */
    update: XOR<factory_sale_officeUpdateInput, factory_sale_officeUncheckedUpdateInput>
  }

  /**
   * factory_sale_office delete
   */
  export type factory_sale_officeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
    /**
     * Filter which factory_sale_office to delete.
     */
    where: factory_sale_officeWhereUniqueInput
  }

  /**
   * factory_sale_office deleteMany
   */
  export type factory_sale_officeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which factory_sale_offices to delete
     */
    where?: factory_sale_officeWhereInput
    /**
     * Limit how many factory_sale_offices to delete.
     */
    limit?: number
  }

  /**
   * factory_sale_office without action
   */
  export type factory_sale_officeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factory_sale_office
     */
    select?: factory_sale_officeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factory_sale_office
     */
    omit?: factory_sale_officeOmit<ExtArgs> | null
  }


  /**
   * Model factories
   */

  export type AggregateFactories = {
    _count: FactoriesCountAggregateOutputType | null
    _avg: FactoriesAvgAggregateOutputType | null
    _sum: FactoriesSumAggregateOutputType | null
    _min: FactoriesMinAggregateOutputType | null
    _max: FactoriesMaxAggregateOutputType | null
  }

  export type FactoriesAvgAggregateOutputType = {
    id: number | null
    price: number | null
    tax_id: number | null
  }

  export type FactoriesSumAggregateOutputType = {
    id: number | null
    price: number | null
    tax_id: number | null
  }

  export type FactoriesMinAggregateOutputType = {
    id: number | null
    price: number | null
    address: string | null
    post: string | null
    tel: string | null
    tax_id: number | null
    name_th: string | null
    name_en: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type FactoriesMaxAggregateOutputType = {
    id: number | null
    price: number | null
    address: string | null
    post: string | null
    tel: string | null
    tax_id: number | null
    name_th: string | null
    name_en: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type FactoriesCountAggregateOutputType = {
    id: number
    price: number
    address: number
    post: number
    tel: number
    tax_id: number
    name_th: number
    name_en: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type FactoriesAvgAggregateInputType = {
    id?: true
    price?: true
    tax_id?: true
  }

  export type FactoriesSumAggregateInputType = {
    id?: true
    price?: true
    tax_id?: true
  }

  export type FactoriesMinAggregateInputType = {
    id?: true
    price?: true
    address?: true
    post?: true
    tel?: true
    tax_id?: true
    name_th?: true
    name_en?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type FactoriesMaxAggregateInputType = {
    id?: true
    price?: true
    address?: true
    post?: true
    tel?: true
    tax_id?: true
    name_th?: true
    name_en?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type FactoriesCountAggregateInputType = {
    id?: true
    price?: true
    address?: true
    post?: true
    tel?: true
    tax_id?: true
    name_th?: true
    name_en?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type FactoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which factories to aggregate.
     */
    where?: factoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factories to fetch.
     */
    orderBy?: factoriesOrderByWithRelationInput | factoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: factoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned factories
    **/
    _count?: true | FactoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactoriesMaxAggregateInputType
  }

  export type GetFactoriesAggregateType<T extends FactoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateFactories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFactories[P]>
      : GetScalarType<T[P], AggregateFactories[P]>
  }




  export type factoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: factoriesWhereInput
    orderBy?: factoriesOrderByWithAggregationInput | factoriesOrderByWithAggregationInput[]
    by: FactoriesScalarFieldEnum[] | FactoriesScalarFieldEnum
    having?: factoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactoriesCountAggregateInputType | true
    _avg?: FactoriesAvgAggregateInputType
    _sum?: FactoriesSumAggregateInputType
    _min?: FactoriesMinAggregateInputType
    _max?: FactoriesMaxAggregateInputType
  }

  export type FactoriesGroupByOutputType = {
    id: number
    price: number
    address: string
    post: string
    tel: string
    tax_id: number
    name_th: string
    name_en: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: FactoriesCountAggregateOutputType | null
    _avg: FactoriesAvgAggregateOutputType | null
    _sum: FactoriesSumAggregateOutputType | null
    _min: FactoriesMinAggregateOutputType | null
    _max: FactoriesMaxAggregateOutputType | null
  }

  type GetFactoriesGroupByPayload<T extends factoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactoriesGroupByOutputType[P]>
            : GetScalarType<T[P], FactoriesGroupByOutputType[P]>
        }
      >
    >


  export type factoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    price?: boolean
    address?: boolean
    post?: boolean
    tel?: boolean
    tax_id?: boolean
    name_th?: boolean
    name_en?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["factories"]>



  export type factoriesSelectScalar = {
    id?: boolean
    price?: boolean
    address?: boolean
    post?: boolean
    tel?: boolean
    tax_id?: boolean
    name_th?: boolean
    name_en?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type factoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "price" | "address" | "post" | "tel" | "tax_id" | "name_th" | "name_en" | "status" | "create_at" | "update_at", ExtArgs["result"]["factories"]>

  export type $factoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "factories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      price: number
      address: string
      post: string
      tel: string
      tax_id: number
      name_th: string
      name_en: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["factories"]>
    composites: {}
  }

  type factoriesGetPayload<S extends boolean | null | undefined | factoriesDefaultArgs> = $Result.GetResult<Prisma.$factoriesPayload, S>

  type factoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<factoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FactoriesCountAggregateInputType | true
    }

  export interface factoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['factories'], meta: { name: 'factories' } }
    /**
     * Find zero or one Factories that matches the filter.
     * @param {factoriesFindUniqueArgs} args - Arguments to find a Factories
     * @example
     * // Get one Factories
     * const factories = await prisma.factories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends factoriesFindUniqueArgs>(args: SelectSubset<T, factoriesFindUniqueArgs<ExtArgs>>): Prisma__factoriesClient<$Result.GetResult<Prisma.$factoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Factories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {factoriesFindUniqueOrThrowArgs} args - Arguments to find a Factories
     * @example
     * // Get one Factories
     * const factories = await prisma.factories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends factoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, factoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__factoriesClient<$Result.GetResult<Prisma.$factoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Factories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factoriesFindFirstArgs} args - Arguments to find a Factories
     * @example
     * // Get one Factories
     * const factories = await prisma.factories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends factoriesFindFirstArgs>(args?: SelectSubset<T, factoriesFindFirstArgs<ExtArgs>>): Prisma__factoriesClient<$Result.GetResult<Prisma.$factoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Factories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factoriesFindFirstOrThrowArgs} args - Arguments to find a Factories
     * @example
     * // Get one Factories
     * const factories = await prisma.factories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends factoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, factoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__factoriesClient<$Result.GetResult<Prisma.$factoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Factories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Factories
     * const factories = await prisma.factories.findMany()
     * 
     * // Get first 10 Factories
     * const factories = await prisma.factories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factoriesWithIdOnly = await prisma.factories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends factoriesFindManyArgs>(args?: SelectSubset<T, factoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$factoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Factories.
     * @param {factoriesCreateArgs} args - Arguments to create a Factories.
     * @example
     * // Create one Factories
     * const Factories = await prisma.factories.create({
     *   data: {
     *     // ... data to create a Factories
     *   }
     * })
     * 
     */
    create<T extends factoriesCreateArgs>(args: SelectSubset<T, factoriesCreateArgs<ExtArgs>>): Prisma__factoriesClient<$Result.GetResult<Prisma.$factoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Factories.
     * @param {factoriesCreateManyArgs} args - Arguments to create many Factories.
     * @example
     * // Create many Factories
     * const factories = await prisma.factories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends factoriesCreateManyArgs>(args?: SelectSubset<T, factoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Factories.
     * @param {factoriesDeleteArgs} args - Arguments to delete one Factories.
     * @example
     * // Delete one Factories
     * const Factories = await prisma.factories.delete({
     *   where: {
     *     // ... filter to delete one Factories
     *   }
     * })
     * 
     */
    delete<T extends factoriesDeleteArgs>(args: SelectSubset<T, factoriesDeleteArgs<ExtArgs>>): Prisma__factoriesClient<$Result.GetResult<Prisma.$factoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Factories.
     * @param {factoriesUpdateArgs} args - Arguments to update one Factories.
     * @example
     * // Update one Factories
     * const factories = await prisma.factories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends factoriesUpdateArgs>(args: SelectSubset<T, factoriesUpdateArgs<ExtArgs>>): Prisma__factoriesClient<$Result.GetResult<Prisma.$factoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Factories.
     * @param {factoriesDeleteManyArgs} args - Arguments to filter Factories to delete.
     * @example
     * // Delete a few Factories
     * const { count } = await prisma.factories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends factoriesDeleteManyArgs>(args?: SelectSubset<T, factoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Factories
     * const factories = await prisma.factories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends factoriesUpdateManyArgs>(args: SelectSubset<T, factoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Factories.
     * @param {factoriesUpsertArgs} args - Arguments to update or create a Factories.
     * @example
     * // Update or create a Factories
     * const factories = await prisma.factories.upsert({
     *   create: {
     *     // ... data to create a Factories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Factories we want to update
     *   }
     * })
     */
    upsert<T extends factoriesUpsertArgs>(args: SelectSubset<T, factoriesUpsertArgs<ExtArgs>>): Prisma__factoriesClient<$Result.GetResult<Prisma.$factoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Factories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factoriesCountArgs} args - Arguments to filter Factories to count.
     * @example
     * // Count the number of Factories
     * const count = await prisma.factories.count({
     *   where: {
     *     // ... the filter for the Factories we want to count
     *   }
     * })
    **/
    count<T extends factoriesCountArgs>(
      args?: Subset<T, factoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Factories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactoriesAggregateArgs>(args: Subset<T, FactoriesAggregateArgs>): Prisma.PrismaPromise<GetFactoriesAggregateType<T>>

    /**
     * Group by Factories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {factoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends factoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: factoriesGroupByArgs['orderBy'] }
        : { orderBy?: factoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, factoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the factories model
   */
  readonly fields: factoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for factories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__factoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the factories model
   */
  interface factoriesFieldRefs {
    readonly id: FieldRef<"factories", 'Int'>
    readonly price: FieldRef<"factories", 'Float'>
    readonly address: FieldRef<"factories", 'String'>
    readonly post: FieldRef<"factories", 'String'>
    readonly tel: FieldRef<"factories", 'String'>
    readonly tax_id: FieldRef<"factories", 'Int'>
    readonly name_th: FieldRef<"factories", 'String'>
    readonly name_en: FieldRef<"factories", 'String'>
    readonly status: FieldRef<"factories", 'Boolean'>
    readonly create_at: FieldRef<"factories", 'DateTime'>
    readonly update_at: FieldRef<"factories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * factories findUnique
   */
  export type factoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
    /**
     * Filter, which factories to fetch.
     */
    where: factoriesWhereUniqueInput
  }

  /**
   * factories findUniqueOrThrow
   */
  export type factoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
    /**
     * Filter, which factories to fetch.
     */
    where: factoriesWhereUniqueInput
  }

  /**
   * factories findFirst
   */
  export type factoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
    /**
     * Filter, which factories to fetch.
     */
    where?: factoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factories to fetch.
     */
    orderBy?: factoriesOrderByWithRelationInput | factoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for factories.
     */
    cursor?: factoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of factories.
     */
    distinct?: FactoriesScalarFieldEnum | FactoriesScalarFieldEnum[]
  }

  /**
   * factories findFirstOrThrow
   */
  export type factoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
    /**
     * Filter, which factories to fetch.
     */
    where?: factoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factories to fetch.
     */
    orderBy?: factoriesOrderByWithRelationInput | factoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for factories.
     */
    cursor?: factoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of factories.
     */
    distinct?: FactoriesScalarFieldEnum | FactoriesScalarFieldEnum[]
  }

  /**
   * factories findMany
   */
  export type factoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
    /**
     * Filter, which factories to fetch.
     */
    where?: factoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of factories to fetch.
     */
    orderBy?: factoriesOrderByWithRelationInput | factoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing factories.
     */
    cursor?: factoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` factories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` factories.
     */
    skip?: number
    distinct?: FactoriesScalarFieldEnum | FactoriesScalarFieldEnum[]
  }

  /**
   * factories create
   */
  export type factoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
    /**
     * The data needed to create a factories.
     */
    data: XOR<factoriesCreateInput, factoriesUncheckedCreateInput>
  }

  /**
   * factories createMany
   */
  export type factoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many factories.
     */
    data: factoriesCreateManyInput | factoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * factories update
   */
  export type factoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
    /**
     * The data needed to update a factories.
     */
    data: XOR<factoriesUpdateInput, factoriesUncheckedUpdateInput>
    /**
     * Choose, which factories to update.
     */
    where: factoriesWhereUniqueInput
  }

  /**
   * factories updateMany
   */
  export type factoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update factories.
     */
    data: XOR<factoriesUpdateManyMutationInput, factoriesUncheckedUpdateManyInput>
    /**
     * Filter which factories to update
     */
    where?: factoriesWhereInput
    /**
     * Limit how many factories to update.
     */
    limit?: number
  }

  /**
   * factories upsert
   */
  export type factoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
    /**
     * The filter to search for the factories to update in case it exists.
     */
    where: factoriesWhereUniqueInput
    /**
     * In case the factories found by the `where` argument doesn't exist, create a new factories with this data.
     */
    create: XOR<factoriesCreateInput, factoriesUncheckedCreateInput>
    /**
     * In case the factories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<factoriesUpdateInput, factoriesUncheckedUpdateInput>
  }

  /**
   * factories delete
   */
  export type factoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
    /**
     * Filter which factories to delete.
     */
    where: factoriesWhereUniqueInput
  }

  /**
   * factories deleteMany
   */
  export type factoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which factories to delete
     */
    where?: factoriesWhereInput
    /**
     * Limit how many factories to delete.
     */
    limit?: number
  }

  /**
   * factories without action
   */
  export type factoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the factories
     */
    select?: factoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the factories
     */
    omit?: factoriesOmit<ExtArgs> | null
  }


  /**
   * Model machines
   */

  export type AggregateMachines = {
    _count: MachinesCountAggregateOutputType | null
    _avg: MachinesAvgAggregateOutputType | null
    _sum: MachinesSumAggregateOutputType | null
    _min: MachinesMinAggregateOutputType | null
    _max: MachinesMaxAggregateOutputType | null
  }

  export type MachinesAvgAggregateOutputType = {
    id: number | null
    facetory_id: number | null
  }

  export type MachinesSumAggregateOutputType = {
    id: number | null
    facetory_id: number | null
  }

  export type MachinesMinAggregateOutputType = {
    id: number | null
    facetory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type MachinesMaxAggregateOutputType = {
    id: number | null
    facetory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type MachinesCountAggregateOutputType = {
    id: number
    facetory_id: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type MachinesAvgAggregateInputType = {
    id?: true
    facetory_id?: true
  }

  export type MachinesSumAggregateInputType = {
    id?: true
    facetory_id?: true
  }

  export type MachinesMinAggregateInputType = {
    id?: true
    facetory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type MachinesMaxAggregateInputType = {
    id?: true
    facetory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type MachinesCountAggregateInputType = {
    id?: true
    facetory_id?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type MachinesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which machines to aggregate.
     */
    where?: machinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of machines to fetch.
     */
    orderBy?: machinesOrderByWithRelationInput | machinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: machinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned machines
    **/
    _count?: true | MachinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachinesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachinesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachinesMaxAggregateInputType
  }

  export type GetMachinesAggregateType<T extends MachinesAggregateArgs> = {
        [P in keyof T & keyof AggregateMachines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachines[P]>
      : GetScalarType<T[P], AggregateMachines[P]>
  }




  export type machinesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: machinesWhereInput
    orderBy?: machinesOrderByWithAggregationInput | machinesOrderByWithAggregationInput[]
    by: MachinesScalarFieldEnum[] | MachinesScalarFieldEnum
    having?: machinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachinesCountAggregateInputType | true
    _avg?: MachinesAvgAggregateInputType
    _sum?: MachinesSumAggregateInputType
    _min?: MachinesMinAggregateInputType
    _max?: MachinesMaxAggregateInputType
  }

  export type MachinesGroupByOutputType = {
    id: number
    facetory_id: number
    status: boolean
    create_at: Date
    update_at: Date
    _count: MachinesCountAggregateOutputType | null
    _avg: MachinesAvgAggregateOutputType | null
    _sum: MachinesSumAggregateOutputType | null
    _min: MachinesMinAggregateOutputType | null
    _max: MachinesMaxAggregateOutputType | null
  }

  type GetMachinesGroupByPayload<T extends machinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachinesGroupByOutputType[P]>
            : GetScalarType<T[P], MachinesGroupByOutputType[P]>
        }
      >
    >


  export type machinesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facetory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["machines"]>



  export type machinesSelectScalar = {
    id?: boolean
    facetory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type machinesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facetory_id" | "status" | "create_at" | "update_at", ExtArgs["result"]["machines"]>

  export type $machinesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "machines"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      facetory_id: number
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["machines"]>
    composites: {}
  }

  type machinesGetPayload<S extends boolean | null | undefined | machinesDefaultArgs> = $Result.GetResult<Prisma.$machinesPayload, S>

  type machinesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<machinesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MachinesCountAggregateInputType | true
    }

  export interface machinesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['machines'], meta: { name: 'machines' } }
    /**
     * Find zero or one Machines that matches the filter.
     * @param {machinesFindUniqueArgs} args - Arguments to find a Machines
     * @example
     * // Get one Machines
     * const machines = await prisma.machines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends machinesFindUniqueArgs>(args: SelectSubset<T, machinesFindUniqueArgs<ExtArgs>>): Prisma__machinesClient<$Result.GetResult<Prisma.$machinesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Machines that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {machinesFindUniqueOrThrowArgs} args - Arguments to find a Machines
     * @example
     * // Get one Machines
     * const machines = await prisma.machines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends machinesFindUniqueOrThrowArgs>(args: SelectSubset<T, machinesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__machinesClient<$Result.GetResult<Prisma.$machinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinesFindFirstArgs} args - Arguments to find a Machines
     * @example
     * // Get one Machines
     * const machines = await prisma.machines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends machinesFindFirstArgs>(args?: SelectSubset<T, machinesFindFirstArgs<ExtArgs>>): Prisma__machinesClient<$Result.GetResult<Prisma.$machinesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Machines that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinesFindFirstOrThrowArgs} args - Arguments to find a Machines
     * @example
     * // Get one Machines
     * const machines = await prisma.machines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends machinesFindFirstOrThrowArgs>(args?: SelectSubset<T, machinesFindFirstOrThrowArgs<ExtArgs>>): Prisma__machinesClient<$Result.GetResult<Prisma.$machinesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Machines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Machines
     * const machines = await prisma.machines.findMany()
     * 
     * // Get first 10 Machines
     * const machines = await prisma.machines.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const machinesWithIdOnly = await prisma.machines.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends machinesFindManyArgs>(args?: SelectSubset<T, machinesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$machinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Machines.
     * @param {machinesCreateArgs} args - Arguments to create a Machines.
     * @example
     * // Create one Machines
     * const Machines = await prisma.machines.create({
     *   data: {
     *     // ... data to create a Machines
     *   }
     * })
     * 
     */
    create<T extends machinesCreateArgs>(args: SelectSubset<T, machinesCreateArgs<ExtArgs>>): Prisma__machinesClient<$Result.GetResult<Prisma.$machinesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Machines.
     * @param {machinesCreateManyArgs} args - Arguments to create many Machines.
     * @example
     * // Create many Machines
     * const machines = await prisma.machines.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends machinesCreateManyArgs>(args?: SelectSubset<T, machinesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Machines.
     * @param {machinesDeleteArgs} args - Arguments to delete one Machines.
     * @example
     * // Delete one Machines
     * const Machines = await prisma.machines.delete({
     *   where: {
     *     // ... filter to delete one Machines
     *   }
     * })
     * 
     */
    delete<T extends machinesDeleteArgs>(args: SelectSubset<T, machinesDeleteArgs<ExtArgs>>): Prisma__machinesClient<$Result.GetResult<Prisma.$machinesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Machines.
     * @param {machinesUpdateArgs} args - Arguments to update one Machines.
     * @example
     * // Update one Machines
     * const machines = await prisma.machines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends machinesUpdateArgs>(args: SelectSubset<T, machinesUpdateArgs<ExtArgs>>): Prisma__machinesClient<$Result.GetResult<Prisma.$machinesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Machines.
     * @param {machinesDeleteManyArgs} args - Arguments to filter Machines to delete.
     * @example
     * // Delete a few Machines
     * const { count } = await prisma.machines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends machinesDeleteManyArgs>(args?: SelectSubset<T, machinesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Machines
     * const machines = await prisma.machines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends machinesUpdateManyArgs>(args: SelectSubset<T, machinesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Machines.
     * @param {machinesUpsertArgs} args - Arguments to update or create a Machines.
     * @example
     * // Update or create a Machines
     * const machines = await prisma.machines.upsert({
     *   create: {
     *     // ... data to create a Machines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Machines we want to update
     *   }
     * })
     */
    upsert<T extends machinesUpsertArgs>(args: SelectSubset<T, machinesUpsertArgs<ExtArgs>>): Prisma__machinesClient<$Result.GetResult<Prisma.$machinesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinesCountArgs} args - Arguments to filter Machines to count.
     * @example
     * // Count the number of Machines
     * const count = await prisma.machines.count({
     *   where: {
     *     // ... the filter for the Machines we want to count
     *   }
     * })
    **/
    count<T extends machinesCountArgs>(
      args?: Subset<T, machinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachinesAggregateArgs>(args: Subset<T, MachinesAggregateArgs>): Prisma.PrismaPromise<GetMachinesAggregateType<T>>

    /**
     * Group by Machines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends machinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: machinesGroupByArgs['orderBy'] }
        : { orderBy?: machinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, machinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the machines model
   */
  readonly fields: machinesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for machines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__machinesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the machines model
   */
  interface machinesFieldRefs {
    readonly id: FieldRef<"machines", 'Int'>
    readonly facetory_id: FieldRef<"machines", 'Int'>
    readonly status: FieldRef<"machines", 'Boolean'>
    readonly create_at: FieldRef<"machines", 'DateTime'>
    readonly update_at: FieldRef<"machines", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * machines findUnique
   */
  export type machinesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
    /**
     * Filter, which machines to fetch.
     */
    where: machinesWhereUniqueInput
  }

  /**
   * machines findUniqueOrThrow
   */
  export type machinesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
    /**
     * Filter, which machines to fetch.
     */
    where: machinesWhereUniqueInput
  }

  /**
   * machines findFirst
   */
  export type machinesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
    /**
     * Filter, which machines to fetch.
     */
    where?: machinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of machines to fetch.
     */
    orderBy?: machinesOrderByWithRelationInput | machinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for machines.
     */
    cursor?: machinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of machines.
     */
    distinct?: MachinesScalarFieldEnum | MachinesScalarFieldEnum[]
  }

  /**
   * machines findFirstOrThrow
   */
  export type machinesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
    /**
     * Filter, which machines to fetch.
     */
    where?: machinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of machines to fetch.
     */
    orderBy?: machinesOrderByWithRelationInput | machinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for machines.
     */
    cursor?: machinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` machines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of machines.
     */
    distinct?: MachinesScalarFieldEnum | MachinesScalarFieldEnum[]
  }

  /**
   * machines findMany
   */
  export type machinesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
    /**
     * Filter, which machines to fetch.
     */
    where?: machinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of machines to fetch.
     */
    orderBy?: machinesOrderByWithRelationInput | machinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing machines.
     */
    cursor?: machinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` machines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` machines.
     */
    skip?: number
    distinct?: MachinesScalarFieldEnum | MachinesScalarFieldEnum[]
  }

  /**
   * machines create
   */
  export type machinesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
    /**
     * The data needed to create a machines.
     */
    data: XOR<machinesCreateInput, machinesUncheckedCreateInput>
  }

  /**
   * machines createMany
   */
  export type machinesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many machines.
     */
    data: machinesCreateManyInput | machinesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * machines update
   */
  export type machinesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
    /**
     * The data needed to update a machines.
     */
    data: XOR<machinesUpdateInput, machinesUncheckedUpdateInput>
    /**
     * Choose, which machines to update.
     */
    where: machinesWhereUniqueInput
  }

  /**
   * machines updateMany
   */
  export type machinesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update machines.
     */
    data: XOR<machinesUpdateManyMutationInput, machinesUncheckedUpdateManyInput>
    /**
     * Filter which machines to update
     */
    where?: machinesWhereInput
    /**
     * Limit how many machines to update.
     */
    limit?: number
  }

  /**
   * machines upsert
   */
  export type machinesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
    /**
     * The filter to search for the machines to update in case it exists.
     */
    where: machinesWhereUniqueInput
    /**
     * In case the machines found by the `where` argument doesn't exist, create a new machines with this data.
     */
    create: XOR<machinesCreateInput, machinesUncheckedCreateInput>
    /**
     * In case the machines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<machinesUpdateInput, machinesUncheckedUpdateInput>
  }

  /**
   * machines delete
   */
  export type machinesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
    /**
     * Filter which machines to delete.
     */
    where: machinesWhereUniqueInput
  }

  /**
   * machines deleteMany
   */
  export type machinesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which machines to delete
     */
    where?: machinesWhereInput
    /**
     * Limit how many machines to delete.
     */
    limit?: number
  }

  /**
   * machines without action
   */
  export type machinesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machines
     */
    select?: machinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the machines
     */
    omit?: machinesOmit<ExtArgs> | null
  }


  /**
   * Model contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    factory_sale_office_id: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    factory_sale_office_id: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    factory_sale_office_id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    factory_sale_office_id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    sale_office_id: number
    factory_sale_office_id: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_sale_office_id?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_sale_office_id?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_sale_office_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_sale_office_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    sale_office_id?: true
    factory_sale_office_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact to aggregate.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type contactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactWhereInput
    orderBy?: contactOrderByWithAggregationInput | contactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: contactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    sale_office_id: number
    factory_sale_office_id: number
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends contactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type contactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_office_id?: boolean
    factory_sale_office_id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["contact"]>



  export type contactSelectScalar = {
    id?: boolean
    sale_office_id?: boolean
    factory_sale_office_id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type contactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_office_id" | "factory_sale_office_id" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["contact"]>

  export type $contactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contact"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_office_id: number
      factory_sale_office_id: number
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type contactGetPayload<S extends boolean | null | undefined | contactDefaultArgs> = $Result.GetResult<Prisma.$contactPayload, S>

  type contactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface contactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contact'], meta: { name: 'contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {contactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contactFindUniqueArgs>(args: SelectSubset<T, contactFindUniqueArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contactFindUniqueOrThrowArgs>(args: SelectSubset<T, contactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contactFindFirstArgs>(args?: SelectSubset<T, contactFindFirstArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contactFindFirstOrThrowArgs>(args?: SelectSubset<T, contactFindFirstOrThrowArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contactFindManyArgs>(args?: SelectSubset<T, contactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {contactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends contactCreateArgs>(args: SelectSubset<T, contactCreateArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {contactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contactCreateManyArgs>(args?: SelectSubset<T, contactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {contactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends contactDeleteArgs>(args: SelectSubset<T, contactDeleteArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {contactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contactUpdateArgs>(args: SelectSubset<T, contactUpdateArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {contactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contactDeleteManyArgs>(args?: SelectSubset<T, contactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contactUpdateManyArgs>(args: SelectSubset<T, contactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {contactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends contactUpsertArgs>(args: SelectSubset<T, contactUpsertArgs<ExtArgs>>): Prisma__contactClient<$Result.GetResult<Prisma.$contactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends contactCountArgs>(
      args?: Subset<T, contactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactGroupByArgs['orderBy'] }
        : { orderBy?: contactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contact model
   */
  readonly fields: contactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contact model
   */
  interface contactFieldRefs {
    readonly id: FieldRef<"contact", 'Int'>
    readonly sale_office_id: FieldRef<"contact", 'Int'>
    readonly factory_sale_office_id: FieldRef<"contact", 'Int'>
    readonly description: FieldRef<"contact", 'String'>
    readonly status: FieldRef<"contact", 'Boolean'>
    readonly create_at: FieldRef<"contact", 'DateTime'>
    readonly update_at: FieldRef<"contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contact findUnique
   */
  export type contactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact findUniqueOrThrow
   */
  export type contactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact findFirst
   */
  export type contactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * contact findFirstOrThrow
   */
  export type contactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * contact findMany
   */
  export type contactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * contact create
   */
  export type contactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * The data needed to create a contact.
     */
    data: XOR<contactCreateInput, contactUncheckedCreateInput>
  }

  /**
   * contact createMany
   */
  export type contactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contacts.
     */
    data: contactCreateManyInput | contactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contact update
   */
  export type contactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * The data needed to update a contact.
     */
    data: XOR<contactUpdateInput, contactUncheckedUpdateInput>
    /**
     * Choose, which contact to update.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact updateMany
   */
  export type contactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contacts.
     */
    data: XOR<contactUpdateManyMutationInput, contactUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactWhereInput
    /**
     * Limit how many contacts to update.
     */
    limit?: number
  }

  /**
   * contact upsert
   */
  export type contactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * The filter to search for the contact to update in case it exists.
     */
    where: contactWhereUniqueInput
    /**
     * In case the contact found by the `where` argument doesn't exist, create a new contact with this data.
     */
    create: XOR<contactCreateInput, contactUncheckedCreateInput>
    /**
     * In case the contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactUpdateInput, contactUncheckedUpdateInput>
  }

  /**
   * contact delete
   */
  export type contactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
    /**
     * Filter which contact to delete.
     */
    where: contactWhereUniqueInput
  }

  /**
   * contact deleteMany
   */
  export type contactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to delete
     */
    where?: contactWhereInput
    /**
     * Limit how many contacts to delete.
     */
    limit?: number
  }

  /**
   * contact without action
   */
  export type contactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contact
     */
    omit?: contactOmit<ExtArgs> | null
  }


  /**
   * Model materials
   */

  export type AggregateMaterials = {
    _count: MaterialsCountAggregateOutputType | null
    _avg: MaterialsAvgAggregateOutputType | null
    _sum: MaterialsSumAggregateOutputType | null
    _min: MaterialsMinAggregateOutputType | null
    _max: MaterialsMaxAggregateOutputType | null
  }

  export type MaterialsAvgAggregateOutputType = {
    id: number | null
    material_code: number | null
    material_type_id: number | null
    material_unit_id: number | null
  }

  export type MaterialsSumAggregateOutputType = {
    id: number | null
    material_code: number | null
    material_type_id: number | null
    material_unit_id: number | null
  }

  export type MaterialsMinAggregateOutputType = {
    id: number | null
    material_code: number | null
    material_name_th: string | null
    material_name_en: string | null
    long_meterial_name: string | null
    material_type_id: number | null
    material_unit_id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type MaterialsMaxAggregateOutputType = {
    id: number | null
    material_code: number | null
    material_name_th: string | null
    material_name_en: string | null
    long_meterial_name: string | null
    material_type_id: number | null
    material_unit_id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type MaterialsCountAggregateOutputType = {
    id: number
    material_code: number
    material_name_th: number
    material_name_en: number
    long_meterial_name: number
    material_type_id: number
    material_unit_id: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type MaterialsAvgAggregateInputType = {
    id?: true
    material_code?: true
    material_type_id?: true
    material_unit_id?: true
  }

  export type MaterialsSumAggregateInputType = {
    id?: true
    material_code?: true
    material_type_id?: true
    material_unit_id?: true
  }

  export type MaterialsMinAggregateInputType = {
    id?: true
    material_code?: true
    material_name_th?: true
    material_name_en?: true
    long_meterial_name?: true
    material_type_id?: true
    material_unit_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type MaterialsMaxAggregateInputType = {
    id?: true
    material_code?: true
    material_name_th?: true
    material_name_en?: true
    long_meterial_name?: true
    material_type_id?: true
    material_unit_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type MaterialsCountAggregateInputType = {
    id?: true
    material_code?: true
    material_name_th?: true
    material_name_en?: true
    long_meterial_name?: true
    material_type_id?: true
    material_unit_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type MaterialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materials to aggregate.
     */
    where?: materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materials to fetch.
     */
    orderBy?: materialsOrderByWithRelationInput | materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned materials
    **/
    _count?: true | MaterialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialsMaxAggregateInputType
  }

  export type GetMaterialsAggregateType<T extends MaterialsAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterials[P]>
      : GetScalarType<T[P], AggregateMaterials[P]>
  }




  export type materialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: materialsWhereInput
    orderBy?: materialsOrderByWithAggregationInput | materialsOrderByWithAggregationInput[]
    by: MaterialsScalarFieldEnum[] | MaterialsScalarFieldEnum
    having?: materialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialsCountAggregateInputType | true
    _avg?: MaterialsAvgAggregateInputType
    _sum?: MaterialsSumAggregateInputType
    _min?: MaterialsMinAggregateInputType
    _max?: MaterialsMaxAggregateInputType
  }

  export type MaterialsGroupByOutputType = {
    id: number
    material_code: number
    material_name_th: string
    material_name_en: string
    long_meterial_name: string
    material_type_id: number
    material_unit_id: number
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: MaterialsCountAggregateOutputType | null
    _avg: MaterialsAvgAggregateOutputType | null
    _sum: MaterialsSumAggregateOutputType | null
    _min: MaterialsMinAggregateOutputType | null
    _max: MaterialsMaxAggregateOutputType | null
  }

  type GetMaterialsGroupByPayload<T extends materialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialsGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialsGroupByOutputType[P]>
        }
      >
    >


  export type materialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    material_code?: boolean
    material_name_th?: boolean
    material_name_en?: boolean
    long_meterial_name?: boolean
    material_type_id?: boolean
    material_unit_id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["materials"]>



  export type materialsSelectScalar = {
    id?: boolean
    material_code?: boolean
    material_name_th?: boolean
    material_name_en?: boolean
    long_meterial_name?: boolean
    material_type_id?: boolean
    material_unit_id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type materialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "material_code" | "material_name_th" | "material_name_en" | "long_meterial_name" | "material_type_id" | "material_unit_id" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["materials"]>

  export type $materialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "materials"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      material_code: number
      material_name_th: string
      material_name_en: string
      long_meterial_name: string
      material_type_id: number
      material_unit_id: number
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["materials"]>
    composites: {}
  }

  type materialsGetPayload<S extends boolean | null | undefined | materialsDefaultArgs> = $Result.GetResult<Prisma.$materialsPayload, S>

  type materialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<materialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialsCountAggregateInputType | true
    }

  export interface materialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['materials'], meta: { name: 'materials' } }
    /**
     * Find zero or one Materials that matches the filter.
     * @param {materialsFindUniqueArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends materialsFindUniqueArgs>(args: SelectSubset<T, materialsFindUniqueArgs<ExtArgs>>): Prisma__materialsClient<$Result.GetResult<Prisma.$materialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Materials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {materialsFindUniqueOrThrowArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends materialsFindUniqueOrThrowArgs>(args: SelectSubset<T, materialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__materialsClient<$Result.GetResult<Prisma.$materialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialsFindFirstArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends materialsFindFirstArgs>(args?: SelectSubset<T, materialsFindFirstArgs<ExtArgs>>): Prisma__materialsClient<$Result.GetResult<Prisma.$materialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Materials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialsFindFirstOrThrowArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends materialsFindFirstOrThrowArgs>(args?: SelectSubset<T, materialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__materialsClient<$Result.GetResult<Prisma.$materialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.materials.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.materials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialsWithIdOnly = await prisma.materials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends materialsFindManyArgs>(args?: SelectSubset<T, materialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Materials.
     * @param {materialsCreateArgs} args - Arguments to create a Materials.
     * @example
     * // Create one Materials
     * const Materials = await prisma.materials.create({
     *   data: {
     *     // ... data to create a Materials
     *   }
     * })
     * 
     */
    create<T extends materialsCreateArgs>(args: SelectSubset<T, materialsCreateArgs<ExtArgs>>): Prisma__materialsClient<$Result.GetResult<Prisma.$materialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {materialsCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const materials = await prisma.materials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends materialsCreateManyArgs>(args?: SelectSubset<T, materialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Materials.
     * @param {materialsDeleteArgs} args - Arguments to delete one Materials.
     * @example
     * // Delete one Materials
     * const Materials = await prisma.materials.delete({
     *   where: {
     *     // ... filter to delete one Materials
     *   }
     * })
     * 
     */
    delete<T extends materialsDeleteArgs>(args: SelectSubset<T, materialsDeleteArgs<ExtArgs>>): Prisma__materialsClient<$Result.GetResult<Prisma.$materialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Materials.
     * @param {materialsUpdateArgs} args - Arguments to update one Materials.
     * @example
     * // Update one Materials
     * const materials = await prisma.materials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends materialsUpdateArgs>(args: SelectSubset<T, materialsUpdateArgs<ExtArgs>>): Prisma__materialsClient<$Result.GetResult<Prisma.$materialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {materialsDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.materials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends materialsDeleteManyArgs>(args?: SelectSubset<T, materialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const materials = await prisma.materials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends materialsUpdateManyArgs>(args: SelectSubset<T, materialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materials.
     * @param {materialsUpsertArgs} args - Arguments to update or create a Materials.
     * @example
     * // Update or create a Materials
     * const materials = await prisma.materials.upsert({
     *   create: {
     *     // ... data to create a Materials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materials we want to update
     *   }
     * })
     */
    upsert<T extends materialsUpsertArgs>(args: SelectSubset<T, materialsUpsertArgs<ExtArgs>>): Prisma__materialsClient<$Result.GetResult<Prisma.$materialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialsCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.materials.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends materialsCountArgs>(
      args?: Subset<T, materialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialsAggregateArgs>(args: Subset<T, MaterialsAggregateArgs>): Prisma.PrismaPromise<GetMaterialsAggregateType<T>>

    /**
     * Group by Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends materialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: materialsGroupByArgs['orderBy'] }
        : { orderBy?: materialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, materialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the materials model
   */
  readonly fields: materialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for materials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__materialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the materials model
   */
  interface materialsFieldRefs {
    readonly id: FieldRef<"materials", 'Int'>
    readonly material_code: FieldRef<"materials", 'Int'>
    readonly material_name_th: FieldRef<"materials", 'String'>
    readonly material_name_en: FieldRef<"materials", 'String'>
    readonly long_meterial_name: FieldRef<"materials", 'String'>
    readonly material_type_id: FieldRef<"materials", 'Int'>
    readonly material_unit_id: FieldRef<"materials", 'Int'>
    readonly description: FieldRef<"materials", 'String'>
    readonly status: FieldRef<"materials", 'Boolean'>
    readonly create_at: FieldRef<"materials", 'DateTime'>
    readonly update_at: FieldRef<"materials", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * materials findUnique
   */
  export type materialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
    /**
     * Filter, which materials to fetch.
     */
    where: materialsWhereUniqueInput
  }

  /**
   * materials findUniqueOrThrow
   */
  export type materialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
    /**
     * Filter, which materials to fetch.
     */
    where: materialsWhereUniqueInput
  }

  /**
   * materials findFirst
   */
  export type materialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
    /**
     * Filter, which materials to fetch.
     */
    where?: materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materials to fetch.
     */
    orderBy?: materialsOrderByWithRelationInput | materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materials.
     */
    cursor?: materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materials.
     */
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }

  /**
   * materials findFirstOrThrow
   */
  export type materialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
    /**
     * Filter, which materials to fetch.
     */
    where?: materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materials to fetch.
     */
    orderBy?: materialsOrderByWithRelationInput | materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materials.
     */
    cursor?: materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materials.
     */
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }

  /**
   * materials findMany
   */
  export type materialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
    /**
     * Filter, which materials to fetch.
     */
    where?: materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materials to fetch.
     */
    orderBy?: materialsOrderByWithRelationInput | materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing materials.
     */
    cursor?: materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materials.
     */
    skip?: number
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }

  /**
   * materials create
   */
  export type materialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
    /**
     * The data needed to create a materials.
     */
    data: XOR<materialsCreateInput, materialsUncheckedCreateInput>
  }

  /**
   * materials createMany
   */
  export type materialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many materials.
     */
    data: materialsCreateManyInput | materialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * materials update
   */
  export type materialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
    /**
     * The data needed to update a materials.
     */
    data: XOR<materialsUpdateInput, materialsUncheckedUpdateInput>
    /**
     * Choose, which materials to update.
     */
    where: materialsWhereUniqueInput
  }

  /**
   * materials updateMany
   */
  export type materialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update materials.
     */
    data: XOR<materialsUpdateManyMutationInput, materialsUncheckedUpdateManyInput>
    /**
     * Filter which materials to update
     */
    where?: materialsWhereInput
    /**
     * Limit how many materials to update.
     */
    limit?: number
  }

  /**
   * materials upsert
   */
  export type materialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
    /**
     * The filter to search for the materials to update in case it exists.
     */
    where: materialsWhereUniqueInput
    /**
     * In case the materials found by the `where` argument doesn't exist, create a new materials with this data.
     */
    create: XOR<materialsCreateInput, materialsUncheckedCreateInput>
    /**
     * In case the materials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<materialsUpdateInput, materialsUncheckedUpdateInput>
  }

  /**
   * materials delete
   */
  export type materialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
    /**
     * Filter which materials to delete.
     */
    where: materialsWhereUniqueInput
  }

  /**
   * materials deleteMany
   */
  export type materialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materials to delete
     */
    where?: materialsWhereInput
    /**
     * Limit how many materials to delete.
     */
    limit?: number
  }

  /**
   * materials without action
   */
  export type materialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materials
     */
    select?: materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the materials
     */
    omit?: materialsOmit<ExtArgs> | null
  }


  /**
   * Model material_types
   */

  export type AggregateMaterial_types = {
    _count: Material_typesCountAggregateOutputType | null
    _avg: Material_typesAvgAggregateOutputType | null
    _sum: Material_typesSumAggregateOutputType | null
    _min: Material_typesMinAggregateOutputType | null
    _max: Material_typesMaxAggregateOutputType | null
  }

  export type Material_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Material_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Material_typesMinAggregateOutputType = {
    id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Material_typesMaxAggregateOutputType = {
    id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Material_typesCountAggregateOutputType = {
    id: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Material_typesAvgAggregateInputType = {
    id?: true
  }

  export type Material_typesSumAggregateInputType = {
    id?: true
  }

  export type Material_typesMinAggregateInputType = {
    id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Material_typesMaxAggregateInputType = {
    id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Material_typesCountAggregateInputType = {
    id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Material_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which material_types to aggregate.
     */
    where?: material_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of material_types to fetch.
     */
    orderBy?: material_typesOrderByWithRelationInput | material_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: material_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` material_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` material_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned material_types
    **/
    _count?: true | Material_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Material_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Material_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Material_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Material_typesMaxAggregateInputType
  }

  export type GetMaterial_typesAggregateType<T extends Material_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial_types[P]>
      : GetScalarType<T[P], AggregateMaterial_types[P]>
  }




  export type material_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: material_typesWhereInput
    orderBy?: material_typesOrderByWithAggregationInput | material_typesOrderByWithAggregationInput[]
    by: Material_typesScalarFieldEnum[] | Material_typesScalarFieldEnum
    having?: material_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Material_typesCountAggregateInputType | true
    _avg?: Material_typesAvgAggregateInputType
    _sum?: Material_typesSumAggregateInputType
    _min?: Material_typesMinAggregateInputType
    _max?: Material_typesMaxAggregateInputType
  }

  export type Material_typesGroupByOutputType = {
    id: number
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Material_typesCountAggregateOutputType | null
    _avg: Material_typesAvgAggregateOutputType | null
    _sum: Material_typesSumAggregateOutputType | null
    _min: Material_typesMinAggregateOutputType | null
    _max: Material_typesMaxAggregateOutputType | null
  }

  type GetMaterial_typesGroupByPayload<T extends material_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Material_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Material_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Material_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Material_typesGroupByOutputType[P]>
        }
      >
    >


  export type material_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["material_types"]>



  export type material_typesSelectScalar = {
    id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type material_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["material_types"]>

  export type $material_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "material_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["material_types"]>
    composites: {}
  }

  type material_typesGetPayload<S extends boolean | null | undefined | material_typesDefaultArgs> = $Result.GetResult<Prisma.$material_typesPayload, S>

  type material_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<material_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Material_typesCountAggregateInputType | true
    }

  export interface material_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['material_types'], meta: { name: 'material_types' } }
    /**
     * Find zero or one Material_types that matches the filter.
     * @param {material_typesFindUniqueArgs} args - Arguments to find a Material_types
     * @example
     * // Get one Material_types
     * const material_types = await prisma.material_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends material_typesFindUniqueArgs>(args: SelectSubset<T, material_typesFindUniqueArgs<ExtArgs>>): Prisma__material_typesClient<$Result.GetResult<Prisma.$material_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {material_typesFindUniqueOrThrowArgs} args - Arguments to find a Material_types
     * @example
     * // Get one Material_types
     * const material_types = await prisma.material_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends material_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, material_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__material_typesClient<$Result.GetResult<Prisma.$material_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {material_typesFindFirstArgs} args - Arguments to find a Material_types
     * @example
     * // Get one Material_types
     * const material_types = await prisma.material_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends material_typesFindFirstArgs>(args?: SelectSubset<T, material_typesFindFirstArgs<ExtArgs>>): Prisma__material_typesClient<$Result.GetResult<Prisma.$material_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {material_typesFindFirstOrThrowArgs} args - Arguments to find a Material_types
     * @example
     * // Get one Material_types
     * const material_types = await prisma.material_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends material_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, material_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__material_typesClient<$Result.GetResult<Prisma.$material_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Material_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {material_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Material_types
     * const material_types = await prisma.material_types.findMany()
     * 
     * // Get first 10 Material_types
     * const material_types = await prisma.material_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const material_typesWithIdOnly = await prisma.material_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends material_typesFindManyArgs>(args?: SelectSubset<T, material_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$material_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material_types.
     * @param {material_typesCreateArgs} args - Arguments to create a Material_types.
     * @example
     * // Create one Material_types
     * const Material_types = await prisma.material_types.create({
     *   data: {
     *     // ... data to create a Material_types
     *   }
     * })
     * 
     */
    create<T extends material_typesCreateArgs>(args: SelectSubset<T, material_typesCreateArgs<ExtArgs>>): Prisma__material_typesClient<$Result.GetResult<Prisma.$material_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Material_types.
     * @param {material_typesCreateManyArgs} args - Arguments to create many Material_types.
     * @example
     * // Create many Material_types
     * const material_types = await prisma.material_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends material_typesCreateManyArgs>(args?: SelectSubset<T, material_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Material_types.
     * @param {material_typesDeleteArgs} args - Arguments to delete one Material_types.
     * @example
     * // Delete one Material_types
     * const Material_types = await prisma.material_types.delete({
     *   where: {
     *     // ... filter to delete one Material_types
     *   }
     * })
     * 
     */
    delete<T extends material_typesDeleteArgs>(args: SelectSubset<T, material_typesDeleteArgs<ExtArgs>>): Prisma__material_typesClient<$Result.GetResult<Prisma.$material_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material_types.
     * @param {material_typesUpdateArgs} args - Arguments to update one Material_types.
     * @example
     * // Update one Material_types
     * const material_types = await prisma.material_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends material_typesUpdateArgs>(args: SelectSubset<T, material_typesUpdateArgs<ExtArgs>>): Prisma__material_typesClient<$Result.GetResult<Prisma.$material_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Material_types.
     * @param {material_typesDeleteManyArgs} args - Arguments to filter Material_types to delete.
     * @example
     * // Delete a few Material_types
     * const { count } = await prisma.material_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends material_typesDeleteManyArgs>(args?: SelectSubset<T, material_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Material_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {material_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Material_types
     * const material_types = await prisma.material_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends material_typesUpdateManyArgs>(args: SelectSubset<T, material_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Material_types.
     * @param {material_typesUpsertArgs} args - Arguments to update or create a Material_types.
     * @example
     * // Update or create a Material_types
     * const material_types = await prisma.material_types.upsert({
     *   create: {
     *     // ... data to create a Material_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material_types we want to update
     *   }
     * })
     */
    upsert<T extends material_typesUpsertArgs>(args: SelectSubset<T, material_typesUpsertArgs<ExtArgs>>): Prisma__material_typesClient<$Result.GetResult<Prisma.$material_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Material_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {material_typesCountArgs} args - Arguments to filter Material_types to count.
     * @example
     * // Count the number of Material_types
     * const count = await prisma.material_types.count({
     *   where: {
     *     // ... the filter for the Material_types we want to count
     *   }
     * })
    **/
    count<T extends material_typesCountArgs>(
      args?: Subset<T, material_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Material_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Material_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Material_typesAggregateArgs>(args: Subset<T, Material_typesAggregateArgs>): Prisma.PrismaPromise<GetMaterial_typesAggregateType<T>>

    /**
     * Group by Material_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {material_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends material_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: material_typesGroupByArgs['orderBy'] }
        : { orderBy?: material_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, material_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterial_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the material_types model
   */
  readonly fields: material_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for material_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__material_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the material_types model
   */
  interface material_typesFieldRefs {
    readonly id: FieldRef<"material_types", 'Int'>
    readonly description: FieldRef<"material_types", 'String'>
    readonly status: FieldRef<"material_types", 'Boolean'>
    readonly create_at: FieldRef<"material_types", 'DateTime'>
    readonly update_at: FieldRef<"material_types", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * material_types findUnique
   */
  export type material_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
    /**
     * Filter, which material_types to fetch.
     */
    where: material_typesWhereUniqueInput
  }

  /**
   * material_types findUniqueOrThrow
   */
  export type material_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
    /**
     * Filter, which material_types to fetch.
     */
    where: material_typesWhereUniqueInput
  }

  /**
   * material_types findFirst
   */
  export type material_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
    /**
     * Filter, which material_types to fetch.
     */
    where?: material_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of material_types to fetch.
     */
    orderBy?: material_typesOrderByWithRelationInput | material_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for material_types.
     */
    cursor?: material_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` material_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` material_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of material_types.
     */
    distinct?: Material_typesScalarFieldEnum | Material_typesScalarFieldEnum[]
  }

  /**
   * material_types findFirstOrThrow
   */
  export type material_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
    /**
     * Filter, which material_types to fetch.
     */
    where?: material_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of material_types to fetch.
     */
    orderBy?: material_typesOrderByWithRelationInput | material_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for material_types.
     */
    cursor?: material_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` material_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` material_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of material_types.
     */
    distinct?: Material_typesScalarFieldEnum | Material_typesScalarFieldEnum[]
  }

  /**
   * material_types findMany
   */
  export type material_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
    /**
     * Filter, which material_types to fetch.
     */
    where?: material_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of material_types to fetch.
     */
    orderBy?: material_typesOrderByWithRelationInput | material_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing material_types.
     */
    cursor?: material_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` material_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` material_types.
     */
    skip?: number
    distinct?: Material_typesScalarFieldEnum | Material_typesScalarFieldEnum[]
  }

  /**
   * material_types create
   */
  export type material_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a material_types.
     */
    data: XOR<material_typesCreateInput, material_typesUncheckedCreateInput>
  }

  /**
   * material_types createMany
   */
  export type material_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many material_types.
     */
    data: material_typesCreateManyInput | material_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * material_types update
   */
  export type material_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a material_types.
     */
    data: XOR<material_typesUpdateInput, material_typesUncheckedUpdateInput>
    /**
     * Choose, which material_types to update.
     */
    where: material_typesWhereUniqueInput
  }

  /**
   * material_types updateMany
   */
  export type material_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update material_types.
     */
    data: XOR<material_typesUpdateManyMutationInput, material_typesUncheckedUpdateManyInput>
    /**
     * Filter which material_types to update
     */
    where?: material_typesWhereInput
    /**
     * Limit how many material_types to update.
     */
    limit?: number
  }

  /**
   * material_types upsert
   */
  export type material_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the material_types to update in case it exists.
     */
    where: material_typesWhereUniqueInput
    /**
     * In case the material_types found by the `where` argument doesn't exist, create a new material_types with this data.
     */
    create: XOR<material_typesCreateInput, material_typesUncheckedCreateInput>
    /**
     * In case the material_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<material_typesUpdateInput, material_typesUncheckedUpdateInput>
  }

  /**
   * material_types delete
   */
  export type material_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
    /**
     * Filter which material_types to delete.
     */
    where: material_typesWhereUniqueInput
  }

  /**
   * material_types deleteMany
   */
  export type material_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which material_types to delete
     */
    where?: material_typesWhereInput
    /**
     * Limit how many material_types to delete.
     */
    limit?: number
  }

  /**
   * material_types without action
   */
  export type material_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the material_types
     */
    select?: material_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the material_types
     */
    omit?: material_typesOmit<ExtArgs> | null
  }


  /**
   * Model item_units_meaures
   */

  export type AggregateItem_units_meaures = {
    _count: Item_units_meauresCountAggregateOutputType | null
    _avg: Item_units_meauresAvgAggregateOutputType | null
    _sum: Item_units_meauresSumAggregateOutputType | null
    _min: Item_units_meauresMinAggregateOutputType | null
    _max: Item_units_meauresMaxAggregateOutputType | null
  }

  export type Item_units_meauresAvgAggregateOutputType = {
    id: number | null
    material_id: number | null
    qty: number | null
  }

  export type Item_units_meauresSumAggregateOutputType = {
    id: number | null
    material_id: number | null
    qty: number | null
  }

  export type Item_units_meauresMinAggregateOutputType = {
    id: number | null
    material_id: number | null
    packing: string | null
    qty: number | null
    countable_unit_id: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Item_units_meauresMaxAggregateOutputType = {
    id: number | null
    material_id: number | null
    packing: string | null
    qty: number | null
    countable_unit_id: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Item_units_meauresCountAggregateOutputType = {
    id: number
    material_id: number
    packing: number
    qty: number
    countable_unit_id: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Item_units_meauresAvgAggregateInputType = {
    id?: true
    material_id?: true
    qty?: true
  }

  export type Item_units_meauresSumAggregateInputType = {
    id?: true
    material_id?: true
    qty?: true
  }

  export type Item_units_meauresMinAggregateInputType = {
    id?: true
    material_id?: true
    packing?: true
    qty?: true
    countable_unit_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Item_units_meauresMaxAggregateInputType = {
    id?: true
    material_id?: true
    packing?: true
    qty?: true
    countable_unit_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Item_units_meauresCountAggregateInputType = {
    id?: true
    material_id?: true
    packing?: true
    qty?: true
    countable_unit_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Item_units_meauresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_units_meaures to aggregate.
     */
    where?: item_units_meauresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_units_meaures to fetch.
     */
    orderBy?: item_units_meauresOrderByWithRelationInput | item_units_meauresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: item_units_meauresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_units_meaures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_units_meaures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned item_units_meaures
    **/
    _count?: true | Item_units_meauresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Item_units_meauresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Item_units_meauresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Item_units_meauresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Item_units_meauresMaxAggregateInputType
  }

  export type GetItem_units_meauresAggregateType<T extends Item_units_meauresAggregateArgs> = {
        [P in keyof T & keyof AggregateItem_units_meaures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem_units_meaures[P]>
      : GetScalarType<T[P], AggregateItem_units_meaures[P]>
  }




  export type item_units_meauresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_units_meauresWhereInput
    orderBy?: item_units_meauresOrderByWithAggregationInput | item_units_meauresOrderByWithAggregationInput[]
    by: Item_units_meauresScalarFieldEnum[] | Item_units_meauresScalarFieldEnum
    having?: item_units_meauresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Item_units_meauresCountAggregateInputType | true
    _avg?: Item_units_meauresAvgAggregateInputType
    _sum?: Item_units_meauresSumAggregateInputType
    _min?: Item_units_meauresMinAggregateInputType
    _max?: Item_units_meauresMaxAggregateInputType
  }

  export type Item_units_meauresGroupByOutputType = {
    id: number
    material_id: number
    packing: string
    qty: number
    countable_unit_id: string
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Item_units_meauresCountAggregateOutputType | null
    _avg: Item_units_meauresAvgAggregateOutputType | null
    _sum: Item_units_meauresSumAggregateOutputType | null
    _min: Item_units_meauresMinAggregateOutputType | null
    _max: Item_units_meauresMaxAggregateOutputType | null
  }

  type GetItem_units_meauresGroupByPayload<T extends item_units_meauresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Item_units_meauresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Item_units_meauresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Item_units_meauresGroupByOutputType[P]>
            : GetScalarType<T[P], Item_units_meauresGroupByOutputType[P]>
        }
      >
    >


  export type item_units_meauresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    material_id?: boolean
    packing?: boolean
    qty?: boolean
    countable_unit_id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["item_units_meaures"]>



  export type item_units_meauresSelectScalar = {
    id?: boolean
    material_id?: boolean
    packing?: boolean
    qty?: boolean
    countable_unit_id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type item_units_meauresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "material_id" | "packing" | "qty" | "countable_unit_id" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["item_units_meaures"]>

  export type $item_units_meauresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "item_units_meaures"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      material_id: number
      packing: string
      qty: number
      countable_unit_id: string
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["item_units_meaures"]>
    composites: {}
  }

  type item_units_meauresGetPayload<S extends boolean | null | undefined | item_units_meauresDefaultArgs> = $Result.GetResult<Prisma.$item_units_meauresPayload, S>

  type item_units_meauresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<item_units_meauresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Item_units_meauresCountAggregateInputType | true
    }

  export interface item_units_meauresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['item_units_meaures'], meta: { name: 'item_units_meaures' } }
    /**
     * Find zero or one Item_units_meaures that matches the filter.
     * @param {item_units_meauresFindUniqueArgs} args - Arguments to find a Item_units_meaures
     * @example
     * // Get one Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends item_units_meauresFindUniqueArgs>(args: SelectSubset<T, item_units_meauresFindUniqueArgs<ExtArgs>>): Prisma__item_units_meauresClient<$Result.GetResult<Prisma.$item_units_meauresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item_units_meaures that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {item_units_meauresFindUniqueOrThrowArgs} args - Arguments to find a Item_units_meaures
     * @example
     * // Get one Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends item_units_meauresFindUniqueOrThrowArgs>(args: SelectSubset<T, item_units_meauresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__item_units_meauresClient<$Result.GetResult<Prisma.$item_units_meauresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_units_meaures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_units_meauresFindFirstArgs} args - Arguments to find a Item_units_meaures
     * @example
     * // Get one Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends item_units_meauresFindFirstArgs>(args?: SelectSubset<T, item_units_meauresFindFirstArgs<ExtArgs>>): Prisma__item_units_meauresClient<$Result.GetResult<Prisma.$item_units_meauresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_units_meaures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_units_meauresFindFirstOrThrowArgs} args - Arguments to find a Item_units_meaures
     * @example
     * // Get one Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends item_units_meauresFindFirstOrThrowArgs>(args?: SelectSubset<T, item_units_meauresFindFirstOrThrowArgs<ExtArgs>>): Prisma__item_units_meauresClient<$Result.GetResult<Prisma.$item_units_meauresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Item_units_meaures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_units_meauresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.findMany()
     * 
     * // Get first 10 Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const item_units_meauresWithIdOnly = await prisma.item_units_meaures.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends item_units_meauresFindManyArgs>(args?: SelectSubset<T, item_units_meauresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_units_meauresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item_units_meaures.
     * @param {item_units_meauresCreateArgs} args - Arguments to create a Item_units_meaures.
     * @example
     * // Create one Item_units_meaures
     * const Item_units_meaures = await prisma.item_units_meaures.create({
     *   data: {
     *     // ... data to create a Item_units_meaures
     *   }
     * })
     * 
     */
    create<T extends item_units_meauresCreateArgs>(args: SelectSubset<T, item_units_meauresCreateArgs<ExtArgs>>): Prisma__item_units_meauresClient<$Result.GetResult<Prisma.$item_units_meauresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Item_units_meaures.
     * @param {item_units_meauresCreateManyArgs} args - Arguments to create many Item_units_meaures.
     * @example
     * // Create many Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends item_units_meauresCreateManyArgs>(args?: SelectSubset<T, item_units_meauresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item_units_meaures.
     * @param {item_units_meauresDeleteArgs} args - Arguments to delete one Item_units_meaures.
     * @example
     * // Delete one Item_units_meaures
     * const Item_units_meaures = await prisma.item_units_meaures.delete({
     *   where: {
     *     // ... filter to delete one Item_units_meaures
     *   }
     * })
     * 
     */
    delete<T extends item_units_meauresDeleteArgs>(args: SelectSubset<T, item_units_meauresDeleteArgs<ExtArgs>>): Prisma__item_units_meauresClient<$Result.GetResult<Prisma.$item_units_meauresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item_units_meaures.
     * @param {item_units_meauresUpdateArgs} args - Arguments to update one Item_units_meaures.
     * @example
     * // Update one Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends item_units_meauresUpdateArgs>(args: SelectSubset<T, item_units_meauresUpdateArgs<ExtArgs>>): Prisma__item_units_meauresClient<$Result.GetResult<Prisma.$item_units_meauresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Item_units_meaures.
     * @param {item_units_meauresDeleteManyArgs} args - Arguments to filter Item_units_meaures to delete.
     * @example
     * // Delete a few Item_units_meaures
     * const { count } = await prisma.item_units_meaures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends item_units_meauresDeleteManyArgs>(args?: SelectSubset<T, item_units_meauresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Item_units_meaures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_units_meauresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends item_units_meauresUpdateManyArgs>(args: SelectSubset<T, item_units_meauresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item_units_meaures.
     * @param {item_units_meauresUpsertArgs} args - Arguments to update or create a Item_units_meaures.
     * @example
     * // Update or create a Item_units_meaures
     * const item_units_meaures = await prisma.item_units_meaures.upsert({
     *   create: {
     *     // ... data to create a Item_units_meaures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item_units_meaures we want to update
     *   }
     * })
     */
    upsert<T extends item_units_meauresUpsertArgs>(args: SelectSubset<T, item_units_meauresUpsertArgs<ExtArgs>>): Prisma__item_units_meauresClient<$Result.GetResult<Prisma.$item_units_meauresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Item_units_meaures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_units_meauresCountArgs} args - Arguments to filter Item_units_meaures to count.
     * @example
     * // Count the number of Item_units_meaures
     * const count = await prisma.item_units_meaures.count({
     *   where: {
     *     // ... the filter for the Item_units_meaures we want to count
     *   }
     * })
    **/
    count<T extends item_units_meauresCountArgs>(
      args?: Subset<T, item_units_meauresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Item_units_meauresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item_units_meaures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Item_units_meauresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Item_units_meauresAggregateArgs>(args: Subset<T, Item_units_meauresAggregateArgs>): Prisma.PrismaPromise<GetItem_units_meauresAggregateType<T>>

    /**
     * Group by Item_units_meaures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_units_meauresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends item_units_meauresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: item_units_meauresGroupByArgs['orderBy'] }
        : { orderBy?: item_units_meauresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, item_units_meauresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItem_units_meauresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the item_units_meaures model
   */
  readonly fields: item_units_meauresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for item_units_meaures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__item_units_meauresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the item_units_meaures model
   */
  interface item_units_meauresFieldRefs {
    readonly id: FieldRef<"item_units_meaures", 'Int'>
    readonly material_id: FieldRef<"item_units_meaures", 'Int'>
    readonly packing: FieldRef<"item_units_meaures", 'String'>
    readonly qty: FieldRef<"item_units_meaures", 'Float'>
    readonly countable_unit_id: FieldRef<"item_units_meaures", 'String'>
    readonly description: FieldRef<"item_units_meaures", 'String'>
    readonly status: FieldRef<"item_units_meaures", 'Boolean'>
    readonly create_at: FieldRef<"item_units_meaures", 'DateTime'>
    readonly update_at: FieldRef<"item_units_meaures", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * item_units_meaures findUnique
   */
  export type item_units_meauresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
    /**
     * Filter, which item_units_meaures to fetch.
     */
    where: item_units_meauresWhereUniqueInput
  }

  /**
   * item_units_meaures findUniqueOrThrow
   */
  export type item_units_meauresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
    /**
     * Filter, which item_units_meaures to fetch.
     */
    where: item_units_meauresWhereUniqueInput
  }

  /**
   * item_units_meaures findFirst
   */
  export type item_units_meauresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
    /**
     * Filter, which item_units_meaures to fetch.
     */
    where?: item_units_meauresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_units_meaures to fetch.
     */
    orderBy?: item_units_meauresOrderByWithRelationInput | item_units_meauresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_units_meaures.
     */
    cursor?: item_units_meauresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_units_meaures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_units_meaures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_units_meaures.
     */
    distinct?: Item_units_meauresScalarFieldEnum | Item_units_meauresScalarFieldEnum[]
  }

  /**
   * item_units_meaures findFirstOrThrow
   */
  export type item_units_meauresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
    /**
     * Filter, which item_units_meaures to fetch.
     */
    where?: item_units_meauresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_units_meaures to fetch.
     */
    orderBy?: item_units_meauresOrderByWithRelationInput | item_units_meauresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_units_meaures.
     */
    cursor?: item_units_meauresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_units_meaures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_units_meaures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_units_meaures.
     */
    distinct?: Item_units_meauresScalarFieldEnum | Item_units_meauresScalarFieldEnum[]
  }

  /**
   * item_units_meaures findMany
   */
  export type item_units_meauresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
    /**
     * Filter, which item_units_meaures to fetch.
     */
    where?: item_units_meauresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_units_meaures to fetch.
     */
    orderBy?: item_units_meauresOrderByWithRelationInput | item_units_meauresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing item_units_meaures.
     */
    cursor?: item_units_meauresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_units_meaures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_units_meaures.
     */
    skip?: number
    distinct?: Item_units_meauresScalarFieldEnum | Item_units_meauresScalarFieldEnum[]
  }

  /**
   * item_units_meaures create
   */
  export type item_units_meauresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
    /**
     * The data needed to create a item_units_meaures.
     */
    data: XOR<item_units_meauresCreateInput, item_units_meauresUncheckedCreateInput>
  }

  /**
   * item_units_meaures createMany
   */
  export type item_units_meauresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many item_units_meaures.
     */
    data: item_units_meauresCreateManyInput | item_units_meauresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * item_units_meaures update
   */
  export type item_units_meauresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
    /**
     * The data needed to update a item_units_meaures.
     */
    data: XOR<item_units_meauresUpdateInput, item_units_meauresUncheckedUpdateInput>
    /**
     * Choose, which item_units_meaures to update.
     */
    where: item_units_meauresWhereUniqueInput
  }

  /**
   * item_units_meaures updateMany
   */
  export type item_units_meauresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update item_units_meaures.
     */
    data: XOR<item_units_meauresUpdateManyMutationInput, item_units_meauresUncheckedUpdateManyInput>
    /**
     * Filter which item_units_meaures to update
     */
    where?: item_units_meauresWhereInput
    /**
     * Limit how many item_units_meaures to update.
     */
    limit?: number
  }

  /**
   * item_units_meaures upsert
   */
  export type item_units_meauresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
    /**
     * The filter to search for the item_units_meaures to update in case it exists.
     */
    where: item_units_meauresWhereUniqueInput
    /**
     * In case the item_units_meaures found by the `where` argument doesn't exist, create a new item_units_meaures with this data.
     */
    create: XOR<item_units_meauresCreateInput, item_units_meauresUncheckedCreateInput>
    /**
     * In case the item_units_meaures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<item_units_meauresUpdateInput, item_units_meauresUncheckedUpdateInput>
  }

  /**
   * item_units_meaures delete
   */
  export type item_units_meauresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
    /**
     * Filter which item_units_meaures to delete.
     */
    where: item_units_meauresWhereUniqueInput
  }

  /**
   * item_units_meaures deleteMany
   */
  export type item_units_meauresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_units_meaures to delete
     */
    where?: item_units_meauresWhereInput
    /**
     * Limit how many item_units_meaures to delete.
     */
    limit?: number
  }

  /**
   * item_units_meaures without action
   */
  export type item_units_meauresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_units_meaures
     */
    select?: item_units_meauresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_units_meaures
     */
    omit?: item_units_meauresOmit<ExtArgs> | null
  }


  /**
   * Model items
   */

  export type AggregateItems = {
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  export type ItemsAvgAggregateOutputType = {
    id: number | null
    material_id: number | null
    saleoffice_id: number | null
    department_id: number | null
    item_category_id: number | null
    stock_location_id: number | null
  }

  export type ItemsSumAggregateOutputType = {
    id: number | null
    material_id: number | null
    saleoffice_id: number | null
    department_id: number | null
    item_category_id: number | null
    stock_location_id: number | null
  }

  export type ItemsMinAggregateOutputType = {
    id: number | null
    material_id: number | null
    saleoffice_id: number | null
    department_id: number | null
    item_category_id: number | null
    stock_location_id: number | null
    name_th: string | null
    name_en: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type ItemsMaxAggregateOutputType = {
    id: number | null
    material_id: number | null
    saleoffice_id: number | null
    department_id: number | null
    item_category_id: number | null
    stock_location_id: number | null
    name_th: string | null
    name_en: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type ItemsCountAggregateOutputType = {
    id: number
    material_id: number
    saleoffice_id: number
    department_id: number
    item_category_id: number
    stock_location_id: number
    name_th: number
    name_en: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type ItemsAvgAggregateInputType = {
    id?: true
    material_id?: true
    saleoffice_id?: true
    department_id?: true
    item_category_id?: true
    stock_location_id?: true
  }

  export type ItemsSumAggregateInputType = {
    id?: true
    material_id?: true
    saleoffice_id?: true
    department_id?: true
    item_category_id?: true
    stock_location_id?: true
  }

  export type ItemsMinAggregateInputType = {
    id?: true
    material_id?: true
    saleoffice_id?: true
    department_id?: true
    item_category_id?: true
    stock_location_id?: true
    name_th?: true
    name_en?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type ItemsMaxAggregateInputType = {
    id?: true
    material_id?: true
    saleoffice_id?: true
    department_id?: true
    item_category_id?: true
    stock_location_id?: true
    name_th?: true
    name_en?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type ItemsCountAggregateInputType = {
    id?: true
    material_id?: true
    saleoffice_id?: true
    department_id?: true
    item_category_id?: true
    stock_location_id?: true
    name_th?: true
    name_en?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type ItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to aggregate.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned items
    **/
    _count?: true | ItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsMaxAggregateInputType
  }

  export type GetItemsAggregateType<T extends ItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItems[P]>
      : GetScalarType<T[P], AggregateItems[P]>
  }




  export type itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: itemsWhereInput
    orderBy?: itemsOrderByWithAggregationInput | itemsOrderByWithAggregationInput[]
    by: ItemsScalarFieldEnum[] | ItemsScalarFieldEnum
    having?: itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsCountAggregateInputType | true
    _avg?: ItemsAvgAggregateInputType
    _sum?: ItemsSumAggregateInputType
    _min?: ItemsMinAggregateInputType
    _max?: ItemsMaxAggregateInputType
  }

  export type ItemsGroupByOutputType = {
    id: number
    material_id: number
    saleoffice_id: number
    department_id: number
    item_category_id: number
    stock_location_id: number
    name_th: string | null
    name_en: string | null
    status: boolean
    create_at: Date
    update_at: Date
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  type GetItemsGroupByPayload<T extends itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsGroupByOutputType[P]>
        }
      >
    >


  export type itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    material_id?: boolean
    saleoffice_id?: boolean
    department_id?: boolean
    item_category_id?: boolean
    stock_location_id?: boolean
    name_th?: boolean
    name_en?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["items"]>



  export type itemsSelectScalar = {
    id?: boolean
    material_id?: boolean
    saleoffice_id?: boolean
    department_id?: boolean
    item_category_id?: boolean
    stock_location_id?: boolean
    name_th?: boolean
    name_en?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type itemsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "material_id" | "saleoffice_id" | "department_id" | "item_category_id" | "stock_location_id" | "name_th" | "name_en" | "status" | "create_at" | "update_at", ExtArgs["result"]["items"]>

  export type $itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "items"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      material_id: number
      saleoffice_id: number
      department_id: number
      item_category_id: number
      stock_location_id: number
      name_th: string | null
      name_en: string | null
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["items"]>
    composites: {}
  }

  type itemsGetPayload<S extends boolean | null | undefined | itemsDefaultArgs> = $Result.GetResult<Prisma.$itemsPayload, S>

  type itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<itemsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemsCountAggregateInputType | true
    }

  export interface itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['items'], meta: { name: 'items' } }
    /**
     * Find zero or one Items that matches the filter.
     * @param {itemsFindUniqueArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends itemsFindUniqueArgs>(args: SelectSubset<T, itemsFindUniqueArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Items that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {itemsFindUniqueOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends itemsFindFirstArgs>(args?: SelectSubset<T, itemsFindFirstArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindFirstOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.items.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemsWithIdOnly = await prisma.items.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends itemsFindManyArgs>(args?: SelectSubset<T, itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Items.
     * @param {itemsCreateArgs} args - Arguments to create a Items.
     * @example
     * // Create one Items
     * const Items = await prisma.items.create({
     *   data: {
     *     // ... data to create a Items
     *   }
     * })
     * 
     */
    create<T extends itemsCreateArgs>(args: SelectSubset<T, itemsCreateArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {itemsCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const items = await prisma.items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends itemsCreateManyArgs>(args?: SelectSubset<T, itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Items.
     * @param {itemsDeleteArgs} args - Arguments to delete one Items.
     * @example
     * // Delete one Items
     * const Items = await prisma.items.delete({
     *   where: {
     *     // ... filter to delete one Items
     *   }
     * })
     * 
     */
    delete<T extends itemsDeleteArgs>(args: SelectSubset<T, itemsDeleteArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Items.
     * @param {itemsUpdateArgs} args - Arguments to update one Items.
     * @example
     * // Update one Items
     * const items = await prisma.items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends itemsUpdateArgs>(args: SelectSubset<T, itemsUpdateArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {itemsDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends itemsDeleteManyArgs>(args?: SelectSubset<T, itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends itemsUpdateManyArgs>(args: SelectSubset<T, itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Items.
     * @param {itemsUpsertArgs} args - Arguments to update or create a Items.
     * @example
     * // Update or create a Items
     * const items = await prisma.items.upsert({
     *   create: {
     *     // ... data to create a Items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Items we want to update
     *   }
     * })
     */
    upsert<T extends itemsUpsertArgs>(args: SelectSubset<T, itemsUpsertArgs<ExtArgs>>): Prisma__itemsClient<$Result.GetResult<Prisma.$itemsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.items.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends itemsCountArgs>(
      args?: Subset<T, itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsAggregateArgs>(args: Subset<T, ItemsAggregateArgs>): Prisma.PrismaPromise<GetItemsAggregateType<T>>

    /**
     * Group by Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: itemsGroupByArgs['orderBy'] }
        : { orderBy?: itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the items model
   */
  readonly fields: itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the items model
   */
  interface itemsFieldRefs {
    readonly id: FieldRef<"items", 'Int'>
    readonly material_id: FieldRef<"items", 'Int'>
    readonly saleoffice_id: FieldRef<"items", 'Int'>
    readonly department_id: FieldRef<"items", 'Int'>
    readonly item_category_id: FieldRef<"items", 'Int'>
    readonly stock_location_id: FieldRef<"items", 'Int'>
    readonly name_th: FieldRef<"items", 'String'>
    readonly name_en: FieldRef<"items", 'String'>
    readonly status: FieldRef<"items", 'Boolean'>
    readonly create_at: FieldRef<"items", 'DateTime'>
    readonly update_at: FieldRef<"items", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * items findUnique
   */
  export type itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findUniqueOrThrow
   */
  export type itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items findFirst
   */
  export type itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findFirstOrThrow
   */
  export type itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items findMany
   */
  export type itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Filter, which items to fetch.
     */
    where?: itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items to fetch.
     */
    orderBy?: itemsOrderByWithRelationInput | itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing items.
     */
    cursor?: itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items.
     */
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }

  /**
   * items create
   */
  export type itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * The data needed to create a items.
     */
    data: XOR<itemsCreateInput, itemsUncheckedCreateInput>
  }

  /**
   * items createMany
   */
  export type itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many items.
     */
    data: itemsCreateManyInput | itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * items update
   */
  export type itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * The data needed to update a items.
     */
    data: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
    /**
     * Choose, which items to update.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items updateMany
   */
  export type itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update items.
     */
    data: XOR<itemsUpdateManyMutationInput, itemsUncheckedUpdateManyInput>
    /**
     * Filter which items to update
     */
    where?: itemsWhereInput
    /**
     * Limit how many items to update.
     */
    limit?: number
  }

  /**
   * items upsert
   */
  export type itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * The filter to search for the items to update in case it exists.
     */
    where: itemsWhereUniqueInput
    /**
     * In case the items found by the `where` argument doesn't exist, create a new items with this data.
     */
    create: XOR<itemsCreateInput, itemsUncheckedCreateInput>
    /**
     * In case the items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<itemsUpdateInput, itemsUncheckedUpdateInput>
  }

  /**
   * items delete
   */
  export type itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
    /**
     * Filter which items to delete.
     */
    where: itemsWhereUniqueInput
  }

  /**
   * items deleteMany
   */
  export type itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items to delete
     */
    where?: itemsWhereInput
    /**
     * Limit how many items to delete.
     */
    limit?: number
  }

  /**
   * items without action
   */
  export type itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items
     */
    select?: itemsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items
     */
    omit?: itemsOmit<ExtArgs> | null
  }


  /**
   * Model items_details
   */

  export type AggregateItems_details = {
    _count: Items_detailsCountAggregateOutputType | null
    _avg: Items_detailsAvgAggregateOutputType | null
    _sum: Items_detailsSumAggregateOutputType | null
    _min: Items_detailsMinAggregateOutputType | null
    _max: Items_detailsMaxAggregateOutputType | null
  }

  export type Items_detailsAvgAggregateOutputType = {
    id: number | null
    item_id: number | null
    sale_office_id: number | null
  }

  export type Items_detailsSumAggregateOutputType = {
    id: number | null
    item_id: number | null
    sale_office_id: number | null
  }

  export type Items_detailsMinAggregateOutputType = {
    id: number | null
    item_id: number | null
    sale_office_id: number | null
    qr_code_number: string | null
    product_lot_number: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Items_detailsMaxAggregateOutputType = {
    id: number | null
    item_id: number | null
    sale_office_id: number | null
    qr_code_number: string | null
    product_lot_number: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Items_detailsCountAggregateOutputType = {
    id: number
    item_id: number
    sale_office_id: number
    qr_code_number: number
    product_lot_number: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Items_detailsAvgAggregateInputType = {
    id?: true
    item_id?: true
    sale_office_id?: true
  }

  export type Items_detailsSumAggregateInputType = {
    id?: true
    item_id?: true
    sale_office_id?: true
  }

  export type Items_detailsMinAggregateInputType = {
    id?: true
    item_id?: true
    sale_office_id?: true
    qr_code_number?: true
    product_lot_number?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Items_detailsMaxAggregateInputType = {
    id?: true
    item_id?: true
    sale_office_id?: true
    qr_code_number?: true
    product_lot_number?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Items_detailsCountAggregateInputType = {
    id?: true
    item_id?: true
    sale_office_id?: true
    qr_code_number?: true
    product_lot_number?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Items_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items_details to aggregate.
     */
    where?: items_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items_details to fetch.
     */
    orderBy?: items_detailsOrderByWithRelationInput | items_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: items_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned items_details
    **/
    _count?: true | Items_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Items_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Items_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Items_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Items_detailsMaxAggregateInputType
  }

  export type GetItems_detailsAggregateType<T extends Items_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateItems_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItems_details[P]>
      : GetScalarType<T[P], AggregateItems_details[P]>
  }




  export type items_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: items_detailsWhereInput
    orderBy?: items_detailsOrderByWithAggregationInput | items_detailsOrderByWithAggregationInput[]
    by: Items_detailsScalarFieldEnum[] | Items_detailsScalarFieldEnum
    having?: items_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Items_detailsCountAggregateInputType | true
    _avg?: Items_detailsAvgAggregateInputType
    _sum?: Items_detailsSumAggregateInputType
    _min?: Items_detailsMinAggregateInputType
    _max?: Items_detailsMaxAggregateInputType
  }

  export type Items_detailsGroupByOutputType = {
    id: number
    item_id: number
    sale_office_id: number
    qr_code_number: string
    product_lot_number: string
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Items_detailsCountAggregateOutputType | null
    _avg: Items_detailsAvgAggregateOutputType | null
    _sum: Items_detailsSumAggregateOutputType | null
    _min: Items_detailsMinAggregateOutputType | null
    _max: Items_detailsMaxAggregateOutputType | null
  }

  type GetItems_detailsGroupByPayload<T extends items_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Items_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Items_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Items_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Items_detailsGroupByOutputType[P]>
        }
      >
    >


  export type items_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    sale_office_id?: boolean
    qr_code_number?: boolean
    product_lot_number?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["items_details"]>



  export type items_detailsSelectScalar = {
    id?: boolean
    item_id?: boolean
    sale_office_id?: boolean
    qr_code_number?: boolean
    product_lot_number?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type items_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_id" | "sale_office_id" | "qr_code_number" | "product_lot_number" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["items_details"]>

  export type $items_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "items_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      item_id: number
      sale_office_id: number
      qr_code_number: string
      product_lot_number: string
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["items_details"]>
    composites: {}
  }

  type items_detailsGetPayload<S extends boolean | null | undefined | items_detailsDefaultArgs> = $Result.GetResult<Prisma.$items_detailsPayload, S>

  type items_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<items_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Items_detailsCountAggregateInputType | true
    }

  export interface items_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['items_details'], meta: { name: 'items_details' } }
    /**
     * Find zero or one Items_details that matches the filter.
     * @param {items_detailsFindUniqueArgs} args - Arguments to find a Items_details
     * @example
     * // Get one Items_details
     * const items_details = await prisma.items_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends items_detailsFindUniqueArgs>(args: SelectSubset<T, items_detailsFindUniqueArgs<ExtArgs>>): Prisma__items_detailsClient<$Result.GetResult<Prisma.$items_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Items_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {items_detailsFindUniqueOrThrowArgs} args - Arguments to find a Items_details
     * @example
     * // Get one Items_details
     * const items_details = await prisma.items_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends items_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, items_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__items_detailsClient<$Result.GetResult<Prisma.$items_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Items_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {items_detailsFindFirstArgs} args - Arguments to find a Items_details
     * @example
     * // Get one Items_details
     * const items_details = await prisma.items_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends items_detailsFindFirstArgs>(args?: SelectSubset<T, items_detailsFindFirstArgs<ExtArgs>>): Prisma__items_detailsClient<$Result.GetResult<Prisma.$items_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Items_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {items_detailsFindFirstOrThrowArgs} args - Arguments to find a Items_details
     * @example
     * // Get one Items_details
     * const items_details = await prisma.items_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends items_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, items_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__items_detailsClient<$Result.GetResult<Prisma.$items_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {items_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items_details
     * const items_details = await prisma.items_details.findMany()
     * 
     * // Get first 10 Items_details
     * const items_details = await prisma.items_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const items_detailsWithIdOnly = await prisma.items_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends items_detailsFindManyArgs>(args?: SelectSubset<T, items_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$items_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Items_details.
     * @param {items_detailsCreateArgs} args - Arguments to create a Items_details.
     * @example
     * // Create one Items_details
     * const Items_details = await prisma.items_details.create({
     *   data: {
     *     // ... data to create a Items_details
     *   }
     * })
     * 
     */
    create<T extends items_detailsCreateArgs>(args: SelectSubset<T, items_detailsCreateArgs<ExtArgs>>): Prisma__items_detailsClient<$Result.GetResult<Prisma.$items_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items_details.
     * @param {items_detailsCreateManyArgs} args - Arguments to create many Items_details.
     * @example
     * // Create many Items_details
     * const items_details = await prisma.items_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends items_detailsCreateManyArgs>(args?: SelectSubset<T, items_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Items_details.
     * @param {items_detailsDeleteArgs} args - Arguments to delete one Items_details.
     * @example
     * // Delete one Items_details
     * const Items_details = await prisma.items_details.delete({
     *   where: {
     *     // ... filter to delete one Items_details
     *   }
     * })
     * 
     */
    delete<T extends items_detailsDeleteArgs>(args: SelectSubset<T, items_detailsDeleteArgs<ExtArgs>>): Prisma__items_detailsClient<$Result.GetResult<Prisma.$items_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Items_details.
     * @param {items_detailsUpdateArgs} args - Arguments to update one Items_details.
     * @example
     * // Update one Items_details
     * const items_details = await prisma.items_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends items_detailsUpdateArgs>(args: SelectSubset<T, items_detailsUpdateArgs<ExtArgs>>): Prisma__items_detailsClient<$Result.GetResult<Prisma.$items_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items_details.
     * @param {items_detailsDeleteManyArgs} args - Arguments to filter Items_details to delete.
     * @example
     * // Delete a few Items_details
     * const { count } = await prisma.items_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends items_detailsDeleteManyArgs>(args?: SelectSubset<T, items_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {items_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items_details
     * const items_details = await prisma.items_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends items_detailsUpdateManyArgs>(args: SelectSubset<T, items_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Items_details.
     * @param {items_detailsUpsertArgs} args - Arguments to update or create a Items_details.
     * @example
     * // Update or create a Items_details
     * const items_details = await prisma.items_details.upsert({
     *   create: {
     *     // ... data to create a Items_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Items_details we want to update
     *   }
     * })
     */
    upsert<T extends items_detailsUpsertArgs>(args: SelectSubset<T, items_detailsUpsertArgs<ExtArgs>>): Prisma__items_detailsClient<$Result.GetResult<Prisma.$items_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {items_detailsCountArgs} args - Arguments to filter Items_details to count.
     * @example
     * // Count the number of Items_details
     * const count = await prisma.items_details.count({
     *   where: {
     *     // ... the filter for the Items_details we want to count
     *   }
     * })
    **/
    count<T extends items_detailsCountArgs>(
      args?: Subset<T, items_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Items_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Items_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Items_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Items_detailsAggregateArgs>(args: Subset<T, Items_detailsAggregateArgs>): Prisma.PrismaPromise<GetItems_detailsAggregateType<T>>

    /**
     * Group by Items_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {items_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends items_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: items_detailsGroupByArgs['orderBy'] }
        : { orderBy?: items_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, items_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItems_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the items_details model
   */
  readonly fields: items_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for items_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__items_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the items_details model
   */
  interface items_detailsFieldRefs {
    readonly id: FieldRef<"items_details", 'Int'>
    readonly item_id: FieldRef<"items_details", 'Int'>
    readonly sale_office_id: FieldRef<"items_details", 'Int'>
    readonly qr_code_number: FieldRef<"items_details", 'String'>
    readonly product_lot_number: FieldRef<"items_details", 'String'>
    readonly description: FieldRef<"items_details", 'String'>
    readonly status: FieldRef<"items_details", 'Boolean'>
    readonly create_at: FieldRef<"items_details", 'DateTime'>
    readonly update_at: FieldRef<"items_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * items_details findUnique
   */
  export type items_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
    /**
     * Filter, which items_details to fetch.
     */
    where: items_detailsWhereUniqueInput
  }

  /**
   * items_details findUniqueOrThrow
   */
  export type items_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
    /**
     * Filter, which items_details to fetch.
     */
    where: items_detailsWhereUniqueInput
  }

  /**
   * items_details findFirst
   */
  export type items_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
    /**
     * Filter, which items_details to fetch.
     */
    where?: items_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items_details to fetch.
     */
    orderBy?: items_detailsOrderByWithRelationInput | items_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items_details.
     */
    cursor?: items_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items_details.
     */
    distinct?: Items_detailsScalarFieldEnum | Items_detailsScalarFieldEnum[]
  }

  /**
   * items_details findFirstOrThrow
   */
  export type items_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
    /**
     * Filter, which items_details to fetch.
     */
    where?: items_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items_details to fetch.
     */
    orderBy?: items_detailsOrderByWithRelationInput | items_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for items_details.
     */
    cursor?: items_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of items_details.
     */
    distinct?: Items_detailsScalarFieldEnum | Items_detailsScalarFieldEnum[]
  }

  /**
   * items_details findMany
   */
  export type items_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
    /**
     * Filter, which items_details to fetch.
     */
    where?: items_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of items_details to fetch.
     */
    orderBy?: items_detailsOrderByWithRelationInput | items_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing items_details.
     */
    cursor?: items_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` items_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` items_details.
     */
    skip?: number
    distinct?: Items_detailsScalarFieldEnum | Items_detailsScalarFieldEnum[]
  }

  /**
   * items_details create
   */
  export type items_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
    /**
     * The data needed to create a items_details.
     */
    data: XOR<items_detailsCreateInput, items_detailsUncheckedCreateInput>
  }

  /**
   * items_details createMany
   */
  export type items_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many items_details.
     */
    data: items_detailsCreateManyInput | items_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * items_details update
   */
  export type items_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
    /**
     * The data needed to update a items_details.
     */
    data: XOR<items_detailsUpdateInput, items_detailsUncheckedUpdateInput>
    /**
     * Choose, which items_details to update.
     */
    where: items_detailsWhereUniqueInput
  }

  /**
   * items_details updateMany
   */
  export type items_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update items_details.
     */
    data: XOR<items_detailsUpdateManyMutationInput, items_detailsUncheckedUpdateManyInput>
    /**
     * Filter which items_details to update
     */
    where?: items_detailsWhereInput
    /**
     * Limit how many items_details to update.
     */
    limit?: number
  }

  /**
   * items_details upsert
   */
  export type items_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
    /**
     * The filter to search for the items_details to update in case it exists.
     */
    where: items_detailsWhereUniqueInput
    /**
     * In case the items_details found by the `where` argument doesn't exist, create a new items_details with this data.
     */
    create: XOR<items_detailsCreateInput, items_detailsUncheckedCreateInput>
    /**
     * In case the items_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<items_detailsUpdateInput, items_detailsUncheckedUpdateInput>
  }

  /**
   * items_details delete
   */
  export type items_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
    /**
     * Filter which items_details to delete.
     */
    where: items_detailsWhereUniqueInput
  }

  /**
   * items_details deleteMany
   */
  export type items_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which items_details to delete
     */
    where?: items_detailsWhereInput
    /**
     * Limit how many items_details to delete.
     */
    limit?: number
  }

  /**
   * items_details without action
   */
  export type items_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the items_details
     */
    select?: items_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the items_details
     */
    omit?: items_detailsOmit<ExtArgs> | null
  }


  /**
   * Model item_categories
   */

  export type AggregateItem_categories = {
    _count: Item_categoriesCountAggregateOutputType | null
    _avg: Item_categoriesAvgAggregateOutputType | null
    _sum: Item_categoriesSumAggregateOutputType | null
    _min: Item_categoriesMinAggregateOutputType | null
    _max: Item_categoriesMaxAggregateOutputType | null
  }

  export type Item_categoriesAvgAggregateOutputType = {
    id: number | null
    type_id: number | null
    sale_office_id: number | null
    department_id: number | null
    stock_location_id: number | null
  }

  export type Item_categoriesSumAggregateOutputType = {
    id: number | null
    type_id: number | null
    sale_office_id: number | null
    department_id: number | null
    stock_location_id: number | null
  }

  export type Item_categoriesMinAggregateOutputType = {
    id: number | null
    type_id: number | null
    sale_office_id: number | null
    department_id: number | null
    stock_location_id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Item_categoriesMaxAggregateOutputType = {
    id: number | null
    type_id: number | null
    sale_office_id: number | null
    department_id: number | null
    stock_location_id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Item_categoriesCountAggregateOutputType = {
    id: number
    type_id: number
    sale_office_id: number
    department_id: number
    stock_location_id: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Item_categoriesAvgAggregateInputType = {
    id?: true
    type_id?: true
    sale_office_id?: true
    department_id?: true
    stock_location_id?: true
  }

  export type Item_categoriesSumAggregateInputType = {
    id?: true
    type_id?: true
    sale_office_id?: true
    department_id?: true
    stock_location_id?: true
  }

  export type Item_categoriesMinAggregateInputType = {
    id?: true
    type_id?: true
    sale_office_id?: true
    department_id?: true
    stock_location_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Item_categoriesMaxAggregateInputType = {
    id?: true
    type_id?: true
    sale_office_id?: true
    department_id?: true
    stock_location_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Item_categoriesCountAggregateInputType = {
    id?: true
    type_id?: true
    sale_office_id?: true
    department_id?: true
    stock_location_id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Item_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_categories to aggregate.
     */
    where?: item_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_categories to fetch.
     */
    orderBy?: item_categoriesOrderByWithRelationInput | item_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: item_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned item_categories
    **/
    _count?: true | Item_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Item_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Item_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Item_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Item_categoriesMaxAggregateInputType
  }

  export type GetItem_categoriesAggregateType<T extends Item_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateItem_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem_categories[P]>
      : GetScalarType<T[P], AggregateItem_categories[P]>
  }




  export type item_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_categoriesWhereInput
    orderBy?: item_categoriesOrderByWithAggregationInput | item_categoriesOrderByWithAggregationInput[]
    by: Item_categoriesScalarFieldEnum[] | Item_categoriesScalarFieldEnum
    having?: item_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Item_categoriesCountAggregateInputType | true
    _avg?: Item_categoriesAvgAggregateInputType
    _sum?: Item_categoriesSumAggregateInputType
    _min?: Item_categoriesMinAggregateInputType
    _max?: Item_categoriesMaxAggregateInputType
  }

  export type Item_categoriesGroupByOutputType = {
    id: number
    type_id: number
    sale_office_id: number
    department_id: number
    stock_location_id: number
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Item_categoriesCountAggregateOutputType | null
    _avg: Item_categoriesAvgAggregateOutputType | null
    _sum: Item_categoriesSumAggregateOutputType | null
    _min: Item_categoriesMinAggregateOutputType | null
    _max: Item_categoriesMaxAggregateOutputType | null
  }

  type GetItem_categoriesGroupByPayload<T extends item_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Item_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Item_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Item_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Item_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type item_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type_id?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    stock_location_id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["item_categories"]>



  export type item_categoriesSelectScalar = {
    id?: boolean
    type_id?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    stock_location_id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type item_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type_id" | "sale_office_id" | "department_id" | "stock_location_id" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["item_categories"]>

  export type $item_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "item_categories"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type_id: number
      sale_office_id: number
      department_id: number
      stock_location_id: number
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["item_categories"]>
    composites: {}
  }

  type item_categoriesGetPayload<S extends boolean | null | undefined | item_categoriesDefaultArgs> = $Result.GetResult<Prisma.$item_categoriesPayload, S>

  type item_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<item_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Item_categoriesCountAggregateInputType | true
    }

  export interface item_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['item_categories'], meta: { name: 'item_categories' } }
    /**
     * Find zero or one Item_categories that matches the filter.
     * @param {item_categoriesFindUniqueArgs} args - Arguments to find a Item_categories
     * @example
     * // Get one Item_categories
     * const item_categories = await prisma.item_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends item_categoriesFindUniqueArgs>(args: SelectSubset<T, item_categoriesFindUniqueArgs<ExtArgs>>): Prisma__item_categoriesClient<$Result.GetResult<Prisma.$item_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {item_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Item_categories
     * @example
     * // Get one Item_categories
     * const item_categories = await prisma.item_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends item_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, item_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__item_categoriesClient<$Result.GetResult<Prisma.$item_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_categoriesFindFirstArgs} args - Arguments to find a Item_categories
     * @example
     * // Get one Item_categories
     * const item_categories = await prisma.item_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends item_categoriesFindFirstArgs>(args?: SelectSubset<T, item_categoriesFindFirstArgs<ExtArgs>>): Prisma__item_categoriesClient<$Result.GetResult<Prisma.$item_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_categoriesFindFirstOrThrowArgs} args - Arguments to find a Item_categories
     * @example
     * // Get one Item_categories
     * const item_categories = await prisma.item_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends item_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, item_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__item_categoriesClient<$Result.GetResult<Prisma.$item_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Item_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Item_categories
     * const item_categories = await prisma.item_categories.findMany()
     * 
     * // Get first 10 Item_categories
     * const item_categories = await prisma.item_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const item_categoriesWithIdOnly = await prisma.item_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends item_categoriesFindManyArgs>(args?: SelectSubset<T, item_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item_categories.
     * @param {item_categoriesCreateArgs} args - Arguments to create a Item_categories.
     * @example
     * // Create one Item_categories
     * const Item_categories = await prisma.item_categories.create({
     *   data: {
     *     // ... data to create a Item_categories
     *   }
     * })
     * 
     */
    create<T extends item_categoriesCreateArgs>(args: SelectSubset<T, item_categoriesCreateArgs<ExtArgs>>): Prisma__item_categoriesClient<$Result.GetResult<Prisma.$item_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Item_categories.
     * @param {item_categoriesCreateManyArgs} args - Arguments to create many Item_categories.
     * @example
     * // Create many Item_categories
     * const item_categories = await prisma.item_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends item_categoriesCreateManyArgs>(args?: SelectSubset<T, item_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item_categories.
     * @param {item_categoriesDeleteArgs} args - Arguments to delete one Item_categories.
     * @example
     * // Delete one Item_categories
     * const Item_categories = await prisma.item_categories.delete({
     *   where: {
     *     // ... filter to delete one Item_categories
     *   }
     * })
     * 
     */
    delete<T extends item_categoriesDeleteArgs>(args: SelectSubset<T, item_categoriesDeleteArgs<ExtArgs>>): Prisma__item_categoriesClient<$Result.GetResult<Prisma.$item_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item_categories.
     * @param {item_categoriesUpdateArgs} args - Arguments to update one Item_categories.
     * @example
     * // Update one Item_categories
     * const item_categories = await prisma.item_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends item_categoriesUpdateArgs>(args: SelectSubset<T, item_categoriesUpdateArgs<ExtArgs>>): Prisma__item_categoriesClient<$Result.GetResult<Prisma.$item_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Item_categories.
     * @param {item_categoriesDeleteManyArgs} args - Arguments to filter Item_categories to delete.
     * @example
     * // Delete a few Item_categories
     * const { count } = await prisma.item_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends item_categoriesDeleteManyArgs>(args?: SelectSubset<T, item_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Item_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Item_categories
     * const item_categories = await prisma.item_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends item_categoriesUpdateManyArgs>(args: SelectSubset<T, item_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item_categories.
     * @param {item_categoriesUpsertArgs} args - Arguments to update or create a Item_categories.
     * @example
     * // Update or create a Item_categories
     * const item_categories = await prisma.item_categories.upsert({
     *   create: {
     *     // ... data to create a Item_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item_categories we want to update
     *   }
     * })
     */
    upsert<T extends item_categoriesUpsertArgs>(args: SelectSubset<T, item_categoriesUpsertArgs<ExtArgs>>): Prisma__item_categoriesClient<$Result.GetResult<Prisma.$item_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Item_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_categoriesCountArgs} args - Arguments to filter Item_categories to count.
     * @example
     * // Count the number of Item_categories
     * const count = await prisma.item_categories.count({
     *   where: {
     *     // ... the filter for the Item_categories we want to count
     *   }
     * })
    **/
    count<T extends item_categoriesCountArgs>(
      args?: Subset<T, item_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Item_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Item_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Item_categoriesAggregateArgs>(args: Subset<T, Item_categoriesAggregateArgs>): Prisma.PrismaPromise<GetItem_categoriesAggregateType<T>>

    /**
     * Group by Item_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends item_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: item_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: item_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, item_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItem_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the item_categories model
   */
  readonly fields: item_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for item_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__item_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the item_categories model
   */
  interface item_categoriesFieldRefs {
    readonly id: FieldRef<"item_categories", 'Int'>
    readonly type_id: FieldRef<"item_categories", 'Int'>
    readonly sale_office_id: FieldRef<"item_categories", 'Int'>
    readonly department_id: FieldRef<"item_categories", 'Int'>
    readonly stock_location_id: FieldRef<"item_categories", 'Int'>
    readonly description: FieldRef<"item_categories", 'String'>
    readonly status: FieldRef<"item_categories", 'Boolean'>
    readonly create_at: FieldRef<"item_categories", 'DateTime'>
    readonly update_at: FieldRef<"item_categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * item_categories findUnique
   */
  export type item_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which item_categories to fetch.
     */
    where: item_categoriesWhereUniqueInput
  }

  /**
   * item_categories findUniqueOrThrow
   */
  export type item_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which item_categories to fetch.
     */
    where: item_categoriesWhereUniqueInput
  }

  /**
   * item_categories findFirst
   */
  export type item_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which item_categories to fetch.
     */
    where?: item_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_categories to fetch.
     */
    orderBy?: item_categoriesOrderByWithRelationInput | item_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_categories.
     */
    cursor?: item_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_categories.
     */
    distinct?: Item_categoriesScalarFieldEnum | Item_categoriesScalarFieldEnum[]
  }

  /**
   * item_categories findFirstOrThrow
   */
  export type item_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which item_categories to fetch.
     */
    where?: item_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_categories to fetch.
     */
    orderBy?: item_categoriesOrderByWithRelationInput | item_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_categories.
     */
    cursor?: item_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_categories.
     */
    distinct?: Item_categoriesScalarFieldEnum | Item_categoriesScalarFieldEnum[]
  }

  /**
   * item_categories findMany
   */
  export type item_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
    /**
     * Filter, which item_categories to fetch.
     */
    where?: item_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_categories to fetch.
     */
    orderBy?: item_categoriesOrderByWithRelationInput | item_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing item_categories.
     */
    cursor?: item_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_categories.
     */
    skip?: number
    distinct?: Item_categoriesScalarFieldEnum | Item_categoriesScalarFieldEnum[]
  }

  /**
   * item_categories create
   */
  export type item_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
    /**
     * The data needed to create a item_categories.
     */
    data: XOR<item_categoriesCreateInput, item_categoriesUncheckedCreateInput>
  }

  /**
   * item_categories createMany
   */
  export type item_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many item_categories.
     */
    data: item_categoriesCreateManyInput | item_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * item_categories update
   */
  export type item_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
    /**
     * The data needed to update a item_categories.
     */
    data: XOR<item_categoriesUpdateInput, item_categoriesUncheckedUpdateInput>
    /**
     * Choose, which item_categories to update.
     */
    where: item_categoriesWhereUniqueInput
  }

  /**
   * item_categories updateMany
   */
  export type item_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update item_categories.
     */
    data: XOR<item_categoriesUpdateManyMutationInput, item_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which item_categories to update
     */
    where?: item_categoriesWhereInput
    /**
     * Limit how many item_categories to update.
     */
    limit?: number
  }

  /**
   * item_categories upsert
   */
  export type item_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
    /**
     * The filter to search for the item_categories to update in case it exists.
     */
    where: item_categoriesWhereUniqueInput
    /**
     * In case the item_categories found by the `where` argument doesn't exist, create a new item_categories with this data.
     */
    create: XOR<item_categoriesCreateInput, item_categoriesUncheckedCreateInput>
    /**
     * In case the item_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<item_categoriesUpdateInput, item_categoriesUncheckedUpdateInput>
  }

  /**
   * item_categories delete
   */
  export type item_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
    /**
     * Filter which item_categories to delete.
     */
    where: item_categoriesWhereUniqueInput
  }

  /**
   * item_categories deleteMany
   */
  export type item_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_categories to delete
     */
    where?: item_categoriesWhereInput
    /**
     * Limit how many item_categories to delete.
     */
    limit?: number
  }

  /**
   * item_categories without action
   */
  export type item_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_categories
     */
    select?: item_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_categories
     */
    omit?: item_categoriesOmit<ExtArgs> | null
  }


  /**
   * Model types
   */

  export type AggregateTypes = {
    _count: TypesCountAggregateOutputType | null
    _avg: TypesAvgAggregateOutputType | null
    _sum: TypesSumAggregateOutputType | null
    _min: TypesMinAggregateOutputType | null
    _max: TypesMaxAggregateOutputType | null
  }

  export type TypesAvgAggregateOutputType = {
    id: number | null
  }

  export type TypesSumAggregateOutputType = {
    id: number | null
  }

  export type TypesMinAggregateOutputType = {
    id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type TypesMaxAggregateOutputType = {
    id: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type TypesCountAggregateOutputType = {
    id: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type TypesAvgAggregateInputType = {
    id?: true
  }

  export type TypesSumAggregateInputType = {
    id?: true
  }

  export type TypesMinAggregateInputType = {
    id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type TypesMaxAggregateInputType = {
    id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type TypesCountAggregateInputType = {
    id?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type TypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which types to aggregate.
     */
    where?: typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of types to fetch.
     */
    orderBy?: typesOrderByWithRelationInput | typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned types
    **/
    _count?: true | TypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypesMaxAggregateInputType
  }

  export type GetTypesAggregateType<T extends TypesAggregateArgs> = {
        [P in keyof T & keyof AggregateTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypes[P]>
      : GetScalarType<T[P], AggregateTypes[P]>
  }




  export type typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: typesWhereInput
    orderBy?: typesOrderByWithAggregationInput | typesOrderByWithAggregationInput[]
    by: TypesScalarFieldEnum[] | TypesScalarFieldEnum
    having?: typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypesCountAggregateInputType | true
    _avg?: TypesAvgAggregateInputType
    _sum?: TypesSumAggregateInputType
    _min?: TypesMinAggregateInputType
    _max?: TypesMaxAggregateInputType
  }

  export type TypesGroupByOutputType = {
    id: number
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: TypesCountAggregateOutputType | null
    _avg: TypesAvgAggregateOutputType | null
    _sum: TypesSumAggregateOutputType | null
    _min: TypesMinAggregateOutputType | null
    _max: TypesMaxAggregateOutputType | null
  }

  type GetTypesGroupByPayload<T extends typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypesGroupByOutputType[P]>
            : GetScalarType<T[P], TypesGroupByOutputType[P]>
        }
      >
    >


  export type typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["types"]>



  export type typesSelectScalar = {
    id?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["types"]>

  export type $typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["types"]>
    composites: {}
  }

  type typesGetPayload<S extends boolean | null | undefined | typesDefaultArgs> = $Result.GetResult<Prisma.$typesPayload, S>

  type typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypesCountAggregateInputType | true
    }

  export interface typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['types'], meta: { name: 'types' } }
    /**
     * Find zero or one Types that matches the filter.
     * @param {typesFindUniqueArgs} args - Arguments to find a Types
     * @example
     * // Get one Types
     * const types = await prisma.types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends typesFindUniqueArgs>(args: SelectSubset<T, typesFindUniqueArgs<ExtArgs>>): Prisma__typesClient<$Result.GetResult<Prisma.$typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {typesFindUniqueOrThrowArgs} args - Arguments to find a Types
     * @example
     * // Get one Types
     * const types = await prisma.types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends typesFindUniqueOrThrowArgs>(args: SelectSubset<T, typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__typesClient<$Result.GetResult<Prisma.$typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typesFindFirstArgs} args - Arguments to find a Types
     * @example
     * // Get one Types
     * const types = await prisma.types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends typesFindFirstArgs>(args?: SelectSubset<T, typesFindFirstArgs<ExtArgs>>): Prisma__typesClient<$Result.GetResult<Prisma.$typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typesFindFirstOrThrowArgs} args - Arguments to find a Types
     * @example
     * // Get one Types
     * const types = await prisma.types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends typesFindFirstOrThrowArgs>(args?: SelectSubset<T, typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__typesClient<$Result.GetResult<Prisma.$typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Types
     * const types = await prisma.types.findMany()
     * 
     * // Get first 10 Types
     * const types = await prisma.types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typesWithIdOnly = await prisma.types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends typesFindManyArgs>(args?: SelectSubset<T, typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Types.
     * @param {typesCreateArgs} args - Arguments to create a Types.
     * @example
     * // Create one Types
     * const Types = await prisma.types.create({
     *   data: {
     *     // ... data to create a Types
     *   }
     * })
     * 
     */
    create<T extends typesCreateArgs>(args: SelectSubset<T, typesCreateArgs<ExtArgs>>): Prisma__typesClient<$Result.GetResult<Prisma.$typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Types.
     * @param {typesCreateManyArgs} args - Arguments to create many Types.
     * @example
     * // Create many Types
     * const types = await prisma.types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends typesCreateManyArgs>(args?: SelectSubset<T, typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Types.
     * @param {typesDeleteArgs} args - Arguments to delete one Types.
     * @example
     * // Delete one Types
     * const Types = await prisma.types.delete({
     *   where: {
     *     // ... filter to delete one Types
     *   }
     * })
     * 
     */
    delete<T extends typesDeleteArgs>(args: SelectSubset<T, typesDeleteArgs<ExtArgs>>): Prisma__typesClient<$Result.GetResult<Prisma.$typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Types.
     * @param {typesUpdateArgs} args - Arguments to update one Types.
     * @example
     * // Update one Types
     * const types = await prisma.types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends typesUpdateArgs>(args: SelectSubset<T, typesUpdateArgs<ExtArgs>>): Prisma__typesClient<$Result.GetResult<Prisma.$typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Types.
     * @param {typesDeleteManyArgs} args - Arguments to filter Types to delete.
     * @example
     * // Delete a few Types
     * const { count } = await prisma.types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends typesDeleteManyArgs>(args?: SelectSubset<T, typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Types
     * const types = await prisma.types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends typesUpdateManyArgs>(args: SelectSubset<T, typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Types.
     * @param {typesUpsertArgs} args - Arguments to update or create a Types.
     * @example
     * // Update or create a Types
     * const types = await prisma.types.upsert({
     *   create: {
     *     // ... data to create a Types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Types we want to update
     *   }
     * })
     */
    upsert<T extends typesUpsertArgs>(args: SelectSubset<T, typesUpsertArgs<ExtArgs>>): Prisma__typesClient<$Result.GetResult<Prisma.$typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typesCountArgs} args - Arguments to filter Types to count.
     * @example
     * // Count the number of Types
     * const count = await prisma.types.count({
     *   where: {
     *     // ... the filter for the Types we want to count
     *   }
     * })
    **/
    count<T extends typesCountArgs>(
      args?: Subset<T, typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypesAggregateArgs>(args: Subset<T, TypesAggregateArgs>): Prisma.PrismaPromise<GetTypesAggregateType<T>>

    /**
     * Group by Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: typesGroupByArgs['orderBy'] }
        : { orderBy?: typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the types model
   */
  readonly fields: typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the types model
   */
  interface typesFieldRefs {
    readonly id: FieldRef<"types", 'Int'>
    readonly description: FieldRef<"types", 'String'>
    readonly status: FieldRef<"types", 'Boolean'>
    readonly create_at: FieldRef<"types", 'DateTime'>
    readonly update_at: FieldRef<"types", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * types findUnique
   */
  export type typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
    /**
     * Filter, which types to fetch.
     */
    where: typesWhereUniqueInput
  }

  /**
   * types findUniqueOrThrow
   */
  export type typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
    /**
     * Filter, which types to fetch.
     */
    where: typesWhereUniqueInput
  }

  /**
   * types findFirst
   */
  export type typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
    /**
     * Filter, which types to fetch.
     */
    where?: typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of types to fetch.
     */
    orderBy?: typesOrderByWithRelationInput | typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for types.
     */
    cursor?: typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of types.
     */
    distinct?: TypesScalarFieldEnum | TypesScalarFieldEnum[]
  }

  /**
   * types findFirstOrThrow
   */
  export type typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
    /**
     * Filter, which types to fetch.
     */
    where?: typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of types to fetch.
     */
    orderBy?: typesOrderByWithRelationInput | typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for types.
     */
    cursor?: typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of types.
     */
    distinct?: TypesScalarFieldEnum | TypesScalarFieldEnum[]
  }

  /**
   * types findMany
   */
  export type typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
    /**
     * Filter, which types to fetch.
     */
    where?: typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of types to fetch.
     */
    orderBy?: typesOrderByWithRelationInput | typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing types.
     */
    cursor?: typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` types.
     */
    skip?: number
    distinct?: TypesScalarFieldEnum | TypesScalarFieldEnum[]
  }

  /**
   * types create
   */
  export type typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
    /**
     * The data needed to create a types.
     */
    data: XOR<typesCreateInput, typesUncheckedCreateInput>
  }

  /**
   * types createMany
   */
  export type typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many types.
     */
    data: typesCreateManyInput | typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * types update
   */
  export type typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
    /**
     * The data needed to update a types.
     */
    data: XOR<typesUpdateInput, typesUncheckedUpdateInput>
    /**
     * Choose, which types to update.
     */
    where: typesWhereUniqueInput
  }

  /**
   * types updateMany
   */
  export type typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update types.
     */
    data: XOR<typesUpdateManyMutationInput, typesUncheckedUpdateManyInput>
    /**
     * Filter which types to update
     */
    where?: typesWhereInput
    /**
     * Limit how many types to update.
     */
    limit?: number
  }

  /**
   * types upsert
   */
  export type typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
    /**
     * The filter to search for the types to update in case it exists.
     */
    where: typesWhereUniqueInput
    /**
     * In case the types found by the `where` argument doesn't exist, create a new types with this data.
     */
    create: XOR<typesCreateInput, typesUncheckedCreateInput>
    /**
     * In case the types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<typesUpdateInput, typesUncheckedUpdateInput>
  }

  /**
   * types delete
   */
  export type typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
    /**
     * Filter which types to delete.
     */
    where: typesWhereUniqueInput
  }

  /**
   * types deleteMany
   */
  export type typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which types to delete
     */
    where?: typesWhereInput
    /**
     * Limit how many types to delete.
     */
    limit?: number
  }

  /**
   * types without action
   */
  export type typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the types
     */
    select?: typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the types
     */
    omit?: typesOmit<ExtArgs> | null
  }


  /**
   * Model item_prices
   */

  export type AggregateItem_prices = {
    _count: Item_pricesCountAggregateOutputType | null
    _avg: Item_pricesAvgAggregateOutputType | null
    _sum: Item_pricesSumAggregateOutputType | null
    _min: Item_pricesMinAggregateOutputType | null
    _max: Item_pricesMaxAggregateOutputType | null
  }

  export type Item_pricesAvgAggregateOutputType = {
    id: number | null
    item_id: number | null
    price: number | null
  }

  export type Item_pricesSumAggregateOutputType = {
    id: number | null
    item_id: number | null
    price: number | null
  }

  export type Item_pricesMinAggregateOutputType = {
    id: number | null
    item_id: number | null
    price: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Item_pricesMaxAggregateOutputType = {
    id: number | null
    item_id: number | null
    price: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Item_pricesCountAggregateOutputType = {
    id: number
    item_id: number
    price: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Item_pricesAvgAggregateInputType = {
    id?: true
    item_id?: true
    price?: true
  }

  export type Item_pricesSumAggregateInputType = {
    id?: true
    item_id?: true
    price?: true
  }

  export type Item_pricesMinAggregateInputType = {
    id?: true
    item_id?: true
    price?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Item_pricesMaxAggregateInputType = {
    id?: true
    item_id?: true
    price?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Item_pricesCountAggregateInputType = {
    id?: true
    item_id?: true
    price?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Item_pricesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_prices to aggregate.
     */
    where?: item_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_prices to fetch.
     */
    orderBy?: item_pricesOrderByWithRelationInput | item_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: item_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned item_prices
    **/
    _count?: true | Item_pricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Item_pricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Item_pricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Item_pricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Item_pricesMaxAggregateInputType
  }

  export type GetItem_pricesAggregateType<T extends Item_pricesAggregateArgs> = {
        [P in keyof T & keyof AggregateItem_prices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem_prices[P]>
      : GetScalarType<T[P], AggregateItem_prices[P]>
  }




  export type item_pricesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: item_pricesWhereInput
    orderBy?: item_pricesOrderByWithAggregationInput | item_pricesOrderByWithAggregationInput[]
    by: Item_pricesScalarFieldEnum[] | Item_pricesScalarFieldEnum
    having?: item_pricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Item_pricesCountAggregateInputType | true
    _avg?: Item_pricesAvgAggregateInputType
    _sum?: Item_pricesSumAggregateInputType
    _min?: Item_pricesMinAggregateInputType
    _max?: Item_pricesMaxAggregateInputType
  }

  export type Item_pricesGroupByOutputType = {
    id: number
    item_id: number
    price: number
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Item_pricesCountAggregateOutputType | null
    _avg: Item_pricesAvgAggregateOutputType | null
    _sum: Item_pricesSumAggregateOutputType | null
    _min: Item_pricesMinAggregateOutputType | null
    _max: Item_pricesMaxAggregateOutputType | null
  }

  type GetItem_pricesGroupByPayload<T extends item_pricesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Item_pricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Item_pricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Item_pricesGroupByOutputType[P]>
            : GetScalarType<T[P], Item_pricesGroupByOutputType[P]>
        }
      >
    >


  export type item_pricesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    price?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["item_prices"]>



  export type item_pricesSelectScalar = {
    id?: boolean
    item_id?: boolean
    price?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type item_pricesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_id" | "price" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["item_prices"]>

  export type $item_pricesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "item_prices"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      item_id: number
      price: number
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["item_prices"]>
    composites: {}
  }

  type item_pricesGetPayload<S extends boolean | null | undefined | item_pricesDefaultArgs> = $Result.GetResult<Prisma.$item_pricesPayload, S>

  type item_pricesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<item_pricesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Item_pricesCountAggregateInputType | true
    }

  export interface item_pricesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['item_prices'], meta: { name: 'item_prices' } }
    /**
     * Find zero or one Item_prices that matches the filter.
     * @param {item_pricesFindUniqueArgs} args - Arguments to find a Item_prices
     * @example
     * // Get one Item_prices
     * const item_prices = await prisma.item_prices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends item_pricesFindUniqueArgs>(args: SelectSubset<T, item_pricesFindUniqueArgs<ExtArgs>>): Prisma__item_pricesClient<$Result.GetResult<Prisma.$item_pricesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item_prices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {item_pricesFindUniqueOrThrowArgs} args - Arguments to find a Item_prices
     * @example
     * // Get one Item_prices
     * const item_prices = await prisma.item_prices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends item_pricesFindUniqueOrThrowArgs>(args: SelectSubset<T, item_pricesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__item_pricesClient<$Result.GetResult<Prisma.$item_pricesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_pricesFindFirstArgs} args - Arguments to find a Item_prices
     * @example
     * // Get one Item_prices
     * const item_prices = await prisma.item_prices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends item_pricesFindFirstArgs>(args?: SelectSubset<T, item_pricesFindFirstArgs<ExtArgs>>): Prisma__item_pricesClient<$Result.GetResult<Prisma.$item_pricesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item_prices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_pricesFindFirstOrThrowArgs} args - Arguments to find a Item_prices
     * @example
     * // Get one Item_prices
     * const item_prices = await prisma.item_prices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends item_pricesFindFirstOrThrowArgs>(args?: SelectSubset<T, item_pricesFindFirstOrThrowArgs<ExtArgs>>): Prisma__item_pricesClient<$Result.GetResult<Prisma.$item_pricesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Item_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_pricesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Item_prices
     * const item_prices = await prisma.item_prices.findMany()
     * 
     * // Get first 10 Item_prices
     * const item_prices = await prisma.item_prices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const item_pricesWithIdOnly = await prisma.item_prices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends item_pricesFindManyArgs>(args?: SelectSubset<T, item_pricesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$item_pricesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item_prices.
     * @param {item_pricesCreateArgs} args - Arguments to create a Item_prices.
     * @example
     * // Create one Item_prices
     * const Item_prices = await prisma.item_prices.create({
     *   data: {
     *     // ... data to create a Item_prices
     *   }
     * })
     * 
     */
    create<T extends item_pricesCreateArgs>(args: SelectSubset<T, item_pricesCreateArgs<ExtArgs>>): Prisma__item_pricesClient<$Result.GetResult<Prisma.$item_pricesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Item_prices.
     * @param {item_pricesCreateManyArgs} args - Arguments to create many Item_prices.
     * @example
     * // Create many Item_prices
     * const item_prices = await prisma.item_prices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends item_pricesCreateManyArgs>(args?: SelectSubset<T, item_pricesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item_prices.
     * @param {item_pricesDeleteArgs} args - Arguments to delete one Item_prices.
     * @example
     * // Delete one Item_prices
     * const Item_prices = await prisma.item_prices.delete({
     *   where: {
     *     // ... filter to delete one Item_prices
     *   }
     * })
     * 
     */
    delete<T extends item_pricesDeleteArgs>(args: SelectSubset<T, item_pricesDeleteArgs<ExtArgs>>): Prisma__item_pricesClient<$Result.GetResult<Prisma.$item_pricesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item_prices.
     * @param {item_pricesUpdateArgs} args - Arguments to update one Item_prices.
     * @example
     * // Update one Item_prices
     * const item_prices = await prisma.item_prices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends item_pricesUpdateArgs>(args: SelectSubset<T, item_pricesUpdateArgs<ExtArgs>>): Prisma__item_pricesClient<$Result.GetResult<Prisma.$item_pricesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Item_prices.
     * @param {item_pricesDeleteManyArgs} args - Arguments to filter Item_prices to delete.
     * @example
     * // Delete a few Item_prices
     * const { count } = await prisma.item_prices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends item_pricesDeleteManyArgs>(args?: SelectSubset<T, item_pricesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Item_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_pricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Item_prices
     * const item_prices = await prisma.item_prices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends item_pricesUpdateManyArgs>(args: SelectSubset<T, item_pricesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item_prices.
     * @param {item_pricesUpsertArgs} args - Arguments to update or create a Item_prices.
     * @example
     * // Update or create a Item_prices
     * const item_prices = await prisma.item_prices.upsert({
     *   create: {
     *     // ... data to create a Item_prices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item_prices we want to update
     *   }
     * })
     */
    upsert<T extends item_pricesUpsertArgs>(args: SelectSubset<T, item_pricesUpsertArgs<ExtArgs>>): Prisma__item_pricesClient<$Result.GetResult<Prisma.$item_pricesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Item_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_pricesCountArgs} args - Arguments to filter Item_prices to count.
     * @example
     * // Count the number of Item_prices
     * const count = await prisma.item_prices.count({
     *   where: {
     *     // ... the filter for the Item_prices we want to count
     *   }
     * })
    **/
    count<T extends item_pricesCountArgs>(
      args?: Subset<T, item_pricesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Item_pricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Item_pricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Item_pricesAggregateArgs>(args: Subset<T, Item_pricesAggregateArgs>): Prisma.PrismaPromise<GetItem_pricesAggregateType<T>>

    /**
     * Group by Item_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {item_pricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends item_pricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: item_pricesGroupByArgs['orderBy'] }
        : { orderBy?: item_pricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, item_pricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItem_pricesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the item_prices model
   */
  readonly fields: item_pricesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for item_prices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__item_pricesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the item_prices model
   */
  interface item_pricesFieldRefs {
    readonly id: FieldRef<"item_prices", 'Int'>
    readonly item_id: FieldRef<"item_prices", 'Int'>
    readonly price: FieldRef<"item_prices", 'Float'>
    readonly description: FieldRef<"item_prices", 'String'>
    readonly status: FieldRef<"item_prices", 'Boolean'>
    readonly create_at: FieldRef<"item_prices", 'DateTime'>
    readonly update_at: FieldRef<"item_prices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * item_prices findUnique
   */
  export type item_pricesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
    /**
     * Filter, which item_prices to fetch.
     */
    where: item_pricesWhereUniqueInput
  }

  /**
   * item_prices findUniqueOrThrow
   */
  export type item_pricesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
    /**
     * Filter, which item_prices to fetch.
     */
    where: item_pricesWhereUniqueInput
  }

  /**
   * item_prices findFirst
   */
  export type item_pricesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
    /**
     * Filter, which item_prices to fetch.
     */
    where?: item_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_prices to fetch.
     */
    orderBy?: item_pricesOrderByWithRelationInput | item_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_prices.
     */
    cursor?: item_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_prices.
     */
    distinct?: Item_pricesScalarFieldEnum | Item_pricesScalarFieldEnum[]
  }

  /**
   * item_prices findFirstOrThrow
   */
  export type item_pricesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
    /**
     * Filter, which item_prices to fetch.
     */
    where?: item_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_prices to fetch.
     */
    orderBy?: item_pricesOrderByWithRelationInput | item_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for item_prices.
     */
    cursor?: item_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of item_prices.
     */
    distinct?: Item_pricesScalarFieldEnum | Item_pricesScalarFieldEnum[]
  }

  /**
   * item_prices findMany
   */
  export type item_pricesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
    /**
     * Filter, which item_prices to fetch.
     */
    where?: item_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of item_prices to fetch.
     */
    orderBy?: item_pricesOrderByWithRelationInput | item_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing item_prices.
     */
    cursor?: item_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` item_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` item_prices.
     */
    skip?: number
    distinct?: Item_pricesScalarFieldEnum | Item_pricesScalarFieldEnum[]
  }

  /**
   * item_prices create
   */
  export type item_pricesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
    /**
     * The data needed to create a item_prices.
     */
    data: XOR<item_pricesCreateInput, item_pricesUncheckedCreateInput>
  }

  /**
   * item_prices createMany
   */
  export type item_pricesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many item_prices.
     */
    data: item_pricesCreateManyInput | item_pricesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * item_prices update
   */
  export type item_pricesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
    /**
     * The data needed to update a item_prices.
     */
    data: XOR<item_pricesUpdateInput, item_pricesUncheckedUpdateInput>
    /**
     * Choose, which item_prices to update.
     */
    where: item_pricesWhereUniqueInput
  }

  /**
   * item_prices updateMany
   */
  export type item_pricesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update item_prices.
     */
    data: XOR<item_pricesUpdateManyMutationInput, item_pricesUncheckedUpdateManyInput>
    /**
     * Filter which item_prices to update
     */
    where?: item_pricesWhereInput
    /**
     * Limit how many item_prices to update.
     */
    limit?: number
  }

  /**
   * item_prices upsert
   */
  export type item_pricesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
    /**
     * The filter to search for the item_prices to update in case it exists.
     */
    where: item_pricesWhereUniqueInput
    /**
     * In case the item_prices found by the `where` argument doesn't exist, create a new item_prices with this data.
     */
    create: XOR<item_pricesCreateInput, item_pricesUncheckedCreateInput>
    /**
     * In case the item_prices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<item_pricesUpdateInput, item_pricesUncheckedUpdateInput>
  }

  /**
   * item_prices delete
   */
  export type item_pricesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
    /**
     * Filter which item_prices to delete.
     */
    where: item_pricesWhereUniqueInput
  }

  /**
   * item_prices deleteMany
   */
  export type item_pricesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which item_prices to delete
     */
    where?: item_pricesWhereInput
    /**
     * Limit how many item_prices to delete.
     */
    limit?: number
  }

  /**
   * item_prices without action
   */
  export type item_pricesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the item_prices
     */
    select?: item_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the item_prices
     */
    omit?: item_pricesOmit<ExtArgs> | null
  }


  /**
   * Model dirties
   */

  export type AggregateDirties = {
    _count: DirtiesCountAggregateOutputType | null
    _avg: DirtiesAvgAggregateOutputType | null
    _sum: DirtiesSumAggregateOutputType | null
    _min: DirtiesMinAggregateOutputType | null
    _max: DirtiesMaxAggregateOutputType | null
  }

  export type DirtiesAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    factory_id: number | null
    user_id: number | null
  }

  export type DirtiesSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    factory_id: number | null
    user_id: number | null
  }

  export type DirtiesMinAggregateOutputType = {
    id: number | null
    dirty_doc_no: string | null
    dirty_doc_date: Date | null
    sale_office_id: number | null
    department_id: number | null
    factory_id: number | null
    user_id: number | null
    signature: string | null
    sign_factory: string | null
    sign_factory_time: Date | null
    sign_NH: string | null
    sign_NH_time: Date | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type DirtiesMaxAggregateOutputType = {
    id: number | null
    dirty_doc_no: string | null
    dirty_doc_date: Date | null
    sale_office_id: number | null
    department_id: number | null
    factory_id: number | null
    user_id: number | null
    signature: string | null
    sign_factory: string | null
    sign_factory_time: Date | null
    sign_NH: string | null
    sign_NH_time: Date | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type DirtiesCountAggregateOutputType = {
    id: number
    dirty_doc_no: number
    dirty_doc_date: number
    sale_office_id: number
    department_id: number
    factory_id: number
    user_id: number
    signature: number
    sign_factory: number
    sign_factory_time: number
    sign_NH: number
    sign_NH_time: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type DirtiesAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    factory_id?: true
    user_id?: true
  }

  export type DirtiesSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    factory_id?: true
    user_id?: true
  }

  export type DirtiesMinAggregateInputType = {
    id?: true
    dirty_doc_no?: true
    dirty_doc_date?: true
    sale_office_id?: true
    department_id?: true
    factory_id?: true
    user_id?: true
    signature?: true
    sign_factory?: true
    sign_factory_time?: true
    sign_NH?: true
    sign_NH_time?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type DirtiesMaxAggregateInputType = {
    id?: true
    dirty_doc_no?: true
    dirty_doc_date?: true
    sale_office_id?: true
    department_id?: true
    factory_id?: true
    user_id?: true
    signature?: true
    sign_factory?: true
    sign_factory_time?: true
    sign_NH?: true
    sign_NH_time?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type DirtiesCountAggregateInputType = {
    id?: true
    dirty_doc_no?: true
    dirty_doc_date?: true
    sale_office_id?: true
    department_id?: true
    factory_id?: true
    user_id?: true
    signature?: true
    sign_factory?: true
    sign_factory_time?: true
    sign_NH?: true
    sign_NH_time?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type DirtiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dirties to aggregate.
     */
    where?: dirtiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dirties to fetch.
     */
    orderBy?: dirtiesOrderByWithRelationInput | dirtiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dirtiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dirties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dirties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dirties
    **/
    _count?: true | DirtiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DirtiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DirtiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirtiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirtiesMaxAggregateInputType
  }

  export type GetDirtiesAggregateType<T extends DirtiesAggregateArgs> = {
        [P in keyof T & keyof AggregateDirties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirties[P]>
      : GetScalarType<T[P], AggregateDirties[P]>
  }




  export type dirtiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dirtiesWhereInput
    orderBy?: dirtiesOrderByWithAggregationInput | dirtiesOrderByWithAggregationInput[]
    by: DirtiesScalarFieldEnum[] | DirtiesScalarFieldEnum
    having?: dirtiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirtiesCountAggregateInputType | true
    _avg?: DirtiesAvgAggregateInputType
    _sum?: DirtiesSumAggregateInputType
    _min?: DirtiesMinAggregateInputType
    _max?: DirtiesMaxAggregateInputType
  }

  export type DirtiesGroupByOutputType = {
    id: number
    dirty_doc_no: string
    dirty_doc_date: Date | null
    sale_office_id: number | null
    department_id: number | null
    factory_id: number | null
    user_id: number | null
    signature: string | null
    sign_factory: string | null
    sign_factory_time: Date | null
    sign_NH: string | null
    sign_NH_time: Date | null
    status: boolean
    create_at: Date
    update_at: Date
    _count: DirtiesCountAggregateOutputType | null
    _avg: DirtiesAvgAggregateOutputType | null
    _sum: DirtiesSumAggregateOutputType | null
    _min: DirtiesMinAggregateOutputType | null
    _max: DirtiesMaxAggregateOutputType | null
  }

  type GetDirtiesGroupByPayload<T extends dirtiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirtiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirtiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirtiesGroupByOutputType[P]>
            : GetScalarType<T[P], DirtiesGroupByOutputType[P]>
        }
      >
    >


  export type dirtiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dirty_doc_no?: boolean
    dirty_doc_date?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    factory_id?: boolean
    user_id?: boolean
    signature?: boolean
    sign_factory?: boolean
    sign_factory_time?: boolean
    sign_NH?: boolean
    sign_NH_time?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["dirties"]>



  export type dirtiesSelectScalar = {
    id?: boolean
    dirty_doc_no?: boolean
    dirty_doc_date?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    factory_id?: boolean
    user_id?: boolean
    signature?: boolean
    sign_factory?: boolean
    sign_factory_time?: boolean
    sign_NH?: boolean
    sign_NH_time?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type dirtiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dirty_doc_no" | "dirty_doc_date" | "sale_office_id" | "department_id" | "factory_id" | "user_id" | "signature" | "sign_factory" | "sign_factory_time" | "sign_NH" | "sign_NH_time" | "status" | "create_at" | "update_at", ExtArgs["result"]["dirties"]>

  export type $dirtiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dirties"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dirty_doc_no: string
      dirty_doc_date: Date | null
      sale_office_id: number | null
      department_id: number | null
      factory_id: number | null
      user_id: number | null
      signature: string | null
      sign_factory: string | null
      sign_factory_time: Date | null
      sign_NH: string | null
      sign_NH_time: Date | null
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["dirties"]>
    composites: {}
  }

  type dirtiesGetPayload<S extends boolean | null | undefined | dirtiesDefaultArgs> = $Result.GetResult<Prisma.$dirtiesPayload, S>

  type dirtiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<dirtiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DirtiesCountAggregateInputType | true
    }

  export interface dirtiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dirties'], meta: { name: 'dirties' } }
    /**
     * Find zero or one Dirties that matches the filter.
     * @param {dirtiesFindUniqueArgs} args - Arguments to find a Dirties
     * @example
     * // Get one Dirties
     * const dirties = await prisma.dirties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dirtiesFindUniqueArgs>(args: SelectSubset<T, dirtiesFindUniqueArgs<ExtArgs>>): Prisma__dirtiesClient<$Result.GetResult<Prisma.$dirtiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dirties that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {dirtiesFindUniqueOrThrowArgs} args - Arguments to find a Dirties
     * @example
     * // Get one Dirties
     * const dirties = await prisma.dirties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dirtiesFindUniqueOrThrowArgs>(args: SelectSubset<T, dirtiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dirtiesClient<$Result.GetResult<Prisma.$dirtiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dirties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirtiesFindFirstArgs} args - Arguments to find a Dirties
     * @example
     * // Get one Dirties
     * const dirties = await prisma.dirties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dirtiesFindFirstArgs>(args?: SelectSubset<T, dirtiesFindFirstArgs<ExtArgs>>): Prisma__dirtiesClient<$Result.GetResult<Prisma.$dirtiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dirties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirtiesFindFirstOrThrowArgs} args - Arguments to find a Dirties
     * @example
     * // Get one Dirties
     * const dirties = await prisma.dirties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dirtiesFindFirstOrThrowArgs>(args?: SelectSubset<T, dirtiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__dirtiesClient<$Result.GetResult<Prisma.$dirtiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dirties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirtiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dirties
     * const dirties = await prisma.dirties.findMany()
     * 
     * // Get first 10 Dirties
     * const dirties = await prisma.dirties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dirtiesWithIdOnly = await prisma.dirties.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dirtiesFindManyArgs>(args?: SelectSubset<T, dirtiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dirtiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dirties.
     * @param {dirtiesCreateArgs} args - Arguments to create a Dirties.
     * @example
     * // Create one Dirties
     * const Dirties = await prisma.dirties.create({
     *   data: {
     *     // ... data to create a Dirties
     *   }
     * })
     * 
     */
    create<T extends dirtiesCreateArgs>(args: SelectSubset<T, dirtiesCreateArgs<ExtArgs>>): Prisma__dirtiesClient<$Result.GetResult<Prisma.$dirtiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dirties.
     * @param {dirtiesCreateManyArgs} args - Arguments to create many Dirties.
     * @example
     * // Create many Dirties
     * const dirties = await prisma.dirties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dirtiesCreateManyArgs>(args?: SelectSubset<T, dirtiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dirties.
     * @param {dirtiesDeleteArgs} args - Arguments to delete one Dirties.
     * @example
     * // Delete one Dirties
     * const Dirties = await prisma.dirties.delete({
     *   where: {
     *     // ... filter to delete one Dirties
     *   }
     * })
     * 
     */
    delete<T extends dirtiesDeleteArgs>(args: SelectSubset<T, dirtiesDeleteArgs<ExtArgs>>): Prisma__dirtiesClient<$Result.GetResult<Prisma.$dirtiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dirties.
     * @param {dirtiesUpdateArgs} args - Arguments to update one Dirties.
     * @example
     * // Update one Dirties
     * const dirties = await prisma.dirties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dirtiesUpdateArgs>(args: SelectSubset<T, dirtiesUpdateArgs<ExtArgs>>): Prisma__dirtiesClient<$Result.GetResult<Prisma.$dirtiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dirties.
     * @param {dirtiesDeleteManyArgs} args - Arguments to filter Dirties to delete.
     * @example
     * // Delete a few Dirties
     * const { count } = await prisma.dirties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dirtiesDeleteManyArgs>(args?: SelectSubset<T, dirtiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dirties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirtiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dirties
     * const dirties = await prisma.dirties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dirtiesUpdateManyArgs>(args: SelectSubset<T, dirtiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dirties.
     * @param {dirtiesUpsertArgs} args - Arguments to update or create a Dirties.
     * @example
     * // Update or create a Dirties
     * const dirties = await prisma.dirties.upsert({
     *   create: {
     *     // ... data to create a Dirties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dirties we want to update
     *   }
     * })
     */
    upsert<T extends dirtiesUpsertArgs>(args: SelectSubset<T, dirtiesUpsertArgs<ExtArgs>>): Prisma__dirtiesClient<$Result.GetResult<Prisma.$dirtiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dirties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirtiesCountArgs} args - Arguments to filter Dirties to count.
     * @example
     * // Count the number of Dirties
     * const count = await prisma.dirties.count({
     *   where: {
     *     // ... the filter for the Dirties we want to count
     *   }
     * })
    **/
    count<T extends dirtiesCountArgs>(
      args?: Subset<T, dirtiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirtiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dirties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirtiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirtiesAggregateArgs>(args: Subset<T, DirtiesAggregateArgs>): Prisma.PrismaPromise<GetDirtiesAggregateType<T>>

    /**
     * Group by Dirties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirtiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dirtiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dirtiesGroupByArgs['orderBy'] }
        : { orderBy?: dirtiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dirtiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirtiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dirties model
   */
  readonly fields: dirtiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dirties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dirtiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dirties model
   */
  interface dirtiesFieldRefs {
    readonly id: FieldRef<"dirties", 'Int'>
    readonly dirty_doc_no: FieldRef<"dirties", 'String'>
    readonly dirty_doc_date: FieldRef<"dirties", 'DateTime'>
    readonly sale_office_id: FieldRef<"dirties", 'Int'>
    readonly department_id: FieldRef<"dirties", 'Int'>
    readonly factory_id: FieldRef<"dirties", 'Int'>
    readonly user_id: FieldRef<"dirties", 'Int'>
    readonly signature: FieldRef<"dirties", 'String'>
    readonly sign_factory: FieldRef<"dirties", 'String'>
    readonly sign_factory_time: FieldRef<"dirties", 'DateTime'>
    readonly sign_NH: FieldRef<"dirties", 'String'>
    readonly sign_NH_time: FieldRef<"dirties", 'DateTime'>
    readonly status: FieldRef<"dirties", 'Boolean'>
    readonly create_at: FieldRef<"dirties", 'DateTime'>
    readonly update_at: FieldRef<"dirties", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dirties findUnique
   */
  export type dirtiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
    /**
     * Filter, which dirties to fetch.
     */
    where: dirtiesWhereUniqueInput
  }

  /**
   * dirties findUniqueOrThrow
   */
  export type dirtiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
    /**
     * Filter, which dirties to fetch.
     */
    where: dirtiesWhereUniqueInput
  }

  /**
   * dirties findFirst
   */
  export type dirtiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
    /**
     * Filter, which dirties to fetch.
     */
    where?: dirtiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dirties to fetch.
     */
    orderBy?: dirtiesOrderByWithRelationInput | dirtiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dirties.
     */
    cursor?: dirtiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dirties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dirties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dirties.
     */
    distinct?: DirtiesScalarFieldEnum | DirtiesScalarFieldEnum[]
  }

  /**
   * dirties findFirstOrThrow
   */
  export type dirtiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
    /**
     * Filter, which dirties to fetch.
     */
    where?: dirtiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dirties to fetch.
     */
    orderBy?: dirtiesOrderByWithRelationInput | dirtiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dirties.
     */
    cursor?: dirtiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dirties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dirties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dirties.
     */
    distinct?: DirtiesScalarFieldEnum | DirtiesScalarFieldEnum[]
  }

  /**
   * dirties findMany
   */
  export type dirtiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
    /**
     * Filter, which dirties to fetch.
     */
    where?: dirtiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dirties to fetch.
     */
    orderBy?: dirtiesOrderByWithRelationInput | dirtiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dirties.
     */
    cursor?: dirtiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dirties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dirties.
     */
    skip?: number
    distinct?: DirtiesScalarFieldEnum | DirtiesScalarFieldEnum[]
  }

  /**
   * dirties create
   */
  export type dirtiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
    /**
     * The data needed to create a dirties.
     */
    data: XOR<dirtiesCreateInput, dirtiesUncheckedCreateInput>
  }

  /**
   * dirties createMany
   */
  export type dirtiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dirties.
     */
    data: dirtiesCreateManyInput | dirtiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dirties update
   */
  export type dirtiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
    /**
     * The data needed to update a dirties.
     */
    data: XOR<dirtiesUpdateInput, dirtiesUncheckedUpdateInput>
    /**
     * Choose, which dirties to update.
     */
    where: dirtiesWhereUniqueInput
  }

  /**
   * dirties updateMany
   */
  export type dirtiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dirties.
     */
    data: XOR<dirtiesUpdateManyMutationInput, dirtiesUncheckedUpdateManyInput>
    /**
     * Filter which dirties to update
     */
    where?: dirtiesWhereInput
    /**
     * Limit how many dirties to update.
     */
    limit?: number
  }

  /**
   * dirties upsert
   */
  export type dirtiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
    /**
     * The filter to search for the dirties to update in case it exists.
     */
    where: dirtiesWhereUniqueInput
    /**
     * In case the dirties found by the `where` argument doesn't exist, create a new dirties with this data.
     */
    create: XOR<dirtiesCreateInput, dirtiesUncheckedCreateInput>
    /**
     * In case the dirties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dirtiesUpdateInput, dirtiesUncheckedUpdateInput>
  }

  /**
   * dirties delete
   */
  export type dirtiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
    /**
     * Filter which dirties to delete.
     */
    where: dirtiesWhereUniqueInput
  }

  /**
   * dirties deleteMany
   */
  export type dirtiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dirties to delete
     */
    where?: dirtiesWhereInput
    /**
     * Limit how many dirties to delete.
     */
    limit?: number
  }

  /**
   * dirties without action
   */
  export type dirtiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirties
     */
    select?: dirtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirties
     */
    omit?: dirtiesOmit<ExtArgs> | null
  }


  /**
   * Model dirty_details
   */

  export type AggregateDirty_details = {
    _count: Dirty_detailsCountAggregateOutputType | null
    _avg: Dirty_detailsAvgAggregateOutputType | null
    _sum: Dirty_detailsSumAggregateOutputType | null
    _min: Dirty_detailsMinAggregateOutputType | null
    _max: Dirty_detailsMaxAggregateOutputType | null
  }

  export type Dirty_detailsAvgAggregateOutputType = {
    id: number | null
    dirty_id: number | null
    department_id: number | null
    item_id: number | null
    unit_id: number | null
    user_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
  }

  export type Dirty_detailsSumAggregateOutputType = {
    id: number | null
    dirty_id: number | null
    department_id: number | null
    item_id: number | null
    unit_id: number | null
    user_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
  }

  export type Dirty_detailsMinAggregateOutputType = {
    id: number | null
    dirty_id: number | null
    department_id: number | null
    item_id: number | null
    unit_id: number | null
    user_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
    is_cancel: boolean | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Dirty_detailsMaxAggregateOutputType = {
    id: number | null
    dirty_id: number | null
    department_id: number | null
    item_id: number | null
    unit_id: number | null
    user_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
    is_cancel: boolean | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Dirty_detailsCountAggregateOutputType = {
    id: number
    dirty_id: number
    department_id: number
    item_id: number
    unit_id: number
    user_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Dirty_detailsAvgAggregateInputType = {
    id?: true
    dirty_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    user_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
  }

  export type Dirty_detailsSumAggregateInputType = {
    id?: true
    dirty_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    user_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
  }

  export type Dirty_detailsMinAggregateInputType = {
    id?: true
    dirty_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    user_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
    is_cancel?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Dirty_detailsMaxAggregateInputType = {
    id?: true
    dirty_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    user_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
    is_cancel?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Dirty_detailsCountAggregateInputType = {
    id?: true
    dirty_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    user_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
    is_cancel?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Dirty_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dirty_details to aggregate.
     */
    where?: dirty_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dirty_details to fetch.
     */
    orderBy?: dirty_detailsOrderByWithRelationInput | dirty_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dirty_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dirty_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dirty_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dirty_details
    **/
    _count?: true | Dirty_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Dirty_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Dirty_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dirty_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dirty_detailsMaxAggregateInputType
  }

  export type GetDirty_detailsAggregateType<T extends Dirty_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateDirty_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirty_details[P]>
      : GetScalarType<T[P], AggregateDirty_details[P]>
  }




  export type dirty_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dirty_detailsWhereInput
    orderBy?: dirty_detailsOrderByWithAggregationInput | dirty_detailsOrderByWithAggregationInput[]
    by: Dirty_detailsScalarFieldEnum[] | Dirty_detailsScalarFieldEnum
    having?: dirty_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dirty_detailsCountAggregateInputType | true
    _avg?: Dirty_detailsAvgAggregateInputType
    _sum?: Dirty_detailsSumAggregateInputType
    _min?: Dirty_detailsMinAggregateInputType
    _max?: Dirty_detailsMaxAggregateInputType
  }

  export type Dirty_detailsGroupByOutputType = {
    id: number
    dirty_id: number
    department_id: number
    item_id: number
    unit_id: number
    user_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    status: boolean
    create_at: Date
    update_at: Date
    _count: Dirty_detailsCountAggregateOutputType | null
    _avg: Dirty_detailsAvgAggregateOutputType | null
    _sum: Dirty_detailsSumAggregateOutputType | null
    _min: Dirty_detailsMinAggregateOutputType | null
    _max: Dirty_detailsMaxAggregateOutputType | null
  }

  type GetDirty_detailsGroupByPayload<T extends dirty_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dirty_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dirty_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dirty_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Dirty_detailsGroupByOutputType[P]>
        }
      >
    >


  export type dirty_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dirty_id?: boolean
    department_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    user_id?: boolean
    qty?: boolean
    receive_qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["dirty_details"]>



  export type dirty_detailsSelectScalar = {
    id?: boolean
    dirty_id?: boolean
    department_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    user_id?: boolean
    qty?: boolean
    receive_qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type dirty_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dirty_id" | "department_id" | "item_id" | "unit_id" | "user_id" | "qty" | "receive_qty" | "weight" | "is_cancel" | "status" | "create_at" | "update_at", ExtArgs["result"]["dirty_details"]>

  export type $dirty_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dirty_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dirty_id: number
      department_id: number
      item_id: number
      unit_id: number
      user_id: number
      qty: number
      receive_qty: number
      weight: number
      is_cancel: boolean
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["dirty_details"]>
    composites: {}
  }

  type dirty_detailsGetPayload<S extends boolean | null | undefined | dirty_detailsDefaultArgs> = $Result.GetResult<Prisma.$dirty_detailsPayload, S>

  type dirty_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<dirty_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Dirty_detailsCountAggregateInputType | true
    }

  export interface dirty_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dirty_details'], meta: { name: 'dirty_details' } }
    /**
     * Find zero or one Dirty_details that matches the filter.
     * @param {dirty_detailsFindUniqueArgs} args - Arguments to find a Dirty_details
     * @example
     * // Get one Dirty_details
     * const dirty_details = await prisma.dirty_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dirty_detailsFindUniqueArgs>(args: SelectSubset<T, dirty_detailsFindUniqueArgs<ExtArgs>>): Prisma__dirty_detailsClient<$Result.GetResult<Prisma.$dirty_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dirty_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {dirty_detailsFindUniqueOrThrowArgs} args - Arguments to find a Dirty_details
     * @example
     * // Get one Dirty_details
     * const dirty_details = await prisma.dirty_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dirty_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, dirty_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dirty_detailsClient<$Result.GetResult<Prisma.$dirty_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dirty_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirty_detailsFindFirstArgs} args - Arguments to find a Dirty_details
     * @example
     * // Get one Dirty_details
     * const dirty_details = await prisma.dirty_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dirty_detailsFindFirstArgs>(args?: SelectSubset<T, dirty_detailsFindFirstArgs<ExtArgs>>): Prisma__dirty_detailsClient<$Result.GetResult<Prisma.$dirty_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dirty_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirty_detailsFindFirstOrThrowArgs} args - Arguments to find a Dirty_details
     * @example
     * // Get one Dirty_details
     * const dirty_details = await prisma.dirty_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dirty_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, dirty_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__dirty_detailsClient<$Result.GetResult<Prisma.$dirty_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dirty_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirty_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dirty_details
     * const dirty_details = await prisma.dirty_details.findMany()
     * 
     * // Get first 10 Dirty_details
     * const dirty_details = await prisma.dirty_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dirty_detailsWithIdOnly = await prisma.dirty_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dirty_detailsFindManyArgs>(args?: SelectSubset<T, dirty_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dirty_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dirty_details.
     * @param {dirty_detailsCreateArgs} args - Arguments to create a Dirty_details.
     * @example
     * // Create one Dirty_details
     * const Dirty_details = await prisma.dirty_details.create({
     *   data: {
     *     // ... data to create a Dirty_details
     *   }
     * })
     * 
     */
    create<T extends dirty_detailsCreateArgs>(args: SelectSubset<T, dirty_detailsCreateArgs<ExtArgs>>): Prisma__dirty_detailsClient<$Result.GetResult<Prisma.$dirty_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dirty_details.
     * @param {dirty_detailsCreateManyArgs} args - Arguments to create many Dirty_details.
     * @example
     * // Create many Dirty_details
     * const dirty_details = await prisma.dirty_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dirty_detailsCreateManyArgs>(args?: SelectSubset<T, dirty_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dirty_details.
     * @param {dirty_detailsDeleteArgs} args - Arguments to delete one Dirty_details.
     * @example
     * // Delete one Dirty_details
     * const Dirty_details = await prisma.dirty_details.delete({
     *   where: {
     *     // ... filter to delete one Dirty_details
     *   }
     * })
     * 
     */
    delete<T extends dirty_detailsDeleteArgs>(args: SelectSubset<T, dirty_detailsDeleteArgs<ExtArgs>>): Prisma__dirty_detailsClient<$Result.GetResult<Prisma.$dirty_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dirty_details.
     * @param {dirty_detailsUpdateArgs} args - Arguments to update one Dirty_details.
     * @example
     * // Update one Dirty_details
     * const dirty_details = await prisma.dirty_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dirty_detailsUpdateArgs>(args: SelectSubset<T, dirty_detailsUpdateArgs<ExtArgs>>): Prisma__dirty_detailsClient<$Result.GetResult<Prisma.$dirty_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dirty_details.
     * @param {dirty_detailsDeleteManyArgs} args - Arguments to filter Dirty_details to delete.
     * @example
     * // Delete a few Dirty_details
     * const { count } = await prisma.dirty_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dirty_detailsDeleteManyArgs>(args?: SelectSubset<T, dirty_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dirty_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirty_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dirty_details
     * const dirty_details = await prisma.dirty_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dirty_detailsUpdateManyArgs>(args: SelectSubset<T, dirty_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dirty_details.
     * @param {dirty_detailsUpsertArgs} args - Arguments to update or create a Dirty_details.
     * @example
     * // Update or create a Dirty_details
     * const dirty_details = await prisma.dirty_details.upsert({
     *   create: {
     *     // ... data to create a Dirty_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dirty_details we want to update
     *   }
     * })
     */
    upsert<T extends dirty_detailsUpsertArgs>(args: SelectSubset<T, dirty_detailsUpsertArgs<ExtArgs>>): Prisma__dirty_detailsClient<$Result.GetResult<Prisma.$dirty_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dirty_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirty_detailsCountArgs} args - Arguments to filter Dirty_details to count.
     * @example
     * // Count the number of Dirty_details
     * const count = await prisma.dirty_details.count({
     *   where: {
     *     // ... the filter for the Dirty_details we want to count
     *   }
     * })
    **/
    count<T extends dirty_detailsCountArgs>(
      args?: Subset<T, dirty_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dirty_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dirty_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dirty_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dirty_detailsAggregateArgs>(args: Subset<T, Dirty_detailsAggregateArgs>): Prisma.PrismaPromise<GetDirty_detailsAggregateType<T>>

    /**
     * Group by Dirty_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dirty_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dirty_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dirty_detailsGroupByArgs['orderBy'] }
        : { orderBy?: dirty_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dirty_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirty_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dirty_details model
   */
  readonly fields: dirty_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dirty_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dirty_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dirty_details model
   */
  interface dirty_detailsFieldRefs {
    readonly id: FieldRef<"dirty_details", 'Int'>
    readonly dirty_id: FieldRef<"dirty_details", 'Int'>
    readonly department_id: FieldRef<"dirty_details", 'Int'>
    readonly item_id: FieldRef<"dirty_details", 'Int'>
    readonly unit_id: FieldRef<"dirty_details", 'Int'>
    readonly user_id: FieldRef<"dirty_details", 'Int'>
    readonly qty: FieldRef<"dirty_details", 'Float'>
    readonly receive_qty: FieldRef<"dirty_details", 'Float'>
    readonly weight: FieldRef<"dirty_details", 'Float'>
    readonly is_cancel: FieldRef<"dirty_details", 'Boolean'>
    readonly status: FieldRef<"dirty_details", 'Boolean'>
    readonly create_at: FieldRef<"dirty_details", 'DateTime'>
    readonly update_at: FieldRef<"dirty_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dirty_details findUnique
   */
  export type dirty_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
    /**
     * Filter, which dirty_details to fetch.
     */
    where: dirty_detailsWhereUniqueInput
  }

  /**
   * dirty_details findUniqueOrThrow
   */
  export type dirty_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
    /**
     * Filter, which dirty_details to fetch.
     */
    where: dirty_detailsWhereUniqueInput
  }

  /**
   * dirty_details findFirst
   */
  export type dirty_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
    /**
     * Filter, which dirty_details to fetch.
     */
    where?: dirty_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dirty_details to fetch.
     */
    orderBy?: dirty_detailsOrderByWithRelationInput | dirty_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dirty_details.
     */
    cursor?: dirty_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dirty_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dirty_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dirty_details.
     */
    distinct?: Dirty_detailsScalarFieldEnum | Dirty_detailsScalarFieldEnum[]
  }

  /**
   * dirty_details findFirstOrThrow
   */
  export type dirty_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
    /**
     * Filter, which dirty_details to fetch.
     */
    where?: dirty_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dirty_details to fetch.
     */
    orderBy?: dirty_detailsOrderByWithRelationInput | dirty_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dirty_details.
     */
    cursor?: dirty_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dirty_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dirty_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dirty_details.
     */
    distinct?: Dirty_detailsScalarFieldEnum | Dirty_detailsScalarFieldEnum[]
  }

  /**
   * dirty_details findMany
   */
  export type dirty_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
    /**
     * Filter, which dirty_details to fetch.
     */
    where?: dirty_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dirty_details to fetch.
     */
    orderBy?: dirty_detailsOrderByWithRelationInput | dirty_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dirty_details.
     */
    cursor?: dirty_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dirty_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dirty_details.
     */
    skip?: number
    distinct?: Dirty_detailsScalarFieldEnum | Dirty_detailsScalarFieldEnum[]
  }

  /**
   * dirty_details create
   */
  export type dirty_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
    /**
     * The data needed to create a dirty_details.
     */
    data: XOR<dirty_detailsCreateInput, dirty_detailsUncheckedCreateInput>
  }

  /**
   * dirty_details createMany
   */
  export type dirty_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dirty_details.
     */
    data: dirty_detailsCreateManyInput | dirty_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dirty_details update
   */
  export type dirty_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
    /**
     * The data needed to update a dirty_details.
     */
    data: XOR<dirty_detailsUpdateInput, dirty_detailsUncheckedUpdateInput>
    /**
     * Choose, which dirty_details to update.
     */
    where: dirty_detailsWhereUniqueInput
  }

  /**
   * dirty_details updateMany
   */
  export type dirty_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dirty_details.
     */
    data: XOR<dirty_detailsUpdateManyMutationInput, dirty_detailsUncheckedUpdateManyInput>
    /**
     * Filter which dirty_details to update
     */
    where?: dirty_detailsWhereInput
    /**
     * Limit how many dirty_details to update.
     */
    limit?: number
  }

  /**
   * dirty_details upsert
   */
  export type dirty_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
    /**
     * The filter to search for the dirty_details to update in case it exists.
     */
    where: dirty_detailsWhereUniqueInput
    /**
     * In case the dirty_details found by the `where` argument doesn't exist, create a new dirty_details with this data.
     */
    create: XOR<dirty_detailsCreateInput, dirty_detailsUncheckedCreateInput>
    /**
     * In case the dirty_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dirty_detailsUpdateInput, dirty_detailsUncheckedUpdateInput>
  }

  /**
   * dirty_details delete
   */
  export type dirty_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
    /**
     * Filter which dirty_details to delete.
     */
    where: dirty_detailsWhereUniqueInput
  }

  /**
   * dirty_details deleteMany
   */
  export type dirty_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dirty_details to delete
     */
    where?: dirty_detailsWhereInput
    /**
     * Limit how many dirty_details to delete.
     */
    limit?: number
  }

  /**
   * dirty_details without action
   */
  export type dirty_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dirty_details
     */
    select?: dirty_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dirty_details
     */
    omit?: dirty_detailsOmit<ExtArgs> | null
  }


  /**
   * Model customer_group_types
   */

  export type AggregateCustomer_group_types = {
    _count: Customer_group_typesCountAggregateOutputType | null
    _avg: Customer_group_typesAvgAggregateOutputType | null
    _sum: Customer_group_typesSumAggregateOutputType | null
    _min: Customer_group_typesMinAggregateOutputType | null
    _max: Customer_group_typesMaxAggregateOutputType | null
  }

  export type Customer_group_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Customer_group_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Customer_group_typesMinAggregateOutputType = {
    id: number | null
    level: string | null
    group: string | null
    type: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Customer_group_typesMaxAggregateOutputType = {
    id: number | null
    level: string | null
    group: string | null
    type: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Customer_group_typesCountAggregateOutputType = {
    id: number
    level: number
    group: number
    type: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Customer_group_typesAvgAggregateInputType = {
    id?: true
  }

  export type Customer_group_typesSumAggregateInputType = {
    id?: true
  }

  export type Customer_group_typesMinAggregateInputType = {
    id?: true
    level?: true
    group?: true
    type?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Customer_group_typesMaxAggregateInputType = {
    id?: true
    level?: true
    group?: true
    type?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Customer_group_typesCountAggregateInputType = {
    id?: true
    level?: true
    group?: true
    type?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Customer_group_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_group_types to aggregate.
     */
    where?: customer_group_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_group_types to fetch.
     */
    orderBy?: customer_group_typesOrderByWithRelationInput | customer_group_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customer_group_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_group_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_group_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customer_group_types
    **/
    _count?: true | Customer_group_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Customer_group_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Customer_group_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Customer_group_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Customer_group_typesMaxAggregateInputType
  }

  export type GetCustomer_group_typesAggregateType<T extends Customer_group_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer_group_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer_group_types[P]>
      : GetScalarType<T[P], AggregateCustomer_group_types[P]>
  }




  export type customer_group_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_group_typesWhereInput
    orderBy?: customer_group_typesOrderByWithAggregationInput | customer_group_typesOrderByWithAggregationInput[]
    by: Customer_group_typesScalarFieldEnum[] | Customer_group_typesScalarFieldEnum
    having?: customer_group_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Customer_group_typesCountAggregateInputType | true
    _avg?: Customer_group_typesAvgAggregateInputType
    _sum?: Customer_group_typesSumAggregateInputType
    _min?: Customer_group_typesMinAggregateInputType
    _max?: Customer_group_typesMaxAggregateInputType
  }

  export type Customer_group_typesGroupByOutputType = {
    id: number
    level: string
    group: string
    type: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Customer_group_typesCountAggregateOutputType | null
    _avg: Customer_group_typesAvgAggregateOutputType | null
    _sum: Customer_group_typesSumAggregateOutputType | null
    _min: Customer_group_typesMinAggregateOutputType | null
    _max: Customer_group_typesMaxAggregateOutputType | null
  }

  type GetCustomer_group_typesGroupByPayload<T extends customer_group_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Customer_group_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Customer_group_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Customer_group_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Customer_group_typesGroupByOutputType[P]>
        }
      >
    >


  export type customer_group_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    group?: boolean
    type?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["customer_group_types"]>



  export type customer_group_typesSelectScalar = {
    id?: boolean
    level?: boolean
    group?: boolean
    type?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type customer_group_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level" | "group" | "type" | "status" | "create_at" | "update_at", ExtArgs["result"]["customer_group_types"]>

  export type $customer_group_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer_group_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      level: string
      group: string
      type: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["customer_group_types"]>
    composites: {}
  }

  type customer_group_typesGetPayload<S extends boolean | null | undefined | customer_group_typesDefaultArgs> = $Result.GetResult<Prisma.$customer_group_typesPayload, S>

  type customer_group_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customer_group_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Customer_group_typesCountAggregateInputType | true
    }

  export interface customer_group_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer_group_types'], meta: { name: 'customer_group_types' } }
    /**
     * Find zero or one Customer_group_types that matches the filter.
     * @param {customer_group_typesFindUniqueArgs} args - Arguments to find a Customer_group_types
     * @example
     * // Get one Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customer_group_typesFindUniqueArgs>(args: SelectSubset<T, customer_group_typesFindUniqueArgs<ExtArgs>>): Prisma__customer_group_typesClient<$Result.GetResult<Prisma.$customer_group_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer_group_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customer_group_typesFindUniqueOrThrowArgs} args - Arguments to find a Customer_group_types
     * @example
     * // Get one Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customer_group_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, customer_group_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customer_group_typesClient<$Result.GetResult<Prisma.$customer_group_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_group_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_group_typesFindFirstArgs} args - Arguments to find a Customer_group_types
     * @example
     * // Get one Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customer_group_typesFindFirstArgs>(args?: SelectSubset<T, customer_group_typesFindFirstArgs<ExtArgs>>): Prisma__customer_group_typesClient<$Result.GetResult<Prisma.$customer_group_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_group_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_group_typesFindFirstOrThrowArgs} args - Arguments to find a Customer_group_types
     * @example
     * // Get one Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customer_group_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, customer_group_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__customer_group_typesClient<$Result.GetResult<Prisma.$customer_group_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customer_group_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_group_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.findMany()
     * 
     * // Get first 10 Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customer_group_typesWithIdOnly = await prisma.customer_group_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customer_group_typesFindManyArgs>(args?: SelectSubset<T, customer_group_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_group_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer_group_types.
     * @param {customer_group_typesCreateArgs} args - Arguments to create a Customer_group_types.
     * @example
     * // Create one Customer_group_types
     * const Customer_group_types = await prisma.customer_group_types.create({
     *   data: {
     *     // ... data to create a Customer_group_types
     *   }
     * })
     * 
     */
    create<T extends customer_group_typesCreateArgs>(args: SelectSubset<T, customer_group_typesCreateArgs<ExtArgs>>): Prisma__customer_group_typesClient<$Result.GetResult<Prisma.$customer_group_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customer_group_types.
     * @param {customer_group_typesCreateManyArgs} args - Arguments to create many Customer_group_types.
     * @example
     * // Create many Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customer_group_typesCreateManyArgs>(args?: SelectSubset<T, customer_group_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer_group_types.
     * @param {customer_group_typesDeleteArgs} args - Arguments to delete one Customer_group_types.
     * @example
     * // Delete one Customer_group_types
     * const Customer_group_types = await prisma.customer_group_types.delete({
     *   where: {
     *     // ... filter to delete one Customer_group_types
     *   }
     * })
     * 
     */
    delete<T extends customer_group_typesDeleteArgs>(args: SelectSubset<T, customer_group_typesDeleteArgs<ExtArgs>>): Prisma__customer_group_typesClient<$Result.GetResult<Prisma.$customer_group_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer_group_types.
     * @param {customer_group_typesUpdateArgs} args - Arguments to update one Customer_group_types.
     * @example
     * // Update one Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customer_group_typesUpdateArgs>(args: SelectSubset<T, customer_group_typesUpdateArgs<ExtArgs>>): Prisma__customer_group_typesClient<$Result.GetResult<Prisma.$customer_group_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customer_group_types.
     * @param {customer_group_typesDeleteManyArgs} args - Arguments to filter Customer_group_types to delete.
     * @example
     * // Delete a few Customer_group_types
     * const { count } = await prisma.customer_group_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customer_group_typesDeleteManyArgs>(args?: SelectSubset<T, customer_group_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customer_group_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_group_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customer_group_typesUpdateManyArgs>(args: SelectSubset<T, customer_group_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer_group_types.
     * @param {customer_group_typesUpsertArgs} args - Arguments to update or create a Customer_group_types.
     * @example
     * // Update or create a Customer_group_types
     * const customer_group_types = await prisma.customer_group_types.upsert({
     *   create: {
     *     // ... data to create a Customer_group_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer_group_types we want to update
     *   }
     * })
     */
    upsert<T extends customer_group_typesUpsertArgs>(args: SelectSubset<T, customer_group_typesUpsertArgs<ExtArgs>>): Prisma__customer_group_typesClient<$Result.GetResult<Prisma.$customer_group_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customer_group_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_group_typesCountArgs} args - Arguments to filter Customer_group_types to count.
     * @example
     * // Count the number of Customer_group_types
     * const count = await prisma.customer_group_types.count({
     *   where: {
     *     // ... the filter for the Customer_group_types we want to count
     *   }
     * })
    **/
    count<T extends customer_group_typesCountArgs>(
      args?: Subset<T, customer_group_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Customer_group_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer_group_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_group_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Customer_group_typesAggregateArgs>(args: Subset<T, Customer_group_typesAggregateArgs>): Prisma.PrismaPromise<GetCustomer_group_typesAggregateType<T>>

    /**
     * Group by Customer_group_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_group_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customer_group_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customer_group_typesGroupByArgs['orderBy'] }
        : { orderBy?: customer_group_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customer_group_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomer_group_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer_group_types model
   */
  readonly fields: customer_group_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer_group_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customer_group_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer_group_types model
   */
  interface customer_group_typesFieldRefs {
    readonly id: FieldRef<"customer_group_types", 'Int'>
    readonly level: FieldRef<"customer_group_types", 'String'>
    readonly group: FieldRef<"customer_group_types", 'String'>
    readonly type: FieldRef<"customer_group_types", 'String'>
    readonly status: FieldRef<"customer_group_types", 'Boolean'>
    readonly create_at: FieldRef<"customer_group_types", 'DateTime'>
    readonly update_at: FieldRef<"customer_group_types", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer_group_types findUnique
   */
  export type customer_group_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
    /**
     * Filter, which customer_group_types to fetch.
     */
    where: customer_group_typesWhereUniqueInput
  }

  /**
   * customer_group_types findUniqueOrThrow
   */
  export type customer_group_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
    /**
     * Filter, which customer_group_types to fetch.
     */
    where: customer_group_typesWhereUniqueInput
  }

  /**
   * customer_group_types findFirst
   */
  export type customer_group_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
    /**
     * Filter, which customer_group_types to fetch.
     */
    where?: customer_group_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_group_types to fetch.
     */
    orderBy?: customer_group_typesOrderByWithRelationInput | customer_group_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_group_types.
     */
    cursor?: customer_group_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_group_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_group_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_group_types.
     */
    distinct?: Customer_group_typesScalarFieldEnum | Customer_group_typesScalarFieldEnum[]
  }

  /**
   * customer_group_types findFirstOrThrow
   */
  export type customer_group_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
    /**
     * Filter, which customer_group_types to fetch.
     */
    where?: customer_group_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_group_types to fetch.
     */
    orderBy?: customer_group_typesOrderByWithRelationInput | customer_group_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_group_types.
     */
    cursor?: customer_group_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_group_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_group_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_group_types.
     */
    distinct?: Customer_group_typesScalarFieldEnum | Customer_group_typesScalarFieldEnum[]
  }

  /**
   * customer_group_types findMany
   */
  export type customer_group_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
    /**
     * Filter, which customer_group_types to fetch.
     */
    where?: customer_group_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_group_types to fetch.
     */
    orderBy?: customer_group_typesOrderByWithRelationInput | customer_group_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customer_group_types.
     */
    cursor?: customer_group_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_group_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_group_types.
     */
    skip?: number
    distinct?: Customer_group_typesScalarFieldEnum | Customer_group_typesScalarFieldEnum[]
  }

  /**
   * customer_group_types create
   */
  export type customer_group_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a customer_group_types.
     */
    data: XOR<customer_group_typesCreateInput, customer_group_typesUncheckedCreateInput>
  }

  /**
   * customer_group_types createMany
   */
  export type customer_group_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customer_group_types.
     */
    data: customer_group_typesCreateManyInput | customer_group_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer_group_types update
   */
  export type customer_group_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a customer_group_types.
     */
    data: XOR<customer_group_typesUpdateInput, customer_group_typesUncheckedUpdateInput>
    /**
     * Choose, which customer_group_types to update.
     */
    where: customer_group_typesWhereUniqueInput
  }

  /**
   * customer_group_types updateMany
   */
  export type customer_group_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customer_group_types.
     */
    data: XOR<customer_group_typesUpdateManyMutationInput, customer_group_typesUncheckedUpdateManyInput>
    /**
     * Filter which customer_group_types to update
     */
    where?: customer_group_typesWhereInput
    /**
     * Limit how many customer_group_types to update.
     */
    limit?: number
  }

  /**
   * customer_group_types upsert
   */
  export type customer_group_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the customer_group_types to update in case it exists.
     */
    where: customer_group_typesWhereUniqueInput
    /**
     * In case the customer_group_types found by the `where` argument doesn't exist, create a new customer_group_types with this data.
     */
    create: XOR<customer_group_typesCreateInput, customer_group_typesUncheckedCreateInput>
    /**
     * In case the customer_group_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customer_group_typesUpdateInput, customer_group_typesUncheckedUpdateInput>
  }

  /**
   * customer_group_types delete
   */
  export type customer_group_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
    /**
     * Filter which customer_group_types to delete.
     */
    where: customer_group_typesWhereUniqueInput
  }

  /**
   * customer_group_types deleteMany
   */
  export type customer_group_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_group_types to delete
     */
    where?: customer_group_typesWhereInput
    /**
     * Limit how many customer_group_types to delete.
     */
    limit?: number
  }

  /**
   * customer_group_types without action
   */
  export type customer_group_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_group_types
     */
    select?: customer_group_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_group_types
     */
    omit?: customer_group_typesOmit<ExtArgs> | null
  }


  /**
   * Model customer_groups
   */

  export type AggregateCustomer_groups = {
    _count: Customer_groupsCountAggregateOutputType | null
    _avg: Customer_groupsAvgAggregateOutputType | null
    _sum: Customer_groupsSumAggregateOutputType | null
    _min: Customer_groupsMinAggregateOutputType | null
    _max: Customer_groupsMaxAggregateOutputType | null
  }

  export type Customer_groupsAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    customer_group_type_id: number | null
  }

  export type Customer_groupsSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    customer_group_type_id: number | null
  }

  export type Customer_groupsMinAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    customer_group_type_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Customer_groupsMaxAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    customer_group_type_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Customer_groupsCountAggregateOutputType = {
    id: number
    sale_office_id: number
    customer_group_type_id: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Customer_groupsAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    customer_group_type_id?: true
  }

  export type Customer_groupsSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    customer_group_type_id?: true
  }

  export type Customer_groupsMinAggregateInputType = {
    id?: true
    sale_office_id?: true
    customer_group_type_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Customer_groupsMaxAggregateInputType = {
    id?: true
    sale_office_id?: true
    customer_group_type_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Customer_groupsCountAggregateInputType = {
    id?: true
    sale_office_id?: true
    customer_group_type_id?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Customer_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_groups to aggregate.
     */
    where?: customer_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_groups to fetch.
     */
    orderBy?: customer_groupsOrderByWithRelationInput | customer_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customer_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customer_groups
    **/
    _count?: true | Customer_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Customer_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Customer_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Customer_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Customer_groupsMaxAggregateInputType
  }

  export type GetCustomer_groupsAggregateType<T extends Customer_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer_groups[P]>
      : GetScalarType<T[P], AggregateCustomer_groups[P]>
  }




  export type customer_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customer_groupsWhereInput
    orderBy?: customer_groupsOrderByWithAggregationInput | customer_groupsOrderByWithAggregationInput[]
    by: Customer_groupsScalarFieldEnum[] | Customer_groupsScalarFieldEnum
    having?: customer_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Customer_groupsCountAggregateInputType | true
    _avg?: Customer_groupsAvgAggregateInputType
    _sum?: Customer_groupsSumAggregateInputType
    _min?: Customer_groupsMinAggregateInputType
    _max?: Customer_groupsMaxAggregateInputType
  }

  export type Customer_groupsGroupByOutputType = {
    id: number
    sale_office_id: number
    customer_group_type_id: number
    status: boolean
    create_at: Date
    update_at: Date
    _count: Customer_groupsCountAggregateOutputType | null
    _avg: Customer_groupsAvgAggregateOutputType | null
    _sum: Customer_groupsSumAggregateOutputType | null
    _min: Customer_groupsMinAggregateOutputType | null
    _max: Customer_groupsMaxAggregateOutputType | null
  }

  type GetCustomer_groupsGroupByPayload<T extends customer_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Customer_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Customer_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Customer_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Customer_groupsGroupByOutputType[P]>
        }
      >
    >


  export type customer_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_office_id?: boolean
    customer_group_type_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["customer_groups"]>



  export type customer_groupsSelectScalar = {
    id?: boolean
    sale_office_id?: boolean
    customer_group_type_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type customer_groupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_office_id" | "customer_group_type_id" | "status" | "create_at" | "update_at", ExtArgs["result"]["customer_groups"]>

  export type $customer_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer_groups"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_office_id: number
      customer_group_type_id: number
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["customer_groups"]>
    composites: {}
  }

  type customer_groupsGetPayload<S extends boolean | null | undefined | customer_groupsDefaultArgs> = $Result.GetResult<Prisma.$customer_groupsPayload, S>

  type customer_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customer_groupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Customer_groupsCountAggregateInputType | true
    }

  export interface customer_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer_groups'], meta: { name: 'customer_groups' } }
    /**
     * Find zero or one Customer_groups that matches the filter.
     * @param {customer_groupsFindUniqueArgs} args - Arguments to find a Customer_groups
     * @example
     * // Get one Customer_groups
     * const customer_groups = await prisma.customer_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customer_groupsFindUniqueArgs>(args: SelectSubset<T, customer_groupsFindUniqueArgs<ExtArgs>>): Prisma__customer_groupsClient<$Result.GetResult<Prisma.$customer_groupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer_groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customer_groupsFindUniqueOrThrowArgs} args - Arguments to find a Customer_groups
     * @example
     * // Get one Customer_groups
     * const customer_groups = await prisma.customer_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customer_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, customer_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customer_groupsClient<$Result.GetResult<Prisma.$customer_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_groupsFindFirstArgs} args - Arguments to find a Customer_groups
     * @example
     * // Get one Customer_groups
     * const customer_groups = await prisma.customer_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customer_groupsFindFirstArgs>(args?: SelectSubset<T, customer_groupsFindFirstArgs<ExtArgs>>): Prisma__customer_groupsClient<$Result.GetResult<Prisma.$customer_groupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_groupsFindFirstOrThrowArgs} args - Arguments to find a Customer_groups
     * @example
     * // Get one Customer_groups
     * const customer_groups = await prisma.customer_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customer_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, customer_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__customer_groupsClient<$Result.GetResult<Prisma.$customer_groupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customer_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customer_groups
     * const customer_groups = await prisma.customer_groups.findMany()
     * 
     * // Get first 10 Customer_groups
     * const customer_groups = await prisma.customer_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customer_groupsWithIdOnly = await prisma.customer_groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customer_groupsFindManyArgs>(args?: SelectSubset<T, customer_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customer_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer_groups.
     * @param {customer_groupsCreateArgs} args - Arguments to create a Customer_groups.
     * @example
     * // Create one Customer_groups
     * const Customer_groups = await prisma.customer_groups.create({
     *   data: {
     *     // ... data to create a Customer_groups
     *   }
     * })
     * 
     */
    create<T extends customer_groupsCreateArgs>(args: SelectSubset<T, customer_groupsCreateArgs<ExtArgs>>): Prisma__customer_groupsClient<$Result.GetResult<Prisma.$customer_groupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customer_groups.
     * @param {customer_groupsCreateManyArgs} args - Arguments to create many Customer_groups.
     * @example
     * // Create many Customer_groups
     * const customer_groups = await prisma.customer_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customer_groupsCreateManyArgs>(args?: SelectSubset<T, customer_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer_groups.
     * @param {customer_groupsDeleteArgs} args - Arguments to delete one Customer_groups.
     * @example
     * // Delete one Customer_groups
     * const Customer_groups = await prisma.customer_groups.delete({
     *   where: {
     *     // ... filter to delete one Customer_groups
     *   }
     * })
     * 
     */
    delete<T extends customer_groupsDeleteArgs>(args: SelectSubset<T, customer_groupsDeleteArgs<ExtArgs>>): Prisma__customer_groupsClient<$Result.GetResult<Prisma.$customer_groupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer_groups.
     * @param {customer_groupsUpdateArgs} args - Arguments to update one Customer_groups.
     * @example
     * // Update one Customer_groups
     * const customer_groups = await prisma.customer_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customer_groupsUpdateArgs>(args: SelectSubset<T, customer_groupsUpdateArgs<ExtArgs>>): Prisma__customer_groupsClient<$Result.GetResult<Prisma.$customer_groupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customer_groups.
     * @param {customer_groupsDeleteManyArgs} args - Arguments to filter Customer_groups to delete.
     * @example
     * // Delete a few Customer_groups
     * const { count } = await prisma.customer_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customer_groupsDeleteManyArgs>(args?: SelectSubset<T, customer_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customer_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customer_groups
     * const customer_groups = await prisma.customer_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customer_groupsUpdateManyArgs>(args: SelectSubset<T, customer_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer_groups.
     * @param {customer_groupsUpsertArgs} args - Arguments to update or create a Customer_groups.
     * @example
     * // Update or create a Customer_groups
     * const customer_groups = await prisma.customer_groups.upsert({
     *   create: {
     *     // ... data to create a Customer_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer_groups we want to update
     *   }
     * })
     */
    upsert<T extends customer_groupsUpsertArgs>(args: SelectSubset<T, customer_groupsUpsertArgs<ExtArgs>>): Prisma__customer_groupsClient<$Result.GetResult<Prisma.$customer_groupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customer_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_groupsCountArgs} args - Arguments to filter Customer_groups to count.
     * @example
     * // Count the number of Customer_groups
     * const count = await prisma.customer_groups.count({
     *   where: {
     *     // ... the filter for the Customer_groups we want to count
     *   }
     * })
    **/
    count<T extends customer_groupsCountArgs>(
      args?: Subset<T, customer_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Customer_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Customer_groupsAggregateArgs>(args: Subset<T, Customer_groupsAggregateArgs>): Prisma.PrismaPromise<GetCustomer_groupsAggregateType<T>>

    /**
     * Group by Customer_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customer_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customer_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customer_groupsGroupByArgs['orderBy'] }
        : { orderBy?: customer_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customer_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomer_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer_groups model
   */
  readonly fields: customer_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customer_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer_groups model
   */
  interface customer_groupsFieldRefs {
    readonly id: FieldRef<"customer_groups", 'Int'>
    readonly sale_office_id: FieldRef<"customer_groups", 'Int'>
    readonly customer_group_type_id: FieldRef<"customer_groups", 'Int'>
    readonly status: FieldRef<"customer_groups", 'Boolean'>
    readonly create_at: FieldRef<"customer_groups", 'DateTime'>
    readonly update_at: FieldRef<"customer_groups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer_groups findUnique
   */
  export type customer_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
    /**
     * Filter, which customer_groups to fetch.
     */
    where: customer_groupsWhereUniqueInput
  }

  /**
   * customer_groups findUniqueOrThrow
   */
  export type customer_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
    /**
     * Filter, which customer_groups to fetch.
     */
    where: customer_groupsWhereUniqueInput
  }

  /**
   * customer_groups findFirst
   */
  export type customer_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
    /**
     * Filter, which customer_groups to fetch.
     */
    where?: customer_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_groups to fetch.
     */
    orderBy?: customer_groupsOrderByWithRelationInput | customer_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_groups.
     */
    cursor?: customer_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_groups.
     */
    distinct?: Customer_groupsScalarFieldEnum | Customer_groupsScalarFieldEnum[]
  }

  /**
   * customer_groups findFirstOrThrow
   */
  export type customer_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
    /**
     * Filter, which customer_groups to fetch.
     */
    where?: customer_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_groups to fetch.
     */
    orderBy?: customer_groupsOrderByWithRelationInput | customer_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customer_groups.
     */
    cursor?: customer_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customer_groups.
     */
    distinct?: Customer_groupsScalarFieldEnum | Customer_groupsScalarFieldEnum[]
  }

  /**
   * customer_groups findMany
   */
  export type customer_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
    /**
     * Filter, which customer_groups to fetch.
     */
    where?: customer_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customer_groups to fetch.
     */
    orderBy?: customer_groupsOrderByWithRelationInput | customer_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customer_groups.
     */
    cursor?: customer_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customer_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customer_groups.
     */
    skip?: number
    distinct?: Customer_groupsScalarFieldEnum | Customer_groupsScalarFieldEnum[]
  }

  /**
   * customer_groups create
   */
  export type customer_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
    /**
     * The data needed to create a customer_groups.
     */
    data: XOR<customer_groupsCreateInput, customer_groupsUncheckedCreateInput>
  }

  /**
   * customer_groups createMany
   */
  export type customer_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customer_groups.
     */
    data: customer_groupsCreateManyInput | customer_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer_groups update
   */
  export type customer_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
    /**
     * The data needed to update a customer_groups.
     */
    data: XOR<customer_groupsUpdateInput, customer_groupsUncheckedUpdateInput>
    /**
     * Choose, which customer_groups to update.
     */
    where: customer_groupsWhereUniqueInput
  }

  /**
   * customer_groups updateMany
   */
  export type customer_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customer_groups.
     */
    data: XOR<customer_groupsUpdateManyMutationInput, customer_groupsUncheckedUpdateManyInput>
    /**
     * Filter which customer_groups to update
     */
    where?: customer_groupsWhereInput
    /**
     * Limit how many customer_groups to update.
     */
    limit?: number
  }

  /**
   * customer_groups upsert
   */
  export type customer_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
    /**
     * The filter to search for the customer_groups to update in case it exists.
     */
    where: customer_groupsWhereUniqueInput
    /**
     * In case the customer_groups found by the `where` argument doesn't exist, create a new customer_groups with this data.
     */
    create: XOR<customer_groupsCreateInput, customer_groupsUncheckedCreateInput>
    /**
     * In case the customer_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customer_groupsUpdateInput, customer_groupsUncheckedUpdateInput>
  }

  /**
   * customer_groups delete
   */
  export type customer_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
    /**
     * Filter which customer_groups to delete.
     */
    where: customer_groupsWhereUniqueInput
  }

  /**
   * customer_groups deleteMany
   */
  export type customer_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer_groups to delete
     */
    where?: customer_groupsWhereInput
    /**
     * Limit how many customer_groups to delete.
     */
    limit?: number
  }

  /**
   * customer_groups without action
   */
  export type customer_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer_groups
     */
    select?: customer_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer_groups
     */
    omit?: customer_groupsOmit<ExtArgs> | null
  }


  /**
   * Model stock_locations
   */

  export type AggregateStock_locations = {
    _count: Stock_locationsCountAggregateOutputType | null
    _avg: Stock_locationsAvgAggregateOutputType | null
    _sum: Stock_locationsSumAggregateOutputType | null
    _min: Stock_locationsMinAggregateOutputType | null
    _max: Stock_locationsMaxAggregateOutputType | null
  }

  export type Stock_locationsAvgAggregateOutputType = {
    id: number | null
    department_id: number | null
    sale_office_id: number | null
    site_short_code: number | null
  }

  export type Stock_locationsSumAggregateOutputType = {
    id: number | null
    department_id: number | null
    sale_office_id: number | null
    site_short_code: number | null
  }

  export type Stock_locationsMinAggregateOutputType = {
    id: number | null
    department_id: number | null
    sale_office_id: number | null
    site_short_code: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Stock_locationsMaxAggregateOutputType = {
    id: number | null
    department_id: number | null
    sale_office_id: number | null
    site_short_code: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Stock_locationsCountAggregateOutputType = {
    id: number
    department_id: number
    sale_office_id: number
    site_short_code: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Stock_locationsAvgAggregateInputType = {
    id?: true
    department_id?: true
    sale_office_id?: true
    site_short_code?: true
  }

  export type Stock_locationsSumAggregateInputType = {
    id?: true
    department_id?: true
    sale_office_id?: true
    site_short_code?: true
  }

  export type Stock_locationsMinAggregateInputType = {
    id?: true
    department_id?: true
    sale_office_id?: true
    site_short_code?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Stock_locationsMaxAggregateInputType = {
    id?: true
    department_id?: true
    sale_office_id?: true
    site_short_code?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Stock_locationsCountAggregateInputType = {
    id?: true
    department_id?: true
    sale_office_id?: true
    site_short_code?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Stock_locationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stock_locations to aggregate.
     */
    where?: stock_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stock_locations to fetch.
     */
    orderBy?: stock_locationsOrderByWithRelationInput | stock_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stock_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stock_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stock_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stock_locations
    **/
    _count?: true | Stock_locationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Stock_locationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Stock_locationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stock_locationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stock_locationsMaxAggregateInputType
  }

  export type GetStock_locationsAggregateType<T extends Stock_locationsAggregateArgs> = {
        [P in keyof T & keyof AggregateStock_locations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock_locations[P]>
      : GetScalarType<T[P], AggregateStock_locations[P]>
  }




  export type stock_locationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stock_locationsWhereInput
    orderBy?: stock_locationsOrderByWithAggregationInput | stock_locationsOrderByWithAggregationInput[]
    by: Stock_locationsScalarFieldEnum[] | Stock_locationsScalarFieldEnum
    having?: stock_locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stock_locationsCountAggregateInputType | true
    _avg?: Stock_locationsAvgAggregateInputType
    _sum?: Stock_locationsSumAggregateInputType
    _min?: Stock_locationsMinAggregateInputType
    _max?: Stock_locationsMaxAggregateInputType
  }

  export type Stock_locationsGroupByOutputType = {
    id: number
    department_id: number
    sale_office_id: number
    site_short_code: number
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Stock_locationsCountAggregateOutputType | null
    _avg: Stock_locationsAvgAggregateOutputType | null
    _sum: Stock_locationsSumAggregateOutputType | null
    _min: Stock_locationsMinAggregateOutputType | null
    _max: Stock_locationsMaxAggregateOutputType | null
  }

  type GetStock_locationsGroupByPayload<T extends stock_locationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Stock_locationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stock_locationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stock_locationsGroupByOutputType[P]>
            : GetScalarType<T[P], Stock_locationsGroupByOutputType[P]>
        }
      >
    >


  export type stock_locationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    department_id?: boolean
    sale_office_id?: boolean
    site_short_code?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["stock_locations"]>



  export type stock_locationsSelectScalar = {
    id?: boolean
    department_id?: boolean
    sale_office_id?: boolean
    site_short_code?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type stock_locationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "department_id" | "sale_office_id" | "site_short_code" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["stock_locations"]>

  export type $stock_locationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stock_locations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      department_id: number
      sale_office_id: number
      site_short_code: number
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["stock_locations"]>
    composites: {}
  }

  type stock_locationsGetPayload<S extends boolean | null | undefined | stock_locationsDefaultArgs> = $Result.GetResult<Prisma.$stock_locationsPayload, S>

  type stock_locationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<stock_locationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Stock_locationsCountAggregateInputType | true
    }

  export interface stock_locationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stock_locations'], meta: { name: 'stock_locations' } }
    /**
     * Find zero or one Stock_locations that matches the filter.
     * @param {stock_locationsFindUniqueArgs} args - Arguments to find a Stock_locations
     * @example
     * // Get one Stock_locations
     * const stock_locations = await prisma.stock_locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stock_locationsFindUniqueArgs>(args: SelectSubset<T, stock_locationsFindUniqueArgs<ExtArgs>>): Prisma__stock_locationsClient<$Result.GetResult<Prisma.$stock_locationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stock_locations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {stock_locationsFindUniqueOrThrowArgs} args - Arguments to find a Stock_locations
     * @example
     * // Get one Stock_locations
     * const stock_locations = await prisma.stock_locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stock_locationsFindUniqueOrThrowArgs>(args: SelectSubset<T, stock_locationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stock_locationsClient<$Result.GetResult<Prisma.$stock_locationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_locationsFindFirstArgs} args - Arguments to find a Stock_locations
     * @example
     * // Get one Stock_locations
     * const stock_locations = await prisma.stock_locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stock_locationsFindFirstArgs>(args?: SelectSubset<T, stock_locationsFindFirstArgs<ExtArgs>>): Prisma__stock_locationsClient<$Result.GetResult<Prisma.$stock_locationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stock_locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_locationsFindFirstOrThrowArgs} args - Arguments to find a Stock_locations
     * @example
     * // Get one Stock_locations
     * const stock_locations = await prisma.stock_locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stock_locationsFindFirstOrThrowArgs>(args?: SelectSubset<T, stock_locationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__stock_locationsClient<$Result.GetResult<Prisma.$stock_locationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stock_locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_locationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stock_locations
     * const stock_locations = await prisma.stock_locations.findMany()
     * 
     * // Get first 10 Stock_locations
     * const stock_locations = await prisma.stock_locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stock_locationsWithIdOnly = await prisma.stock_locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends stock_locationsFindManyArgs>(args?: SelectSubset<T, stock_locationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stock_locationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stock_locations.
     * @param {stock_locationsCreateArgs} args - Arguments to create a Stock_locations.
     * @example
     * // Create one Stock_locations
     * const Stock_locations = await prisma.stock_locations.create({
     *   data: {
     *     // ... data to create a Stock_locations
     *   }
     * })
     * 
     */
    create<T extends stock_locationsCreateArgs>(args: SelectSubset<T, stock_locationsCreateArgs<ExtArgs>>): Prisma__stock_locationsClient<$Result.GetResult<Prisma.$stock_locationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stock_locations.
     * @param {stock_locationsCreateManyArgs} args - Arguments to create many Stock_locations.
     * @example
     * // Create many Stock_locations
     * const stock_locations = await prisma.stock_locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stock_locationsCreateManyArgs>(args?: SelectSubset<T, stock_locationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stock_locations.
     * @param {stock_locationsDeleteArgs} args - Arguments to delete one Stock_locations.
     * @example
     * // Delete one Stock_locations
     * const Stock_locations = await prisma.stock_locations.delete({
     *   where: {
     *     // ... filter to delete one Stock_locations
     *   }
     * })
     * 
     */
    delete<T extends stock_locationsDeleteArgs>(args: SelectSubset<T, stock_locationsDeleteArgs<ExtArgs>>): Prisma__stock_locationsClient<$Result.GetResult<Prisma.$stock_locationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stock_locations.
     * @param {stock_locationsUpdateArgs} args - Arguments to update one Stock_locations.
     * @example
     * // Update one Stock_locations
     * const stock_locations = await prisma.stock_locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stock_locationsUpdateArgs>(args: SelectSubset<T, stock_locationsUpdateArgs<ExtArgs>>): Prisma__stock_locationsClient<$Result.GetResult<Prisma.$stock_locationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stock_locations.
     * @param {stock_locationsDeleteManyArgs} args - Arguments to filter Stock_locations to delete.
     * @example
     * // Delete a few Stock_locations
     * const { count } = await prisma.stock_locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stock_locationsDeleteManyArgs>(args?: SelectSubset<T, stock_locationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stock_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stock_locations
     * const stock_locations = await prisma.stock_locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stock_locationsUpdateManyArgs>(args: SelectSubset<T, stock_locationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stock_locations.
     * @param {stock_locationsUpsertArgs} args - Arguments to update or create a Stock_locations.
     * @example
     * // Update or create a Stock_locations
     * const stock_locations = await prisma.stock_locations.upsert({
     *   create: {
     *     // ... data to create a Stock_locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock_locations we want to update
     *   }
     * })
     */
    upsert<T extends stock_locationsUpsertArgs>(args: SelectSubset<T, stock_locationsUpsertArgs<ExtArgs>>): Prisma__stock_locationsClient<$Result.GetResult<Prisma.$stock_locationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stock_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_locationsCountArgs} args - Arguments to filter Stock_locations to count.
     * @example
     * // Count the number of Stock_locations
     * const count = await prisma.stock_locations.count({
     *   where: {
     *     // ... the filter for the Stock_locations we want to count
     *   }
     * })
    **/
    count<T extends stock_locationsCountArgs>(
      args?: Subset<T, stock_locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stock_locationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stock_locationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stock_locationsAggregateArgs>(args: Subset<T, Stock_locationsAggregateArgs>): Prisma.PrismaPromise<GetStock_locationsAggregateType<T>>

    /**
     * Group by Stock_locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stock_locationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stock_locationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stock_locationsGroupByArgs['orderBy'] }
        : { orderBy?: stock_locationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stock_locationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStock_locationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stock_locations model
   */
  readonly fields: stock_locationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stock_locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stock_locationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stock_locations model
   */
  interface stock_locationsFieldRefs {
    readonly id: FieldRef<"stock_locations", 'Int'>
    readonly department_id: FieldRef<"stock_locations", 'Int'>
    readonly sale_office_id: FieldRef<"stock_locations", 'Int'>
    readonly site_short_code: FieldRef<"stock_locations", 'Int'>
    readonly description: FieldRef<"stock_locations", 'String'>
    readonly status: FieldRef<"stock_locations", 'Boolean'>
    readonly create_at: FieldRef<"stock_locations", 'DateTime'>
    readonly update_at: FieldRef<"stock_locations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * stock_locations findUnique
   */
  export type stock_locationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
    /**
     * Filter, which stock_locations to fetch.
     */
    where: stock_locationsWhereUniqueInput
  }

  /**
   * stock_locations findUniqueOrThrow
   */
  export type stock_locationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
    /**
     * Filter, which stock_locations to fetch.
     */
    where: stock_locationsWhereUniqueInput
  }

  /**
   * stock_locations findFirst
   */
  export type stock_locationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
    /**
     * Filter, which stock_locations to fetch.
     */
    where?: stock_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stock_locations to fetch.
     */
    orderBy?: stock_locationsOrderByWithRelationInput | stock_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stock_locations.
     */
    cursor?: stock_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stock_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stock_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stock_locations.
     */
    distinct?: Stock_locationsScalarFieldEnum | Stock_locationsScalarFieldEnum[]
  }

  /**
   * stock_locations findFirstOrThrow
   */
  export type stock_locationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
    /**
     * Filter, which stock_locations to fetch.
     */
    where?: stock_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stock_locations to fetch.
     */
    orderBy?: stock_locationsOrderByWithRelationInput | stock_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stock_locations.
     */
    cursor?: stock_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stock_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stock_locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stock_locations.
     */
    distinct?: Stock_locationsScalarFieldEnum | Stock_locationsScalarFieldEnum[]
  }

  /**
   * stock_locations findMany
   */
  export type stock_locationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
    /**
     * Filter, which stock_locations to fetch.
     */
    where?: stock_locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stock_locations to fetch.
     */
    orderBy?: stock_locationsOrderByWithRelationInput | stock_locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stock_locations.
     */
    cursor?: stock_locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stock_locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stock_locations.
     */
    skip?: number
    distinct?: Stock_locationsScalarFieldEnum | Stock_locationsScalarFieldEnum[]
  }

  /**
   * stock_locations create
   */
  export type stock_locationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
    /**
     * The data needed to create a stock_locations.
     */
    data: XOR<stock_locationsCreateInput, stock_locationsUncheckedCreateInput>
  }

  /**
   * stock_locations createMany
   */
  export type stock_locationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stock_locations.
     */
    data: stock_locationsCreateManyInput | stock_locationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stock_locations update
   */
  export type stock_locationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
    /**
     * The data needed to update a stock_locations.
     */
    data: XOR<stock_locationsUpdateInput, stock_locationsUncheckedUpdateInput>
    /**
     * Choose, which stock_locations to update.
     */
    where: stock_locationsWhereUniqueInput
  }

  /**
   * stock_locations updateMany
   */
  export type stock_locationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stock_locations.
     */
    data: XOR<stock_locationsUpdateManyMutationInput, stock_locationsUncheckedUpdateManyInput>
    /**
     * Filter which stock_locations to update
     */
    where?: stock_locationsWhereInput
    /**
     * Limit how many stock_locations to update.
     */
    limit?: number
  }

  /**
   * stock_locations upsert
   */
  export type stock_locationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
    /**
     * The filter to search for the stock_locations to update in case it exists.
     */
    where: stock_locationsWhereUniqueInput
    /**
     * In case the stock_locations found by the `where` argument doesn't exist, create a new stock_locations with this data.
     */
    create: XOR<stock_locationsCreateInput, stock_locationsUncheckedCreateInput>
    /**
     * In case the stock_locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stock_locationsUpdateInput, stock_locationsUncheckedUpdateInput>
  }

  /**
   * stock_locations delete
   */
  export type stock_locationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
    /**
     * Filter which stock_locations to delete.
     */
    where: stock_locationsWhereUniqueInput
  }

  /**
   * stock_locations deleteMany
   */
  export type stock_locationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stock_locations to delete
     */
    where?: stock_locationsWhereInput
    /**
     * Limit how many stock_locations to delete.
     */
    limit?: number
  }

  /**
   * stock_locations without action
   */
  export type stock_locationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stock_locations
     */
    select?: stock_locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stock_locations
     */
    omit?: stock_locationsOmit<ExtArgs> | null
  }


  /**
   * Model shelfcounts
   */

  export type AggregateShelfcounts = {
    _count: ShelfcountsCountAggregateOutputType | null
    _avg: ShelfcountsAvgAggregateOutputType | null
    _sum: ShelfcountsSumAggregateOutputType | null
    _min: ShelfcountsMinAggregateOutputType | null
    _max: ShelfcountsMaxAggregateOutputType | null
  }

  export type ShelfcountsAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    doc_no: number | null
    department_id: number | null
    cancel_user_id: number | null
    site_short_code: number | null
  }

  export type ShelfcountsSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    doc_no: number | null
    department_id: number | null
    cancel_user_id: number | null
    site_short_code: number | null
  }

  export type ShelfcountsMinAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    doc_no: number | null
    doc_date: Date | null
    shelfcount_doc_no: string | null
    department_id: number | null
    is_request: boolean | null
    delivery_time: Date | null
    sc_time: Date | null
    is_mobile: boolean | null
    complete_user: string | null
    complete_date: Date | null
    cancel_user_id: number | null
    cancel_remark: string | null
    site_short_code: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type ShelfcountsMaxAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    doc_no: number | null
    doc_date: Date | null
    shelfcount_doc_no: string | null
    department_id: number | null
    is_request: boolean | null
    delivery_time: Date | null
    sc_time: Date | null
    is_mobile: boolean | null
    complete_user: string | null
    complete_date: Date | null
    cancel_user_id: number | null
    cancel_remark: string | null
    site_short_code: number | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type ShelfcountsCountAggregateOutputType = {
    id: number
    sale_office_id: number
    doc_no: number
    doc_date: number
    shelfcount_doc_no: number
    department_id: number
    is_request: number
    delivery_time: number
    sc_time: number
    is_mobile: number
    complete_user: number
    complete_date: number
    cancel_user_id: number
    cancel_remark: number
    site_short_code: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type ShelfcountsAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    doc_no?: true
    department_id?: true
    cancel_user_id?: true
    site_short_code?: true
  }

  export type ShelfcountsSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    doc_no?: true
    department_id?: true
    cancel_user_id?: true
    site_short_code?: true
  }

  export type ShelfcountsMinAggregateInputType = {
    id?: true
    sale_office_id?: true
    doc_no?: true
    doc_date?: true
    shelfcount_doc_no?: true
    department_id?: true
    is_request?: true
    delivery_time?: true
    sc_time?: true
    is_mobile?: true
    complete_user?: true
    complete_date?: true
    cancel_user_id?: true
    cancel_remark?: true
    site_short_code?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type ShelfcountsMaxAggregateInputType = {
    id?: true
    sale_office_id?: true
    doc_no?: true
    doc_date?: true
    shelfcount_doc_no?: true
    department_id?: true
    is_request?: true
    delivery_time?: true
    sc_time?: true
    is_mobile?: true
    complete_user?: true
    complete_date?: true
    cancel_user_id?: true
    cancel_remark?: true
    site_short_code?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type ShelfcountsCountAggregateInputType = {
    id?: true
    sale_office_id?: true
    doc_no?: true
    doc_date?: true
    shelfcount_doc_no?: true
    department_id?: true
    is_request?: true
    delivery_time?: true
    sc_time?: true
    is_mobile?: true
    complete_user?: true
    complete_date?: true
    cancel_user_id?: true
    cancel_remark?: true
    site_short_code?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type ShelfcountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shelfcounts to aggregate.
     */
    where?: shelfcountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shelfcounts to fetch.
     */
    orderBy?: shelfcountsOrderByWithRelationInput | shelfcountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shelfcountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shelfcounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shelfcounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shelfcounts
    **/
    _count?: true | ShelfcountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShelfcountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShelfcountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShelfcountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShelfcountsMaxAggregateInputType
  }

  export type GetShelfcountsAggregateType<T extends ShelfcountsAggregateArgs> = {
        [P in keyof T & keyof AggregateShelfcounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShelfcounts[P]>
      : GetScalarType<T[P], AggregateShelfcounts[P]>
  }




  export type shelfcountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shelfcountsWhereInput
    orderBy?: shelfcountsOrderByWithAggregationInput | shelfcountsOrderByWithAggregationInput[]
    by: ShelfcountsScalarFieldEnum[] | ShelfcountsScalarFieldEnum
    having?: shelfcountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShelfcountsCountAggregateInputType | true
    _avg?: ShelfcountsAvgAggregateInputType
    _sum?: ShelfcountsSumAggregateInputType
    _min?: ShelfcountsMinAggregateInputType
    _max?: ShelfcountsMaxAggregateInputType
  }

  export type ShelfcountsGroupByOutputType = {
    id: number
    sale_office_id: number
    doc_no: number
    doc_date: Date
    shelfcount_doc_no: string
    department_id: number
    is_request: boolean
    delivery_time: Date
    sc_time: Date
    is_mobile: boolean
    complete_user: string
    complete_date: Date
    cancel_user_id: number
    cancel_remark: string
    site_short_code: number
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: ShelfcountsCountAggregateOutputType | null
    _avg: ShelfcountsAvgAggregateOutputType | null
    _sum: ShelfcountsSumAggregateOutputType | null
    _min: ShelfcountsMinAggregateOutputType | null
    _max: ShelfcountsMaxAggregateOutputType | null
  }

  type GetShelfcountsGroupByPayload<T extends shelfcountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShelfcountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShelfcountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShelfcountsGroupByOutputType[P]>
            : GetScalarType<T[P], ShelfcountsGroupByOutputType[P]>
        }
      >
    >


  export type shelfcountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sale_office_id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    shelfcount_doc_no?: boolean
    department_id?: boolean
    is_request?: boolean
    delivery_time?: boolean
    sc_time?: boolean
    is_mobile?: boolean
    complete_user?: boolean
    complete_date?: boolean
    cancel_user_id?: boolean
    cancel_remark?: boolean
    site_short_code?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["shelfcounts"]>



  export type shelfcountsSelectScalar = {
    id?: boolean
    sale_office_id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    shelfcount_doc_no?: boolean
    department_id?: boolean
    is_request?: boolean
    delivery_time?: boolean
    sc_time?: boolean
    is_mobile?: boolean
    complete_user?: boolean
    complete_date?: boolean
    cancel_user_id?: boolean
    cancel_remark?: boolean
    site_short_code?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type shelfcountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sale_office_id" | "doc_no" | "doc_date" | "shelfcount_doc_no" | "department_id" | "is_request" | "delivery_time" | "sc_time" | "is_mobile" | "complete_user" | "complete_date" | "cancel_user_id" | "cancel_remark" | "site_short_code" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["shelfcounts"]>

  export type $shelfcountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "shelfcounts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sale_office_id: number
      doc_no: number
      doc_date: Date
      shelfcount_doc_no: string
      department_id: number
      is_request: boolean
      delivery_time: Date
      sc_time: Date
      is_mobile: boolean
      complete_user: string
      complete_date: Date
      cancel_user_id: number
      cancel_remark: string
      site_short_code: number
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["shelfcounts"]>
    composites: {}
  }

  type shelfcountsGetPayload<S extends boolean | null | undefined | shelfcountsDefaultArgs> = $Result.GetResult<Prisma.$shelfcountsPayload, S>

  type shelfcountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<shelfcountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShelfcountsCountAggregateInputType | true
    }

  export interface shelfcountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shelfcounts'], meta: { name: 'shelfcounts' } }
    /**
     * Find zero or one Shelfcounts that matches the filter.
     * @param {shelfcountsFindUniqueArgs} args - Arguments to find a Shelfcounts
     * @example
     * // Get one Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shelfcountsFindUniqueArgs>(args: SelectSubset<T, shelfcountsFindUniqueArgs<ExtArgs>>): Prisma__shelfcountsClient<$Result.GetResult<Prisma.$shelfcountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shelfcounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {shelfcountsFindUniqueOrThrowArgs} args - Arguments to find a Shelfcounts
     * @example
     * // Get one Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shelfcountsFindUniqueOrThrowArgs>(args: SelectSubset<T, shelfcountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shelfcountsClient<$Result.GetResult<Prisma.$shelfcountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shelfcounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcountsFindFirstArgs} args - Arguments to find a Shelfcounts
     * @example
     * // Get one Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shelfcountsFindFirstArgs>(args?: SelectSubset<T, shelfcountsFindFirstArgs<ExtArgs>>): Prisma__shelfcountsClient<$Result.GetResult<Prisma.$shelfcountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shelfcounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcountsFindFirstOrThrowArgs} args - Arguments to find a Shelfcounts
     * @example
     * // Get one Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shelfcountsFindFirstOrThrowArgs>(args?: SelectSubset<T, shelfcountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shelfcountsClient<$Result.GetResult<Prisma.$shelfcountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shelfcounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.findMany()
     * 
     * // Get first 10 Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shelfcountsWithIdOnly = await prisma.shelfcounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends shelfcountsFindManyArgs>(args?: SelectSubset<T, shelfcountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shelfcountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shelfcounts.
     * @param {shelfcountsCreateArgs} args - Arguments to create a Shelfcounts.
     * @example
     * // Create one Shelfcounts
     * const Shelfcounts = await prisma.shelfcounts.create({
     *   data: {
     *     // ... data to create a Shelfcounts
     *   }
     * })
     * 
     */
    create<T extends shelfcountsCreateArgs>(args: SelectSubset<T, shelfcountsCreateArgs<ExtArgs>>): Prisma__shelfcountsClient<$Result.GetResult<Prisma.$shelfcountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shelfcounts.
     * @param {shelfcountsCreateManyArgs} args - Arguments to create many Shelfcounts.
     * @example
     * // Create many Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shelfcountsCreateManyArgs>(args?: SelectSubset<T, shelfcountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shelfcounts.
     * @param {shelfcountsDeleteArgs} args - Arguments to delete one Shelfcounts.
     * @example
     * // Delete one Shelfcounts
     * const Shelfcounts = await prisma.shelfcounts.delete({
     *   where: {
     *     // ... filter to delete one Shelfcounts
     *   }
     * })
     * 
     */
    delete<T extends shelfcountsDeleteArgs>(args: SelectSubset<T, shelfcountsDeleteArgs<ExtArgs>>): Prisma__shelfcountsClient<$Result.GetResult<Prisma.$shelfcountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shelfcounts.
     * @param {shelfcountsUpdateArgs} args - Arguments to update one Shelfcounts.
     * @example
     * // Update one Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shelfcountsUpdateArgs>(args: SelectSubset<T, shelfcountsUpdateArgs<ExtArgs>>): Prisma__shelfcountsClient<$Result.GetResult<Prisma.$shelfcountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shelfcounts.
     * @param {shelfcountsDeleteManyArgs} args - Arguments to filter Shelfcounts to delete.
     * @example
     * // Delete a few Shelfcounts
     * const { count } = await prisma.shelfcounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shelfcountsDeleteManyArgs>(args?: SelectSubset<T, shelfcountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shelfcounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shelfcountsUpdateManyArgs>(args: SelectSubset<T, shelfcountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shelfcounts.
     * @param {shelfcountsUpsertArgs} args - Arguments to update or create a Shelfcounts.
     * @example
     * // Update or create a Shelfcounts
     * const shelfcounts = await prisma.shelfcounts.upsert({
     *   create: {
     *     // ... data to create a Shelfcounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shelfcounts we want to update
     *   }
     * })
     */
    upsert<T extends shelfcountsUpsertArgs>(args: SelectSubset<T, shelfcountsUpsertArgs<ExtArgs>>): Prisma__shelfcountsClient<$Result.GetResult<Prisma.$shelfcountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shelfcounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcountsCountArgs} args - Arguments to filter Shelfcounts to count.
     * @example
     * // Count the number of Shelfcounts
     * const count = await prisma.shelfcounts.count({
     *   where: {
     *     // ... the filter for the Shelfcounts we want to count
     *   }
     * })
    **/
    count<T extends shelfcountsCountArgs>(
      args?: Subset<T, shelfcountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShelfcountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shelfcounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShelfcountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShelfcountsAggregateArgs>(args: Subset<T, ShelfcountsAggregateArgs>): Prisma.PrismaPromise<GetShelfcountsAggregateType<T>>

    /**
     * Group by Shelfcounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shelfcountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shelfcountsGroupByArgs['orderBy'] }
        : { orderBy?: shelfcountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shelfcountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShelfcountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the shelfcounts model
   */
  readonly fields: shelfcountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for shelfcounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shelfcountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the shelfcounts model
   */
  interface shelfcountsFieldRefs {
    readonly id: FieldRef<"shelfcounts", 'Int'>
    readonly sale_office_id: FieldRef<"shelfcounts", 'Int'>
    readonly doc_no: FieldRef<"shelfcounts", 'Int'>
    readonly doc_date: FieldRef<"shelfcounts", 'DateTime'>
    readonly shelfcount_doc_no: FieldRef<"shelfcounts", 'String'>
    readonly department_id: FieldRef<"shelfcounts", 'Int'>
    readonly is_request: FieldRef<"shelfcounts", 'Boolean'>
    readonly delivery_time: FieldRef<"shelfcounts", 'DateTime'>
    readonly sc_time: FieldRef<"shelfcounts", 'DateTime'>
    readonly is_mobile: FieldRef<"shelfcounts", 'Boolean'>
    readonly complete_user: FieldRef<"shelfcounts", 'String'>
    readonly complete_date: FieldRef<"shelfcounts", 'DateTime'>
    readonly cancel_user_id: FieldRef<"shelfcounts", 'Int'>
    readonly cancel_remark: FieldRef<"shelfcounts", 'String'>
    readonly site_short_code: FieldRef<"shelfcounts", 'Int'>
    readonly description: FieldRef<"shelfcounts", 'String'>
    readonly status: FieldRef<"shelfcounts", 'Boolean'>
    readonly create_at: FieldRef<"shelfcounts", 'DateTime'>
    readonly update_at: FieldRef<"shelfcounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * shelfcounts findUnique
   */
  export type shelfcountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcounts to fetch.
     */
    where: shelfcountsWhereUniqueInput
  }

  /**
   * shelfcounts findUniqueOrThrow
   */
  export type shelfcountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcounts to fetch.
     */
    where: shelfcountsWhereUniqueInput
  }

  /**
   * shelfcounts findFirst
   */
  export type shelfcountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcounts to fetch.
     */
    where?: shelfcountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shelfcounts to fetch.
     */
    orderBy?: shelfcountsOrderByWithRelationInput | shelfcountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shelfcounts.
     */
    cursor?: shelfcountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shelfcounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shelfcounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shelfcounts.
     */
    distinct?: ShelfcountsScalarFieldEnum | ShelfcountsScalarFieldEnum[]
  }

  /**
   * shelfcounts findFirstOrThrow
   */
  export type shelfcountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcounts to fetch.
     */
    where?: shelfcountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shelfcounts to fetch.
     */
    orderBy?: shelfcountsOrderByWithRelationInput | shelfcountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shelfcounts.
     */
    cursor?: shelfcountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shelfcounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shelfcounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shelfcounts.
     */
    distinct?: ShelfcountsScalarFieldEnum | ShelfcountsScalarFieldEnum[]
  }

  /**
   * shelfcounts findMany
   */
  export type shelfcountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcounts to fetch.
     */
    where?: shelfcountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shelfcounts to fetch.
     */
    orderBy?: shelfcountsOrderByWithRelationInput | shelfcountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shelfcounts.
     */
    cursor?: shelfcountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shelfcounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shelfcounts.
     */
    skip?: number
    distinct?: ShelfcountsScalarFieldEnum | ShelfcountsScalarFieldEnum[]
  }

  /**
   * shelfcounts create
   */
  export type shelfcountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
    /**
     * The data needed to create a shelfcounts.
     */
    data: XOR<shelfcountsCreateInput, shelfcountsUncheckedCreateInput>
  }

  /**
   * shelfcounts createMany
   */
  export type shelfcountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shelfcounts.
     */
    data: shelfcountsCreateManyInput | shelfcountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * shelfcounts update
   */
  export type shelfcountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
    /**
     * The data needed to update a shelfcounts.
     */
    data: XOR<shelfcountsUpdateInput, shelfcountsUncheckedUpdateInput>
    /**
     * Choose, which shelfcounts to update.
     */
    where: shelfcountsWhereUniqueInput
  }

  /**
   * shelfcounts updateMany
   */
  export type shelfcountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shelfcounts.
     */
    data: XOR<shelfcountsUpdateManyMutationInput, shelfcountsUncheckedUpdateManyInput>
    /**
     * Filter which shelfcounts to update
     */
    where?: shelfcountsWhereInput
    /**
     * Limit how many shelfcounts to update.
     */
    limit?: number
  }

  /**
   * shelfcounts upsert
   */
  export type shelfcountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
    /**
     * The filter to search for the shelfcounts to update in case it exists.
     */
    where: shelfcountsWhereUniqueInput
    /**
     * In case the shelfcounts found by the `where` argument doesn't exist, create a new shelfcounts with this data.
     */
    create: XOR<shelfcountsCreateInput, shelfcountsUncheckedCreateInput>
    /**
     * In case the shelfcounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shelfcountsUpdateInput, shelfcountsUncheckedUpdateInput>
  }

  /**
   * shelfcounts delete
   */
  export type shelfcountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
    /**
     * Filter which shelfcounts to delete.
     */
    where: shelfcountsWhereUniqueInput
  }

  /**
   * shelfcounts deleteMany
   */
  export type shelfcountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shelfcounts to delete
     */
    where?: shelfcountsWhereInput
    /**
     * Limit how many shelfcounts to delete.
     */
    limit?: number
  }

  /**
   * shelfcounts without action
   */
  export type shelfcountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcounts
     */
    select?: shelfcountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcounts
     */
    omit?: shelfcountsOmit<ExtArgs> | null
  }


  /**
   * Model shelfcount_details
   */

  export type AggregateShelfcount_details = {
    _count: Shelfcount_detailsCountAggregateOutputType | null
    _avg: Shelfcount_detailsAvgAggregateOutputType | null
    _sum: Shelfcount_detailsSumAggregateOutputType | null
    _min: Shelfcount_detailsMinAggregateOutputType | null
    _max: Shelfcount_detailsMaxAggregateOutputType | null
  }

  export type Shelfcount_detailsAvgAggregateOutputType = {
    id: number | null
    shelfcount_id: number | null
    item_id: number | null
    unit_id: number | null
    par_qty: number | null
    cc_qty: number | null
    total_qty: number | null
    over_par: number | null
    short: number | null
    over: number | null
    weight: number | null
    price: number | null
    category_price: number | null
  }

  export type Shelfcount_detailsSumAggregateOutputType = {
    id: number | null
    shelfcount_id: number | null
    item_id: number | null
    unit_id: number | null
    par_qty: number | null
    cc_qty: number | null
    total_qty: number | null
    over_par: number | null
    short: number | null
    over: number | null
    weight: number | null
    price: number | null
    category_price: number | null
  }

  export type Shelfcount_detailsMinAggregateOutputType = {
    id: number | null
    shelfcount_id: number | null
    item_id: number | null
    unit_id: number | null
    par_qty: number | null
    cc_qty: number | null
    total_qty: number | null
    over_par: number | null
    short: number | null
    over: number | null
    weight: number | null
    price: number | null
    category_price: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Shelfcount_detailsMaxAggregateOutputType = {
    id: number | null
    shelfcount_id: number | null
    item_id: number | null
    unit_id: number | null
    par_qty: number | null
    cc_qty: number | null
    total_qty: number | null
    over_par: number | null
    short: number | null
    over: number | null
    weight: number | null
    price: number | null
    category_price: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Shelfcount_detailsCountAggregateOutputType = {
    id: number
    shelfcount_id: number
    item_id: number
    unit_id: number
    par_qty: number
    cc_qty: number
    total_qty: number
    over_par: number
    short: number
    over: number
    weight: number
    price: number
    category_price: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Shelfcount_detailsAvgAggregateInputType = {
    id?: true
    shelfcount_id?: true
    item_id?: true
    unit_id?: true
    par_qty?: true
    cc_qty?: true
    total_qty?: true
    over_par?: true
    short?: true
    over?: true
    weight?: true
    price?: true
    category_price?: true
  }

  export type Shelfcount_detailsSumAggregateInputType = {
    id?: true
    shelfcount_id?: true
    item_id?: true
    unit_id?: true
    par_qty?: true
    cc_qty?: true
    total_qty?: true
    over_par?: true
    short?: true
    over?: true
    weight?: true
    price?: true
    category_price?: true
  }

  export type Shelfcount_detailsMinAggregateInputType = {
    id?: true
    shelfcount_id?: true
    item_id?: true
    unit_id?: true
    par_qty?: true
    cc_qty?: true
    total_qty?: true
    over_par?: true
    short?: true
    over?: true
    weight?: true
    price?: true
    category_price?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Shelfcount_detailsMaxAggregateInputType = {
    id?: true
    shelfcount_id?: true
    item_id?: true
    unit_id?: true
    par_qty?: true
    cc_qty?: true
    total_qty?: true
    over_par?: true
    short?: true
    over?: true
    weight?: true
    price?: true
    category_price?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Shelfcount_detailsCountAggregateInputType = {
    id?: true
    shelfcount_id?: true
    item_id?: true
    unit_id?: true
    par_qty?: true
    cc_qty?: true
    total_qty?: true
    over_par?: true
    short?: true
    over?: true
    weight?: true
    price?: true
    category_price?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Shelfcount_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shelfcount_details to aggregate.
     */
    where?: shelfcount_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shelfcount_details to fetch.
     */
    orderBy?: shelfcount_detailsOrderByWithRelationInput | shelfcount_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shelfcount_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shelfcount_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shelfcount_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shelfcount_details
    **/
    _count?: true | Shelfcount_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Shelfcount_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Shelfcount_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shelfcount_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shelfcount_detailsMaxAggregateInputType
  }

  export type GetShelfcount_detailsAggregateType<T extends Shelfcount_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateShelfcount_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShelfcount_details[P]>
      : GetScalarType<T[P], AggregateShelfcount_details[P]>
  }




  export type shelfcount_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shelfcount_detailsWhereInput
    orderBy?: shelfcount_detailsOrderByWithAggregationInput | shelfcount_detailsOrderByWithAggregationInput[]
    by: Shelfcount_detailsScalarFieldEnum[] | Shelfcount_detailsScalarFieldEnum
    having?: shelfcount_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shelfcount_detailsCountAggregateInputType | true
    _avg?: Shelfcount_detailsAvgAggregateInputType
    _sum?: Shelfcount_detailsSumAggregateInputType
    _min?: Shelfcount_detailsMinAggregateInputType
    _max?: Shelfcount_detailsMaxAggregateInputType
  }

  export type Shelfcount_detailsGroupByOutputType = {
    id: number
    shelfcount_id: number
    item_id: number
    unit_id: number
    par_qty: number
    cc_qty: number
    total_qty: number
    over_par: number
    short: number
    over: number
    weight: number
    price: number
    category_price: number
    status: boolean
    create_at: Date
    update_at: Date
    _count: Shelfcount_detailsCountAggregateOutputType | null
    _avg: Shelfcount_detailsAvgAggregateOutputType | null
    _sum: Shelfcount_detailsSumAggregateOutputType | null
    _min: Shelfcount_detailsMinAggregateOutputType | null
    _max: Shelfcount_detailsMaxAggregateOutputType | null
  }

  type GetShelfcount_detailsGroupByPayload<T extends shelfcount_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Shelfcount_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shelfcount_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shelfcount_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Shelfcount_detailsGroupByOutputType[P]>
        }
      >
    >


  export type shelfcount_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shelfcount_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    par_qty?: boolean
    cc_qty?: boolean
    total_qty?: boolean
    over_par?: boolean
    short?: boolean
    over?: boolean
    weight?: boolean
    price?: boolean
    category_price?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["shelfcount_details"]>



  export type shelfcount_detailsSelectScalar = {
    id?: boolean
    shelfcount_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    par_qty?: boolean
    cc_qty?: boolean
    total_qty?: boolean
    over_par?: boolean
    short?: boolean
    over?: boolean
    weight?: boolean
    price?: boolean
    category_price?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type shelfcount_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shelfcount_id" | "item_id" | "unit_id" | "par_qty" | "cc_qty" | "total_qty" | "over_par" | "short" | "over" | "weight" | "price" | "category_price" | "status" | "create_at" | "update_at", ExtArgs["result"]["shelfcount_details"]>

  export type $shelfcount_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "shelfcount_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shelfcount_id: number
      item_id: number
      unit_id: number
      par_qty: number
      cc_qty: number
      total_qty: number
      over_par: number
      short: number
      over: number
      weight: number
      price: number
      category_price: number
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["shelfcount_details"]>
    composites: {}
  }

  type shelfcount_detailsGetPayload<S extends boolean | null | undefined | shelfcount_detailsDefaultArgs> = $Result.GetResult<Prisma.$shelfcount_detailsPayload, S>

  type shelfcount_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<shelfcount_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Shelfcount_detailsCountAggregateInputType | true
    }

  export interface shelfcount_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shelfcount_details'], meta: { name: 'shelfcount_details' } }
    /**
     * Find zero or one Shelfcount_details that matches the filter.
     * @param {shelfcount_detailsFindUniqueArgs} args - Arguments to find a Shelfcount_details
     * @example
     * // Get one Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shelfcount_detailsFindUniqueArgs>(args: SelectSubset<T, shelfcount_detailsFindUniqueArgs<ExtArgs>>): Prisma__shelfcount_detailsClient<$Result.GetResult<Prisma.$shelfcount_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shelfcount_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {shelfcount_detailsFindUniqueOrThrowArgs} args - Arguments to find a Shelfcount_details
     * @example
     * // Get one Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shelfcount_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, shelfcount_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shelfcount_detailsClient<$Result.GetResult<Prisma.$shelfcount_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shelfcount_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcount_detailsFindFirstArgs} args - Arguments to find a Shelfcount_details
     * @example
     * // Get one Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shelfcount_detailsFindFirstArgs>(args?: SelectSubset<T, shelfcount_detailsFindFirstArgs<ExtArgs>>): Prisma__shelfcount_detailsClient<$Result.GetResult<Prisma.$shelfcount_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shelfcount_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcount_detailsFindFirstOrThrowArgs} args - Arguments to find a Shelfcount_details
     * @example
     * // Get one Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shelfcount_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, shelfcount_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shelfcount_detailsClient<$Result.GetResult<Prisma.$shelfcount_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shelfcount_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcount_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.findMany()
     * 
     * // Get first 10 Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shelfcount_detailsWithIdOnly = await prisma.shelfcount_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends shelfcount_detailsFindManyArgs>(args?: SelectSubset<T, shelfcount_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shelfcount_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shelfcount_details.
     * @param {shelfcount_detailsCreateArgs} args - Arguments to create a Shelfcount_details.
     * @example
     * // Create one Shelfcount_details
     * const Shelfcount_details = await prisma.shelfcount_details.create({
     *   data: {
     *     // ... data to create a Shelfcount_details
     *   }
     * })
     * 
     */
    create<T extends shelfcount_detailsCreateArgs>(args: SelectSubset<T, shelfcount_detailsCreateArgs<ExtArgs>>): Prisma__shelfcount_detailsClient<$Result.GetResult<Prisma.$shelfcount_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shelfcount_details.
     * @param {shelfcount_detailsCreateManyArgs} args - Arguments to create many Shelfcount_details.
     * @example
     * // Create many Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shelfcount_detailsCreateManyArgs>(args?: SelectSubset<T, shelfcount_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shelfcount_details.
     * @param {shelfcount_detailsDeleteArgs} args - Arguments to delete one Shelfcount_details.
     * @example
     * // Delete one Shelfcount_details
     * const Shelfcount_details = await prisma.shelfcount_details.delete({
     *   where: {
     *     // ... filter to delete one Shelfcount_details
     *   }
     * })
     * 
     */
    delete<T extends shelfcount_detailsDeleteArgs>(args: SelectSubset<T, shelfcount_detailsDeleteArgs<ExtArgs>>): Prisma__shelfcount_detailsClient<$Result.GetResult<Prisma.$shelfcount_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shelfcount_details.
     * @param {shelfcount_detailsUpdateArgs} args - Arguments to update one Shelfcount_details.
     * @example
     * // Update one Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shelfcount_detailsUpdateArgs>(args: SelectSubset<T, shelfcount_detailsUpdateArgs<ExtArgs>>): Prisma__shelfcount_detailsClient<$Result.GetResult<Prisma.$shelfcount_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shelfcount_details.
     * @param {shelfcount_detailsDeleteManyArgs} args - Arguments to filter Shelfcount_details to delete.
     * @example
     * // Delete a few Shelfcount_details
     * const { count } = await prisma.shelfcount_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shelfcount_detailsDeleteManyArgs>(args?: SelectSubset<T, shelfcount_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shelfcount_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcount_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shelfcount_detailsUpdateManyArgs>(args: SelectSubset<T, shelfcount_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shelfcount_details.
     * @param {shelfcount_detailsUpsertArgs} args - Arguments to update or create a Shelfcount_details.
     * @example
     * // Update or create a Shelfcount_details
     * const shelfcount_details = await prisma.shelfcount_details.upsert({
     *   create: {
     *     // ... data to create a Shelfcount_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shelfcount_details we want to update
     *   }
     * })
     */
    upsert<T extends shelfcount_detailsUpsertArgs>(args: SelectSubset<T, shelfcount_detailsUpsertArgs<ExtArgs>>): Prisma__shelfcount_detailsClient<$Result.GetResult<Prisma.$shelfcount_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shelfcount_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcount_detailsCountArgs} args - Arguments to filter Shelfcount_details to count.
     * @example
     * // Count the number of Shelfcount_details
     * const count = await prisma.shelfcount_details.count({
     *   where: {
     *     // ... the filter for the Shelfcount_details we want to count
     *   }
     * })
    **/
    count<T extends shelfcount_detailsCountArgs>(
      args?: Subset<T, shelfcount_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shelfcount_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shelfcount_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shelfcount_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shelfcount_detailsAggregateArgs>(args: Subset<T, Shelfcount_detailsAggregateArgs>): Prisma.PrismaPromise<GetShelfcount_detailsAggregateType<T>>

    /**
     * Group by Shelfcount_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shelfcount_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shelfcount_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shelfcount_detailsGroupByArgs['orderBy'] }
        : { orderBy?: shelfcount_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shelfcount_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShelfcount_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the shelfcount_details model
   */
  readonly fields: shelfcount_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for shelfcount_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shelfcount_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the shelfcount_details model
   */
  interface shelfcount_detailsFieldRefs {
    readonly id: FieldRef<"shelfcount_details", 'Int'>
    readonly shelfcount_id: FieldRef<"shelfcount_details", 'Int'>
    readonly item_id: FieldRef<"shelfcount_details", 'Int'>
    readonly unit_id: FieldRef<"shelfcount_details", 'Int'>
    readonly par_qty: FieldRef<"shelfcount_details", 'Float'>
    readonly cc_qty: FieldRef<"shelfcount_details", 'Float'>
    readonly total_qty: FieldRef<"shelfcount_details", 'Float'>
    readonly over_par: FieldRef<"shelfcount_details", 'Float'>
    readonly short: FieldRef<"shelfcount_details", 'Float'>
    readonly over: FieldRef<"shelfcount_details", 'Float'>
    readonly weight: FieldRef<"shelfcount_details", 'Float'>
    readonly price: FieldRef<"shelfcount_details", 'Float'>
    readonly category_price: FieldRef<"shelfcount_details", 'Float'>
    readonly status: FieldRef<"shelfcount_details", 'Boolean'>
    readonly create_at: FieldRef<"shelfcount_details", 'DateTime'>
    readonly update_at: FieldRef<"shelfcount_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * shelfcount_details findUnique
   */
  export type shelfcount_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcount_details to fetch.
     */
    where: shelfcount_detailsWhereUniqueInput
  }

  /**
   * shelfcount_details findUniqueOrThrow
   */
  export type shelfcount_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcount_details to fetch.
     */
    where: shelfcount_detailsWhereUniqueInput
  }

  /**
   * shelfcount_details findFirst
   */
  export type shelfcount_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcount_details to fetch.
     */
    where?: shelfcount_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shelfcount_details to fetch.
     */
    orderBy?: shelfcount_detailsOrderByWithRelationInput | shelfcount_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shelfcount_details.
     */
    cursor?: shelfcount_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shelfcount_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shelfcount_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shelfcount_details.
     */
    distinct?: Shelfcount_detailsScalarFieldEnum | Shelfcount_detailsScalarFieldEnum[]
  }

  /**
   * shelfcount_details findFirstOrThrow
   */
  export type shelfcount_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcount_details to fetch.
     */
    where?: shelfcount_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shelfcount_details to fetch.
     */
    orderBy?: shelfcount_detailsOrderByWithRelationInput | shelfcount_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shelfcount_details.
     */
    cursor?: shelfcount_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shelfcount_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shelfcount_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shelfcount_details.
     */
    distinct?: Shelfcount_detailsScalarFieldEnum | Shelfcount_detailsScalarFieldEnum[]
  }

  /**
   * shelfcount_details findMany
   */
  export type shelfcount_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
    /**
     * Filter, which shelfcount_details to fetch.
     */
    where?: shelfcount_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shelfcount_details to fetch.
     */
    orderBy?: shelfcount_detailsOrderByWithRelationInput | shelfcount_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shelfcount_details.
     */
    cursor?: shelfcount_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shelfcount_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shelfcount_details.
     */
    skip?: number
    distinct?: Shelfcount_detailsScalarFieldEnum | Shelfcount_detailsScalarFieldEnum[]
  }

  /**
   * shelfcount_details create
   */
  export type shelfcount_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
    /**
     * The data needed to create a shelfcount_details.
     */
    data: XOR<shelfcount_detailsCreateInput, shelfcount_detailsUncheckedCreateInput>
  }

  /**
   * shelfcount_details createMany
   */
  export type shelfcount_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shelfcount_details.
     */
    data: shelfcount_detailsCreateManyInput | shelfcount_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * shelfcount_details update
   */
  export type shelfcount_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
    /**
     * The data needed to update a shelfcount_details.
     */
    data: XOR<shelfcount_detailsUpdateInput, shelfcount_detailsUncheckedUpdateInput>
    /**
     * Choose, which shelfcount_details to update.
     */
    where: shelfcount_detailsWhereUniqueInput
  }

  /**
   * shelfcount_details updateMany
   */
  export type shelfcount_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shelfcount_details.
     */
    data: XOR<shelfcount_detailsUpdateManyMutationInput, shelfcount_detailsUncheckedUpdateManyInput>
    /**
     * Filter which shelfcount_details to update
     */
    where?: shelfcount_detailsWhereInput
    /**
     * Limit how many shelfcount_details to update.
     */
    limit?: number
  }

  /**
   * shelfcount_details upsert
   */
  export type shelfcount_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
    /**
     * The filter to search for the shelfcount_details to update in case it exists.
     */
    where: shelfcount_detailsWhereUniqueInput
    /**
     * In case the shelfcount_details found by the `where` argument doesn't exist, create a new shelfcount_details with this data.
     */
    create: XOR<shelfcount_detailsCreateInput, shelfcount_detailsUncheckedCreateInput>
    /**
     * In case the shelfcount_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shelfcount_detailsUpdateInput, shelfcount_detailsUncheckedUpdateInput>
  }

  /**
   * shelfcount_details delete
   */
  export type shelfcount_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
    /**
     * Filter which shelfcount_details to delete.
     */
    where: shelfcount_detailsWhereUniqueInput
  }

  /**
   * shelfcount_details deleteMany
   */
  export type shelfcount_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shelfcount_details to delete
     */
    where?: shelfcount_detailsWhereInput
    /**
     * Limit how many shelfcount_details to delete.
     */
    limit?: number
  }

  /**
   * shelfcount_details without action
   */
  export type shelfcount_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shelfcount_details
     */
    select?: shelfcount_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shelfcount_details
     */
    omit?: shelfcount_detailsOmit<ExtArgs> | null
  }


  /**
   * Model damages
   */

  export type AggregateDamages = {
    _count: DamagesCountAggregateOutputType | null
    _avg: DamagesAvgAggregateOutputType | null
    _sum: DamagesSumAggregateOutputType | null
    _min: DamagesMinAggregateOutputType | null
    _max: DamagesMaxAggregateOutputType | null
  }

  export type DamagesAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    factory_id: number | null
  }

  export type DamagesSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    factory_id: number | null
  }

  export type DamagesMinAggregateOutputType = {
    id: number | null
    doc_no: string | null
    doc_date: Date | null
    ref_doc_no: string | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type DamagesMaxAggregateOutputType = {
    id: number | null
    doc_no: string | null
    doc_date: Date | null
    ref_doc_no: string | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type DamagesCountAggregateOutputType = {
    id: number
    doc_no: number
    doc_date: number
    ref_doc_no: number
    sale_office_id: number
    department_id: number
    total: number
    sign_factory: number
    sign_NH: number
    sign_factory_time: number
    sign_NH_time: number
    factory_id: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type DamagesAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    factory_id?: true
  }

  export type DamagesSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    factory_id?: true
  }

  export type DamagesMinAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type DamagesMaxAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type DamagesCountAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type DamagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which damages to aggregate.
     */
    where?: damagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damages to fetch.
     */
    orderBy?: damagesOrderByWithRelationInput | damagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: damagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned damages
    **/
    _count?: true | DamagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DamagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DamagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DamagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DamagesMaxAggregateInputType
  }

  export type GetDamagesAggregateType<T extends DamagesAggregateArgs> = {
        [P in keyof T & keyof AggregateDamages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDamages[P]>
      : GetScalarType<T[P], AggregateDamages[P]>
  }




  export type damagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: damagesWhereInput
    orderBy?: damagesOrderByWithAggregationInput | damagesOrderByWithAggregationInput[]
    by: DamagesScalarFieldEnum[] | DamagesScalarFieldEnum
    having?: damagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DamagesCountAggregateInputType | true
    _avg?: DamagesAvgAggregateInputType
    _sum?: DamagesSumAggregateInputType
    _min?: DamagesMinAggregateInputType
    _max?: DamagesMaxAggregateInputType
  }

  export type DamagesGroupByOutputType = {
    id: number
    doc_no: string
    doc_date: Date
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    total: number
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date
    sign_NH_time: Date
    factory_id: number
    status: boolean
    create_at: Date
    update_at: Date
    _count: DamagesCountAggregateOutputType | null
    _avg: DamagesAvgAggregateOutputType | null
    _sum: DamagesSumAggregateOutputType | null
    _min: DamagesMinAggregateOutputType | null
    _max: DamagesMaxAggregateOutputType | null
  }

  type GetDamagesGroupByPayload<T extends damagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DamagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DamagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DamagesGroupByOutputType[P]>
            : GetScalarType<T[P], DamagesGroupByOutputType[P]>
        }
      >
    >


  export type damagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    ref_doc_no?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    total?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["damages"]>



  export type damagesSelectScalar = {
    id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    ref_doc_no?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    total?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type damagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doc_no" | "doc_date" | "ref_doc_no" | "sale_office_id" | "department_id" | "total" | "sign_factory" | "sign_NH" | "sign_factory_time" | "sign_NH_time" | "factory_id" | "status" | "create_at" | "update_at", ExtArgs["result"]["damages"]>

  export type $damagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "damages"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doc_no: string
      doc_date: Date
      ref_doc_no: string
      sale_office_id: number
      department_id: number
      total: number
      sign_factory: string
      sign_NH: string
      sign_factory_time: Date
      sign_NH_time: Date
      factory_id: number
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["damages"]>
    composites: {}
  }

  type damagesGetPayload<S extends boolean | null | undefined | damagesDefaultArgs> = $Result.GetResult<Prisma.$damagesPayload, S>

  type damagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<damagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DamagesCountAggregateInputType | true
    }

  export interface damagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['damages'], meta: { name: 'damages' } }
    /**
     * Find zero or one Damages that matches the filter.
     * @param {damagesFindUniqueArgs} args - Arguments to find a Damages
     * @example
     * // Get one Damages
     * const damages = await prisma.damages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends damagesFindUniqueArgs>(args: SelectSubset<T, damagesFindUniqueArgs<ExtArgs>>): Prisma__damagesClient<$Result.GetResult<Prisma.$damagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Damages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {damagesFindUniqueOrThrowArgs} args - Arguments to find a Damages
     * @example
     * // Get one Damages
     * const damages = await prisma.damages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends damagesFindUniqueOrThrowArgs>(args: SelectSubset<T, damagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__damagesClient<$Result.GetResult<Prisma.$damagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Damages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damagesFindFirstArgs} args - Arguments to find a Damages
     * @example
     * // Get one Damages
     * const damages = await prisma.damages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends damagesFindFirstArgs>(args?: SelectSubset<T, damagesFindFirstArgs<ExtArgs>>): Prisma__damagesClient<$Result.GetResult<Prisma.$damagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Damages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damagesFindFirstOrThrowArgs} args - Arguments to find a Damages
     * @example
     * // Get one Damages
     * const damages = await prisma.damages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends damagesFindFirstOrThrowArgs>(args?: SelectSubset<T, damagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__damagesClient<$Result.GetResult<Prisma.$damagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Damages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Damages
     * const damages = await prisma.damages.findMany()
     * 
     * // Get first 10 Damages
     * const damages = await prisma.damages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const damagesWithIdOnly = await prisma.damages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends damagesFindManyArgs>(args?: SelectSubset<T, damagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$damagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Damages.
     * @param {damagesCreateArgs} args - Arguments to create a Damages.
     * @example
     * // Create one Damages
     * const Damages = await prisma.damages.create({
     *   data: {
     *     // ... data to create a Damages
     *   }
     * })
     * 
     */
    create<T extends damagesCreateArgs>(args: SelectSubset<T, damagesCreateArgs<ExtArgs>>): Prisma__damagesClient<$Result.GetResult<Prisma.$damagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Damages.
     * @param {damagesCreateManyArgs} args - Arguments to create many Damages.
     * @example
     * // Create many Damages
     * const damages = await prisma.damages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends damagesCreateManyArgs>(args?: SelectSubset<T, damagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Damages.
     * @param {damagesDeleteArgs} args - Arguments to delete one Damages.
     * @example
     * // Delete one Damages
     * const Damages = await prisma.damages.delete({
     *   where: {
     *     // ... filter to delete one Damages
     *   }
     * })
     * 
     */
    delete<T extends damagesDeleteArgs>(args: SelectSubset<T, damagesDeleteArgs<ExtArgs>>): Prisma__damagesClient<$Result.GetResult<Prisma.$damagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Damages.
     * @param {damagesUpdateArgs} args - Arguments to update one Damages.
     * @example
     * // Update one Damages
     * const damages = await prisma.damages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends damagesUpdateArgs>(args: SelectSubset<T, damagesUpdateArgs<ExtArgs>>): Prisma__damagesClient<$Result.GetResult<Prisma.$damagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Damages.
     * @param {damagesDeleteManyArgs} args - Arguments to filter Damages to delete.
     * @example
     * // Delete a few Damages
     * const { count } = await prisma.damages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends damagesDeleteManyArgs>(args?: SelectSubset<T, damagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Damages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Damages
     * const damages = await prisma.damages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends damagesUpdateManyArgs>(args: SelectSubset<T, damagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Damages.
     * @param {damagesUpsertArgs} args - Arguments to update or create a Damages.
     * @example
     * // Update or create a Damages
     * const damages = await prisma.damages.upsert({
     *   create: {
     *     // ... data to create a Damages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Damages we want to update
     *   }
     * })
     */
    upsert<T extends damagesUpsertArgs>(args: SelectSubset<T, damagesUpsertArgs<ExtArgs>>): Prisma__damagesClient<$Result.GetResult<Prisma.$damagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Damages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damagesCountArgs} args - Arguments to filter Damages to count.
     * @example
     * // Count the number of Damages
     * const count = await prisma.damages.count({
     *   where: {
     *     // ... the filter for the Damages we want to count
     *   }
     * })
    **/
    count<T extends damagesCountArgs>(
      args?: Subset<T, damagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DamagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Damages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DamagesAggregateArgs>(args: Subset<T, DamagesAggregateArgs>): Prisma.PrismaPromise<GetDamagesAggregateType<T>>

    /**
     * Group by Damages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends damagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: damagesGroupByArgs['orderBy'] }
        : { orderBy?: damagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, damagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDamagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the damages model
   */
  readonly fields: damagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for damages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__damagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the damages model
   */
  interface damagesFieldRefs {
    readonly id: FieldRef<"damages", 'Int'>
    readonly doc_no: FieldRef<"damages", 'String'>
    readonly doc_date: FieldRef<"damages", 'DateTime'>
    readonly ref_doc_no: FieldRef<"damages", 'String'>
    readonly sale_office_id: FieldRef<"damages", 'Int'>
    readonly department_id: FieldRef<"damages", 'Int'>
    readonly total: FieldRef<"damages", 'Float'>
    readonly sign_factory: FieldRef<"damages", 'String'>
    readonly sign_NH: FieldRef<"damages", 'String'>
    readonly sign_factory_time: FieldRef<"damages", 'DateTime'>
    readonly sign_NH_time: FieldRef<"damages", 'DateTime'>
    readonly factory_id: FieldRef<"damages", 'Int'>
    readonly status: FieldRef<"damages", 'Boolean'>
    readonly create_at: FieldRef<"damages", 'DateTime'>
    readonly update_at: FieldRef<"damages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * damages findUnique
   */
  export type damagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
    /**
     * Filter, which damages to fetch.
     */
    where: damagesWhereUniqueInput
  }

  /**
   * damages findUniqueOrThrow
   */
  export type damagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
    /**
     * Filter, which damages to fetch.
     */
    where: damagesWhereUniqueInput
  }

  /**
   * damages findFirst
   */
  export type damagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
    /**
     * Filter, which damages to fetch.
     */
    where?: damagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damages to fetch.
     */
    orderBy?: damagesOrderByWithRelationInput | damagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for damages.
     */
    cursor?: damagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of damages.
     */
    distinct?: DamagesScalarFieldEnum | DamagesScalarFieldEnum[]
  }

  /**
   * damages findFirstOrThrow
   */
  export type damagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
    /**
     * Filter, which damages to fetch.
     */
    where?: damagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damages to fetch.
     */
    orderBy?: damagesOrderByWithRelationInput | damagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for damages.
     */
    cursor?: damagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of damages.
     */
    distinct?: DamagesScalarFieldEnum | DamagesScalarFieldEnum[]
  }

  /**
   * damages findMany
   */
  export type damagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
    /**
     * Filter, which damages to fetch.
     */
    where?: damagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damages to fetch.
     */
    orderBy?: damagesOrderByWithRelationInput | damagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing damages.
     */
    cursor?: damagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damages.
     */
    skip?: number
    distinct?: DamagesScalarFieldEnum | DamagesScalarFieldEnum[]
  }

  /**
   * damages create
   */
  export type damagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
    /**
     * The data needed to create a damages.
     */
    data: XOR<damagesCreateInput, damagesUncheckedCreateInput>
  }

  /**
   * damages createMany
   */
  export type damagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many damages.
     */
    data: damagesCreateManyInput | damagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * damages update
   */
  export type damagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
    /**
     * The data needed to update a damages.
     */
    data: XOR<damagesUpdateInput, damagesUncheckedUpdateInput>
    /**
     * Choose, which damages to update.
     */
    where: damagesWhereUniqueInput
  }

  /**
   * damages updateMany
   */
  export type damagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update damages.
     */
    data: XOR<damagesUpdateManyMutationInput, damagesUncheckedUpdateManyInput>
    /**
     * Filter which damages to update
     */
    where?: damagesWhereInput
    /**
     * Limit how many damages to update.
     */
    limit?: number
  }

  /**
   * damages upsert
   */
  export type damagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
    /**
     * The filter to search for the damages to update in case it exists.
     */
    where: damagesWhereUniqueInput
    /**
     * In case the damages found by the `where` argument doesn't exist, create a new damages with this data.
     */
    create: XOR<damagesCreateInput, damagesUncheckedCreateInput>
    /**
     * In case the damages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<damagesUpdateInput, damagesUncheckedUpdateInput>
  }

  /**
   * damages delete
   */
  export type damagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
    /**
     * Filter which damages to delete.
     */
    where: damagesWhereUniqueInput
  }

  /**
   * damages deleteMany
   */
  export type damagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which damages to delete
     */
    where?: damagesWhereInput
    /**
     * Limit how many damages to delete.
     */
    limit?: number
  }

  /**
   * damages without action
   */
  export type damagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damages
     */
    select?: damagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damages
     */
    omit?: damagesOmit<ExtArgs> | null
  }


  /**
   * Model damage_details
   */

  export type AggregateDamage_details = {
    _count: Damage_detailsCountAggregateOutputType | null
    _avg: Damage_detailsAvgAggregateOutputType | null
    _sum: Damage_detailsSumAggregateOutputType | null
    _min: Damage_detailsMinAggregateOutputType | null
    _max: Damage_detailsMaxAggregateOutputType | null
  }

  export type Damage_detailsAvgAggregateOutputType = {
    id: number | null
    damage_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
  }

  export type Damage_detailsSumAggregateOutputType = {
    id: number | null
    damage_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
  }

  export type Damage_detailsMinAggregateOutputType = {
    id: number | null
    damage_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
    is_cancel: boolean | null
    is_checklist: boolean | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Damage_detailsMaxAggregateOutputType = {
    id: number | null
    damage_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
    is_cancel: boolean | null
    is_checklist: boolean | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Damage_detailsCountAggregateOutputType = {
    id: number
    damage_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: number
    is_checklist: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Damage_detailsAvgAggregateInputType = {
    id?: true
    damage_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
  }

  export type Damage_detailsSumAggregateInputType = {
    id?: true
    damage_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
  }

  export type Damage_detailsMinAggregateInputType = {
    id?: true
    damage_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
    is_cancel?: true
    is_checklist?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Damage_detailsMaxAggregateInputType = {
    id?: true
    damage_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
    is_cancel?: true
    is_checklist?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Damage_detailsCountAggregateInputType = {
    id?: true
    damage_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
    is_cancel?: true
    is_checklist?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Damage_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which damage_details to aggregate.
     */
    where?: damage_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damage_details to fetch.
     */
    orderBy?: damage_detailsOrderByWithRelationInput | damage_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: damage_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damage_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damage_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned damage_details
    **/
    _count?: true | Damage_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Damage_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Damage_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Damage_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Damage_detailsMaxAggregateInputType
  }

  export type GetDamage_detailsAggregateType<T extends Damage_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateDamage_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDamage_details[P]>
      : GetScalarType<T[P], AggregateDamage_details[P]>
  }




  export type damage_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: damage_detailsWhereInput
    orderBy?: damage_detailsOrderByWithAggregationInput | damage_detailsOrderByWithAggregationInput[]
    by: Damage_detailsScalarFieldEnum[] | Damage_detailsScalarFieldEnum
    having?: damage_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Damage_detailsCountAggregateInputType | true
    _avg?: Damage_detailsAvgAggregateInputType
    _sum?: Damage_detailsSumAggregateInputType
    _min?: Damage_detailsMinAggregateInputType
    _max?: Damage_detailsMaxAggregateInputType
  }

  export type Damage_detailsGroupByOutputType = {
    id: number
    damage_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Damage_detailsCountAggregateOutputType | null
    _avg: Damage_detailsAvgAggregateOutputType | null
    _sum: Damage_detailsSumAggregateOutputType | null
    _min: Damage_detailsMinAggregateOutputType | null
    _max: Damage_detailsMaxAggregateOutputType | null
  }

  type GetDamage_detailsGroupByPayload<T extends damage_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Damage_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Damage_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Damage_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Damage_detailsGroupByOutputType[P]>
        }
      >
    >


  export type damage_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    damage_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    is_checklist?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["damage_details"]>



  export type damage_detailsSelectScalar = {
    id?: boolean
    damage_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    is_checklist?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type damage_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "damage_id" | "item_id" | "unit_id" | "qty" | "weight" | "is_cancel" | "is_checklist" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["damage_details"]>

  export type $damage_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "damage_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      damage_id: number
      item_id: number
      unit_id: number
      qty: number
      weight: number
      is_cancel: boolean
      is_checklist: boolean
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["damage_details"]>
    composites: {}
  }

  type damage_detailsGetPayload<S extends boolean | null | undefined | damage_detailsDefaultArgs> = $Result.GetResult<Prisma.$damage_detailsPayload, S>

  type damage_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<damage_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Damage_detailsCountAggregateInputType | true
    }

  export interface damage_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['damage_details'], meta: { name: 'damage_details' } }
    /**
     * Find zero or one Damage_details that matches the filter.
     * @param {damage_detailsFindUniqueArgs} args - Arguments to find a Damage_details
     * @example
     * // Get one Damage_details
     * const damage_details = await prisma.damage_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends damage_detailsFindUniqueArgs>(args: SelectSubset<T, damage_detailsFindUniqueArgs<ExtArgs>>): Prisma__damage_detailsClient<$Result.GetResult<Prisma.$damage_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Damage_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {damage_detailsFindUniqueOrThrowArgs} args - Arguments to find a Damage_details
     * @example
     * // Get one Damage_details
     * const damage_details = await prisma.damage_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends damage_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, damage_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__damage_detailsClient<$Result.GetResult<Prisma.$damage_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Damage_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damage_detailsFindFirstArgs} args - Arguments to find a Damage_details
     * @example
     * // Get one Damage_details
     * const damage_details = await prisma.damage_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends damage_detailsFindFirstArgs>(args?: SelectSubset<T, damage_detailsFindFirstArgs<ExtArgs>>): Prisma__damage_detailsClient<$Result.GetResult<Prisma.$damage_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Damage_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damage_detailsFindFirstOrThrowArgs} args - Arguments to find a Damage_details
     * @example
     * // Get one Damage_details
     * const damage_details = await prisma.damage_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends damage_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, damage_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__damage_detailsClient<$Result.GetResult<Prisma.$damage_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Damage_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damage_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Damage_details
     * const damage_details = await prisma.damage_details.findMany()
     * 
     * // Get first 10 Damage_details
     * const damage_details = await prisma.damage_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const damage_detailsWithIdOnly = await prisma.damage_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends damage_detailsFindManyArgs>(args?: SelectSubset<T, damage_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$damage_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Damage_details.
     * @param {damage_detailsCreateArgs} args - Arguments to create a Damage_details.
     * @example
     * // Create one Damage_details
     * const Damage_details = await prisma.damage_details.create({
     *   data: {
     *     // ... data to create a Damage_details
     *   }
     * })
     * 
     */
    create<T extends damage_detailsCreateArgs>(args: SelectSubset<T, damage_detailsCreateArgs<ExtArgs>>): Prisma__damage_detailsClient<$Result.GetResult<Prisma.$damage_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Damage_details.
     * @param {damage_detailsCreateManyArgs} args - Arguments to create many Damage_details.
     * @example
     * // Create many Damage_details
     * const damage_details = await prisma.damage_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends damage_detailsCreateManyArgs>(args?: SelectSubset<T, damage_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Damage_details.
     * @param {damage_detailsDeleteArgs} args - Arguments to delete one Damage_details.
     * @example
     * // Delete one Damage_details
     * const Damage_details = await prisma.damage_details.delete({
     *   where: {
     *     // ... filter to delete one Damage_details
     *   }
     * })
     * 
     */
    delete<T extends damage_detailsDeleteArgs>(args: SelectSubset<T, damage_detailsDeleteArgs<ExtArgs>>): Prisma__damage_detailsClient<$Result.GetResult<Prisma.$damage_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Damage_details.
     * @param {damage_detailsUpdateArgs} args - Arguments to update one Damage_details.
     * @example
     * // Update one Damage_details
     * const damage_details = await prisma.damage_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends damage_detailsUpdateArgs>(args: SelectSubset<T, damage_detailsUpdateArgs<ExtArgs>>): Prisma__damage_detailsClient<$Result.GetResult<Prisma.$damage_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Damage_details.
     * @param {damage_detailsDeleteManyArgs} args - Arguments to filter Damage_details to delete.
     * @example
     * // Delete a few Damage_details
     * const { count } = await prisma.damage_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends damage_detailsDeleteManyArgs>(args?: SelectSubset<T, damage_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Damage_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damage_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Damage_details
     * const damage_details = await prisma.damage_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends damage_detailsUpdateManyArgs>(args: SelectSubset<T, damage_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Damage_details.
     * @param {damage_detailsUpsertArgs} args - Arguments to update or create a Damage_details.
     * @example
     * // Update or create a Damage_details
     * const damage_details = await prisma.damage_details.upsert({
     *   create: {
     *     // ... data to create a Damage_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Damage_details we want to update
     *   }
     * })
     */
    upsert<T extends damage_detailsUpsertArgs>(args: SelectSubset<T, damage_detailsUpsertArgs<ExtArgs>>): Prisma__damage_detailsClient<$Result.GetResult<Prisma.$damage_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Damage_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damage_detailsCountArgs} args - Arguments to filter Damage_details to count.
     * @example
     * // Count the number of Damage_details
     * const count = await prisma.damage_details.count({
     *   where: {
     *     // ... the filter for the Damage_details we want to count
     *   }
     * })
    **/
    count<T extends damage_detailsCountArgs>(
      args?: Subset<T, damage_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Damage_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Damage_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Damage_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Damage_detailsAggregateArgs>(args: Subset<T, Damage_detailsAggregateArgs>): Prisma.PrismaPromise<GetDamage_detailsAggregateType<T>>

    /**
     * Group by Damage_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {damage_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends damage_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: damage_detailsGroupByArgs['orderBy'] }
        : { orderBy?: damage_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, damage_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDamage_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the damage_details model
   */
  readonly fields: damage_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for damage_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__damage_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the damage_details model
   */
  interface damage_detailsFieldRefs {
    readonly id: FieldRef<"damage_details", 'Int'>
    readonly damage_id: FieldRef<"damage_details", 'Int'>
    readonly item_id: FieldRef<"damage_details", 'Int'>
    readonly unit_id: FieldRef<"damage_details", 'Int'>
    readonly qty: FieldRef<"damage_details", 'Float'>
    readonly weight: FieldRef<"damage_details", 'Float'>
    readonly is_cancel: FieldRef<"damage_details", 'Boolean'>
    readonly is_checklist: FieldRef<"damage_details", 'Boolean'>
    readonly description: FieldRef<"damage_details", 'String'>
    readonly status: FieldRef<"damage_details", 'Boolean'>
    readonly create_at: FieldRef<"damage_details", 'DateTime'>
    readonly update_at: FieldRef<"damage_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * damage_details findUnique
   */
  export type damage_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
    /**
     * Filter, which damage_details to fetch.
     */
    where: damage_detailsWhereUniqueInput
  }

  /**
   * damage_details findUniqueOrThrow
   */
  export type damage_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
    /**
     * Filter, which damage_details to fetch.
     */
    where: damage_detailsWhereUniqueInput
  }

  /**
   * damage_details findFirst
   */
  export type damage_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
    /**
     * Filter, which damage_details to fetch.
     */
    where?: damage_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damage_details to fetch.
     */
    orderBy?: damage_detailsOrderByWithRelationInput | damage_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for damage_details.
     */
    cursor?: damage_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damage_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damage_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of damage_details.
     */
    distinct?: Damage_detailsScalarFieldEnum | Damage_detailsScalarFieldEnum[]
  }

  /**
   * damage_details findFirstOrThrow
   */
  export type damage_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
    /**
     * Filter, which damage_details to fetch.
     */
    where?: damage_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damage_details to fetch.
     */
    orderBy?: damage_detailsOrderByWithRelationInput | damage_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for damage_details.
     */
    cursor?: damage_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damage_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damage_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of damage_details.
     */
    distinct?: Damage_detailsScalarFieldEnum | Damage_detailsScalarFieldEnum[]
  }

  /**
   * damage_details findMany
   */
  export type damage_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
    /**
     * Filter, which damage_details to fetch.
     */
    where?: damage_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of damage_details to fetch.
     */
    orderBy?: damage_detailsOrderByWithRelationInput | damage_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing damage_details.
     */
    cursor?: damage_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` damage_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` damage_details.
     */
    skip?: number
    distinct?: Damage_detailsScalarFieldEnum | Damage_detailsScalarFieldEnum[]
  }

  /**
   * damage_details create
   */
  export type damage_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
    /**
     * The data needed to create a damage_details.
     */
    data: XOR<damage_detailsCreateInput, damage_detailsUncheckedCreateInput>
  }

  /**
   * damage_details createMany
   */
  export type damage_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many damage_details.
     */
    data: damage_detailsCreateManyInput | damage_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * damage_details update
   */
  export type damage_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
    /**
     * The data needed to update a damage_details.
     */
    data: XOR<damage_detailsUpdateInput, damage_detailsUncheckedUpdateInput>
    /**
     * Choose, which damage_details to update.
     */
    where: damage_detailsWhereUniqueInput
  }

  /**
   * damage_details updateMany
   */
  export type damage_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update damage_details.
     */
    data: XOR<damage_detailsUpdateManyMutationInput, damage_detailsUncheckedUpdateManyInput>
    /**
     * Filter which damage_details to update
     */
    where?: damage_detailsWhereInput
    /**
     * Limit how many damage_details to update.
     */
    limit?: number
  }

  /**
   * damage_details upsert
   */
  export type damage_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
    /**
     * The filter to search for the damage_details to update in case it exists.
     */
    where: damage_detailsWhereUniqueInput
    /**
     * In case the damage_details found by the `where` argument doesn't exist, create a new damage_details with this data.
     */
    create: XOR<damage_detailsCreateInput, damage_detailsUncheckedCreateInput>
    /**
     * In case the damage_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<damage_detailsUpdateInput, damage_detailsUncheckedUpdateInput>
  }

  /**
   * damage_details delete
   */
  export type damage_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
    /**
     * Filter which damage_details to delete.
     */
    where: damage_detailsWhereUniqueInput
  }

  /**
   * damage_details deleteMany
   */
  export type damage_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which damage_details to delete
     */
    where?: damage_detailsWhereInput
    /**
     * Limit how many damage_details to delete.
     */
    limit?: number
  }

  /**
   * damage_details without action
   */
  export type damage_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the damage_details
     */
    select?: damage_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the damage_details
     */
    omit?: damage_detailsOmit<ExtArgs> | null
  }


  /**
   * Model ships
   */

  export type AggregateShips = {
    _count: ShipsCountAggregateOutputType | null
    _avg: ShipsAvgAggregateOutputType | null
    _sum: ShipsSumAggregateOutputType | null
    _min: ShipsMinAggregateOutputType | null
    _max: ShipsMaxAggregateOutputType | null
  }

  export type ShipsAvgAggregateOutputType = {
    id: number | null
    item_id: number | null
  }

  export type ShipsSumAggregateOutputType = {
    id: number | null
    item_id: number | null
  }

  export type ShipsMinAggregateOutputType = {
    id: number | null
    item_id: number | null
    site_short_code: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type ShipsMaxAggregateOutputType = {
    id: number | null
    item_id: number | null
    site_short_code: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type ShipsCountAggregateOutputType = {
    id: number
    item_id: number
    site_short_code: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type ShipsAvgAggregateInputType = {
    id?: true
    item_id?: true
  }

  export type ShipsSumAggregateInputType = {
    id?: true
    item_id?: true
  }

  export type ShipsMinAggregateInputType = {
    id?: true
    item_id?: true
    site_short_code?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type ShipsMaxAggregateInputType = {
    id?: true
    item_id?: true
    site_short_code?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type ShipsCountAggregateInputType = {
    id?: true
    item_id?: true
    site_short_code?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type ShipsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ships to aggregate.
     */
    where?: shipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ships to fetch.
     */
    orderBy?: shipsOrderByWithRelationInput | shipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ships
    **/
    _count?: true | ShipsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShipsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShipsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShipsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShipsMaxAggregateInputType
  }

  export type GetShipsAggregateType<T extends ShipsAggregateArgs> = {
        [P in keyof T & keyof AggregateShips]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShips[P]>
      : GetScalarType<T[P], AggregateShips[P]>
  }




  export type shipsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shipsWhereInput
    orderBy?: shipsOrderByWithAggregationInput | shipsOrderByWithAggregationInput[]
    by: ShipsScalarFieldEnum[] | ShipsScalarFieldEnum
    having?: shipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShipsCountAggregateInputType | true
    _avg?: ShipsAvgAggregateInputType
    _sum?: ShipsSumAggregateInputType
    _min?: ShipsMinAggregateInputType
    _max?: ShipsMaxAggregateInputType
  }

  export type ShipsGroupByOutputType = {
    id: number
    item_id: number
    site_short_code: string
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: ShipsCountAggregateOutputType | null
    _avg: ShipsAvgAggregateOutputType | null
    _sum: ShipsSumAggregateOutputType | null
    _min: ShipsMinAggregateOutputType | null
    _max: ShipsMaxAggregateOutputType | null
  }

  type GetShipsGroupByPayload<T extends shipsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShipsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShipsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShipsGroupByOutputType[P]>
            : GetScalarType<T[P], ShipsGroupByOutputType[P]>
        }
      >
    >


  export type shipsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    site_short_code?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["ships"]>



  export type shipsSelectScalar = {
    id?: boolean
    item_id?: boolean
    site_short_code?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type shipsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_id" | "site_short_code" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["ships"]>

  export type $shipsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ships"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      item_id: number
      site_short_code: string
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["ships"]>
    composites: {}
  }

  type shipsGetPayload<S extends boolean | null | undefined | shipsDefaultArgs> = $Result.GetResult<Prisma.$shipsPayload, S>

  type shipsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<shipsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShipsCountAggregateInputType | true
    }

  export interface shipsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ships'], meta: { name: 'ships' } }
    /**
     * Find zero or one Ships that matches the filter.
     * @param {shipsFindUniqueArgs} args - Arguments to find a Ships
     * @example
     * // Get one Ships
     * const ships = await prisma.ships.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shipsFindUniqueArgs>(args: SelectSubset<T, shipsFindUniqueArgs<ExtArgs>>): Prisma__shipsClient<$Result.GetResult<Prisma.$shipsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ships that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {shipsFindUniqueOrThrowArgs} args - Arguments to find a Ships
     * @example
     * // Get one Ships
     * const ships = await prisma.ships.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shipsFindUniqueOrThrowArgs>(args: SelectSubset<T, shipsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shipsClient<$Result.GetResult<Prisma.$shipsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipsFindFirstArgs} args - Arguments to find a Ships
     * @example
     * // Get one Ships
     * const ships = await prisma.ships.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shipsFindFirstArgs>(args?: SelectSubset<T, shipsFindFirstArgs<ExtArgs>>): Prisma__shipsClient<$Result.GetResult<Prisma.$shipsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ships that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipsFindFirstOrThrowArgs} args - Arguments to find a Ships
     * @example
     * // Get one Ships
     * const ships = await prisma.ships.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shipsFindFirstOrThrowArgs>(args?: SelectSubset<T, shipsFindFirstOrThrowArgs<ExtArgs>>): Prisma__shipsClient<$Result.GetResult<Prisma.$shipsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ships
     * const ships = await prisma.ships.findMany()
     * 
     * // Get first 10 Ships
     * const ships = await prisma.ships.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shipsWithIdOnly = await prisma.ships.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends shipsFindManyArgs>(args?: SelectSubset<T, shipsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shipsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ships.
     * @param {shipsCreateArgs} args - Arguments to create a Ships.
     * @example
     * // Create one Ships
     * const Ships = await prisma.ships.create({
     *   data: {
     *     // ... data to create a Ships
     *   }
     * })
     * 
     */
    create<T extends shipsCreateArgs>(args: SelectSubset<T, shipsCreateArgs<ExtArgs>>): Prisma__shipsClient<$Result.GetResult<Prisma.$shipsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ships.
     * @param {shipsCreateManyArgs} args - Arguments to create many Ships.
     * @example
     * // Create many Ships
     * const ships = await prisma.ships.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shipsCreateManyArgs>(args?: SelectSubset<T, shipsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ships.
     * @param {shipsDeleteArgs} args - Arguments to delete one Ships.
     * @example
     * // Delete one Ships
     * const Ships = await prisma.ships.delete({
     *   where: {
     *     // ... filter to delete one Ships
     *   }
     * })
     * 
     */
    delete<T extends shipsDeleteArgs>(args: SelectSubset<T, shipsDeleteArgs<ExtArgs>>): Prisma__shipsClient<$Result.GetResult<Prisma.$shipsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ships.
     * @param {shipsUpdateArgs} args - Arguments to update one Ships.
     * @example
     * // Update one Ships
     * const ships = await prisma.ships.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shipsUpdateArgs>(args: SelectSubset<T, shipsUpdateArgs<ExtArgs>>): Prisma__shipsClient<$Result.GetResult<Prisma.$shipsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ships.
     * @param {shipsDeleteManyArgs} args - Arguments to filter Ships to delete.
     * @example
     * // Delete a few Ships
     * const { count } = await prisma.ships.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shipsDeleteManyArgs>(args?: SelectSubset<T, shipsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ships
     * const ships = await prisma.ships.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shipsUpdateManyArgs>(args: SelectSubset<T, shipsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ships.
     * @param {shipsUpsertArgs} args - Arguments to update or create a Ships.
     * @example
     * // Update or create a Ships
     * const ships = await prisma.ships.upsert({
     *   create: {
     *     // ... data to create a Ships
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ships we want to update
     *   }
     * })
     */
    upsert<T extends shipsUpsertArgs>(args: SelectSubset<T, shipsUpsertArgs<ExtArgs>>): Prisma__shipsClient<$Result.GetResult<Prisma.$shipsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipsCountArgs} args - Arguments to filter Ships to count.
     * @example
     * // Count the number of Ships
     * const count = await prisma.ships.count({
     *   where: {
     *     // ... the filter for the Ships we want to count
     *   }
     * })
    **/
    count<T extends shipsCountArgs>(
      args?: Subset<T, shipsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShipsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShipsAggregateArgs>(args: Subset<T, ShipsAggregateArgs>): Prisma.PrismaPromise<GetShipsAggregateType<T>>

    /**
     * Group by Ships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shipsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shipsGroupByArgs['orderBy'] }
        : { orderBy?: shipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shipsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShipsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ships model
   */
  readonly fields: shipsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ships.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shipsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ships model
   */
  interface shipsFieldRefs {
    readonly id: FieldRef<"ships", 'Int'>
    readonly item_id: FieldRef<"ships", 'Int'>
    readonly site_short_code: FieldRef<"ships", 'String'>
    readonly description: FieldRef<"ships", 'String'>
    readonly status: FieldRef<"ships", 'Boolean'>
    readonly create_at: FieldRef<"ships", 'DateTime'>
    readonly update_at: FieldRef<"ships", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ships findUnique
   */
  export type shipsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
    /**
     * Filter, which ships to fetch.
     */
    where: shipsWhereUniqueInput
  }

  /**
   * ships findUniqueOrThrow
   */
  export type shipsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
    /**
     * Filter, which ships to fetch.
     */
    where: shipsWhereUniqueInput
  }

  /**
   * ships findFirst
   */
  export type shipsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
    /**
     * Filter, which ships to fetch.
     */
    where?: shipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ships to fetch.
     */
    orderBy?: shipsOrderByWithRelationInput | shipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ships.
     */
    cursor?: shipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ships.
     */
    distinct?: ShipsScalarFieldEnum | ShipsScalarFieldEnum[]
  }

  /**
   * ships findFirstOrThrow
   */
  export type shipsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
    /**
     * Filter, which ships to fetch.
     */
    where?: shipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ships to fetch.
     */
    orderBy?: shipsOrderByWithRelationInput | shipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ships.
     */
    cursor?: shipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ships.
     */
    distinct?: ShipsScalarFieldEnum | ShipsScalarFieldEnum[]
  }

  /**
   * ships findMany
   */
  export type shipsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
    /**
     * Filter, which ships to fetch.
     */
    where?: shipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ships to fetch.
     */
    orderBy?: shipsOrderByWithRelationInput | shipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ships.
     */
    cursor?: shipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ships.
     */
    skip?: number
    distinct?: ShipsScalarFieldEnum | ShipsScalarFieldEnum[]
  }

  /**
   * ships create
   */
  export type shipsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
    /**
     * The data needed to create a ships.
     */
    data: XOR<shipsCreateInput, shipsUncheckedCreateInput>
  }

  /**
   * ships createMany
   */
  export type shipsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ships.
     */
    data: shipsCreateManyInput | shipsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ships update
   */
  export type shipsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
    /**
     * The data needed to update a ships.
     */
    data: XOR<shipsUpdateInput, shipsUncheckedUpdateInput>
    /**
     * Choose, which ships to update.
     */
    where: shipsWhereUniqueInput
  }

  /**
   * ships updateMany
   */
  export type shipsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ships.
     */
    data: XOR<shipsUpdateManyMutationInput, shipsUncheckedUpdateManyInput>
    /**
     * Filter which ships to update
     */
    where?: shipsWhereInput
    /**
     * Limit how many ships to update.
     */
    limit?: number
  }

  /**
   * ships upsert
   */
  export type shipsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
    /**
     * The filter to search for the ships to update in case it exists.
     */
    where: shipsWhereUniqueInput
    /**
     * In case the ships found by the `where` argument doesn't exist, create a new ships with this data.
     */
    create: XOR<shipsCreateInput, shipsUncheckedCreateInput>
    /**
     * In case the ships was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shipsUpdateInput, shipsUncheckedUpdateInput>
  }

  /**
   * ships delete
   */
  export type shipsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
    /**
     * Filter which ships to delete.
     */
    where: shipsWhereUniqueInput
  }

  /**
   * ships deleteMany
   */
  export type shipsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ships to delete
     */
    where?: shipsWhereInput
    /**
     * Limit how many ships to delete.
     */
    limit?: number
  }

  /**
   * ships without action
   */
  export type shipsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ships
     */
    select?: shipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ships
     */
    omit?: shipsOmit<ExtArgs> | null
  }


  /**
   * Model new_linens
   */

  export type AggregateNew_linens = {
    _count: New_linensCountAggregateOutputType | null
    _avg: New_linensAvgAggregateOutputType | null
    _sum: New_linensSumAggregateOutputType | null
    _min: New_linensMinAggregateOutputType | null
    _max: New_linensMaxAggregateOutputType | null
  }

  export type New_linensAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    factory_id: number | null
  }

  export type New_linensSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    factory_id: number | null
  }

  export type New_linensMinAggregateOutputType = {
    id: number | null
    doc_no: string | null
    doc_date: Date | null
    ref_doc_no: string | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    is_recive: boolean | null
    receive_date: Date | null
    receive_detail: string | null
    is_process: boolean | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type New_linensMaxAggregateOutputType = {
    id: number | null
    doc_no: string | null
    doc_date: Date | null
    ref_doc_no: string | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    is_recive: boolean | null
    receive_date: Date | null
    receive_detail: string | null
    is_process: boolean | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type New_linensCountAggregateOutputType = {
    id: number
    doc_no: number
    doc_date: number
    ref_doc_no: number
    sale_office_id: number
    department_id: number
    total: number
    is_recive: number
    receive_date: number
    receive_detail: number
    is_process: number
    sign_factory: number
    sign_NH: number
    sign_factory_time: number
    sign_NH_time: number
    factory_id: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type New_linensAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    factory_id?: true
  }

  export type New_linensSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    factory_id?: true
  }

  export type New_linensMinAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    is_recive?: true
    receive_date?: true
    receive_detail?: true
    is_process?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type New_linensMaxAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    is_recive?: true
    receive_date?: true
    receive_detail?: true
    is_process?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type New_linensCountAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    is_recive?: true
    receive_date?: true
    receive_detail?: true
    is_process?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type New_linensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which new_linens to aggregate.
     */
    where?: new_linensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_linens to fetch.
     */
    orderBy?: new_linensOrderByWithRelationInput | new_linensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: new_linensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_linens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_linens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned new_linens
    **/
    _count?: true | New_linensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: New_linensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: New_linensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: New_linensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: New_linensMaxAggregateInputType
  }

  export type GetNew_linensAggregateType<T extends New_linensAggregateArgs> = {
        [P in keyof T & keyof AggregateNew_linens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNew_linens[P]>
      : GetScalarType<T[P], AggregateNew_linens[P]>
  }




  export type new_linensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: new_linensWhereInput
    orderBy?: new_linensOrderByWithAggregationInput | new_linensOrderByWithAggregationInput[]
    by: New_linensScalarFieldEnum[] | New_linensScalarFieldEnum
    having?: new_linensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: New_linensCountAggregateInputType | true
    _avg?: New_linensAvgAggregateInputType
    _sum?: New_linensSumAggregateInputType
    _min?: New_linensMinAggregateInputType
    _max?: New_linensMaxAggregateInputType
  }

  export type New_linensGroupByOutputType = {
    id: number
    doc_no: string
    doc_date: Date
    ref_doc_no: string | null
    sale_office_id: number
    department_id: number
    total: number
    is_recive: boolean | null
    receive_date: Date | null
    receive_detail: string | null
    is_process: boolean | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number
    status: boolean
    create_at: Date
    update_at: Date
    _count: New_linensCountAggregateOutputType | null
    _avg: New_linensAvgAggregateOutputType | null
    _sum: New_linensSumAggregateOutputType | null
    _min: New_linensMinAggregateOutputType | null
    _max: New_linensMaxAggregateOutputType | null
  }

  type GetNew_linensGroupByPayload<T extends new_linensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<New_linensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof New_linensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], New_linensGroupByOutputType[P]>
            : GetScalarType<T[P], New_linensGroupByOutputType[P]>
        }
      >
    >


  export type new_linensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    ref_doc_no?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    total?: boolean
    is_recive?: boolean
    receive_date?: boolean
    receive_detail?: boolean
    is_process?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["new_linens"]>



  export type new_linensSelectScalar = {
    id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    ref_doc_no?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    total?: boolean
    is_recive?: boolean
    receive_date?: boolean
    receive_detail?: boolean
    is_process?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type new_linensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doc_no" | "doc_date" | "ref_doc_no" | "sale_office_id" | "department_id" | "total" | "is_recive" | "receive_date" | "receive_detail" | "is_process" | "sign_factory" | "sign_NH" | "sign_factory_time" | "sign_NH_time" | "factory_id" | "status" | "create_at" | "update_at", ExtArgs["result"]["new_linens"]>

  export type $new_linensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "new_linens"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doc_no: string
      doc_date: Date
      ref_doc_no: string | null
      sale_office_id: number
      department_id: number
      total: number
      is_recive: boolean | null
      receive_date: Date | null
      receive_detail: string | null
      is_process: boolean | null
      sign_factory: string | null
      sign_NH: string | null
      sign_factory_time: Date | null
      sign_NH_time: Date | null
      factory_id: number
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["new_linens"]>
    composites: {}
  }

  type new_linensGetPayload<S extends boolean | null | undefined | new_linensDefaultArgs> = $Result.GetResult<Prisma.$new_linensPayload, S>

  type new_linensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<new_linensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: New_linensCountAggregateInputType | true
    }

  export interface new_linensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['new_linens'], meta: { name: 'new_linens' } }
    /**
     * Find zero or one New_linens that matches the filter.
     * @param {new_linensFindUniqueArgs} args - Arguments to find a New_linens
     * @example
     * // Get one New_linens
     * const new_linens = await prisma.new_linens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends new_linensFindUniqueArgs>(args: SelectSubset<T, new_linensFindUniqueArgs<ExtArgs>>): Prisma__new_linensClient<$Result.GetResult<Prisma.$new_linensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one New_linens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {new_linensFindUniqueOrThrowArgs} args - Arguments to find a New_linens
     * @example
     * // Get one New_linens
     * const new_linens = await prisma.new_linens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends new_linensFindUniqueOrThrowArgs>(args: SelectSubset<T, new_linensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__new_linensClient<$Result.GetResult<Prisma.$new_linensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first New_linens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linensFindFirstArgs} args - Arguments to find a New_linens
     * @example
     * // Get one New_linens
     * const new_linens = await prisma.new_linens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends new_linensFindFirstArgs>(args?: SelectSubset<T, new_linensFindFirstArgs<ExtArgs>>): Prisma__new_linensClient<$Result.GetResult<Prisma.$new_linensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first New_linens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linensFindFirstOrThrowArgs} args - Arguments to find a New_linens
     * @example
     * // Get one New_linens
     * const new_linens = await prisma.new_linens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends new_linensFindFirstOrThrowArgs>(args?: SelectSubset<T, new_linensFindFirstOrThrowArgs<ExtArgs>>): Prisma__new_linensClient<$Result.GetResult<Prisma.$new_linensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more New_linens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all New_linens
     * const new_linens = await prisma.new_linens.findMany()
     * 
     * // Get first 10 New_linens
     * const new_linens = await prisma.new_linens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const new_linensWithIdOnly = await prisma.new_linens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends new_linensFindManyArgs>(args?: SelectSubset<T, new_linensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$new_linensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a New_linens.
     * @param {new_linensCreateArgs} args - Arguments to create a New_linens.
     * @example
     * // Create one New_linens
     * const New_linens = await prisma.new_linens.create({
     *   data: {
     *     // ... data to create a New_linens
     *   }
     * })
     * 
     */
    create<T extends new_linensCreateArgs>(args: SelectSubset<T, new_linensCreateArgs<ExtArgs>>): Prisma__new_linensClient<$Result.GetResult<Prisma.$new_linensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many New_linens.
     * @param {new_linensCreateManyArgs} args - Arguments to create many New_linens.
     * @example
     * // Create many New_linens
     * const new_linens = await prisma.new_linens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends new_linensCreateManyArgs>(args?: SelectSubset<T, new_linensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a New_linens.
     * @param {new_linensDeleteArgs} args - Arguments to delete one New_linens.
     * @example
     * // Delete one New_linens
     * const New_linens = await prisma.new_linens.delete({
     *   where: {
     *     // ... filter to delete one New_linens
     *   }
     * })
     * 
     */
    delete<T extends new_linensDeleteArgs>(args: SelectSubset<T, new_linensDeleteArgs<ExtArgs>>): Prisma__new_linensClient<$Result.GetResult<Prisma.$new_linensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one New_linens.
     * @param {new_linensUpdateArgs} args - Arguments to update one New_linens.
     * @example
     * // Update one New_linens
     * const new_linens = await prisma.new_linens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends new_linensUpdateArgs>(args: SelectSubset<T, new_linensUpdateArgs<ExtArgs>>): Prisma__new_linensClient<$Result.GetResult<Prisma.$new_linensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more New_linens.
     * @param {new_linensDeleteManyArgs} args - Arguments to filter New_linens to delete.
     * @example
     * // Delete a few New_linens
     * const { count } = await prisma.new_linens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends new_linensDeleteManyArgs>(args?: SelectSubset<T, new_linensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more New_linens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many New_linens
     * const new_linens = await prisma.new_linens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends new_linensUpdateManyArgs>(args: SelectSubset<T, new_linensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one New_linens.
     * @param {new_linensUpsertArgs} args - Arguments to update or create a New_linens.
     * @example
     * // Update or create a New_linens
     * const new_linens = await prisma.new_linens.upsert({
     *   create: {
     *     // ... data to create a New_linens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the New_linens we want to update
     *   }
     * })
     */
    upsert<T extends new_linensUpsertArgs>(args: SelectSubset<T, new_linensUpsertArgs<ExtArgs>>): Prisma__new_linensClient<$Result.GetResult<Prisma.$new_linensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of New_linens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linensCountArgs} args - Arguments to filter New_linens to count.
     * @example
     * // Count the number of New_linens
     * const count = await prisma.new_linens.count({
     *   where: {
     *     // ... the filter for the New_linens we want to count
     *   }
     * })
    **/
    count<T extends new_linensCountArgs>(
      args?: Subset<T, new_linensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], New_linensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a New_linens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {New_linensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends New_linensAggregateArgs>(args: Subset<T, New_linensAggregateArgs>): Prisma.PrismaPromise<GetNew_linensAggregateType<T>>

    /**
     * Group by New_linens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends new_linensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: new_linensGroupByArgs['orderBy'] }
        : { orderBy?: new_linensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, new_linensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNew_linensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the new_linens model
   */
  readonly fields: new_linensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for new_linens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__new_linensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the new_linens model
   */
  interface new_linensFieldRefs {
    readonly id: FieldRef<"new_linens", 'Int'>
    readonly doc_no: FieldRef<"new_linens", 'String'>
    readonly doc_date: FieldRef<"new_linens", 'DateTime'>
    readonly ref_doc_no: FieldRef<"new_linens", 'String'>
    readonly sale_office_id: FieldRef<"new_linens", 'Int'>
    readonly department_id: FieldRef<"new_linens", 'Int'>
    readonly total: FieldRef<"new_linens", 'Float'>
    readonly is_recive: FieldRef<"new_linens", 'Boolean'>
    readonly receive_date: FieldRef<"new_linens", 'DateTime'>
    readonly receive_detail: FieldRef<"new_linens", 'String'>
    readonly is_process: FieldRef<"new_linens", 'Boolean'>
    readonly sign_factory: FieldRef<"new_linens", 'String'>
    readonly sign_NH: FieldRef<"new_linens", 'String'>
    readonly sign_factory_time: FieldRef<"new_linens", 'DateTime'>
    readonly sign_NH_time: FieldRef<"new_linens", 'DateTime'>
    readonly factory_id: FieldRef<"new_linens", 'Int'>
    readonly status: FieldRef<"new_linens", 'Boolean'>
    readonly create_at: FieldRef<"new_linens", 'DateTime'>
    readonly update_at: FieldRef<"new_linens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * new_linens findUnique
   */
  export type new_linensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
    /**
     * Filter, which new_linens to fetch.
     */
    where: new_linensWhereUniqueInput
  }

  /**
   * new_linens findUniqueOrThrow
   */
  export type new_linensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
    /**
     * Filter, which new_linens to fetch.
     */
    where: new_linensWhereUniqueInput
  }

  /**
   * new_linens findFirst
   */
  export type new_linensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
    /**
     * Filter, which new_linens to fetch.
     */
    where?: new_linensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_linens to fetch.
     */
    orderBy?: new_linensOrderByWithRelationInput | new_linensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for new_linens.
     */
    cursor?: new_linensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_linens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_linens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of new_linens.
     */
    distinct?: New_linensScalarFieldEnum | New_linensScalarFieldEnum[]
  }

  /**
   * new_linens findFirstOrThrow
   */
  export type new_linensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
    /**
     * Filter, which new_linens to fetch.
     */
    where?: new_linensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_linens to fetch.
     */
    orderBy?: new_linensOrderByWithRelationInput | new_linensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for new_linens.
     */
    cursor?: new_linensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_linens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_linens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of new_linens.
     */
    distinct?: New_linensScalarFieldEnum | New_linensScalarFieldEnum[]
  }

  /**
   * new_linens findMany
   */
  export type new_linensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
    /**
     * Filter, which new_linens to fetch.
     */
    where?: new_linensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_linens to fetch.
     */
    orderBy?: new_linensOrderByWithRelationInput | new_linensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing new_linens.
     */
    cursor?: new_linensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_linens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_linens.
     */
    skip?: number
    distinct?: New_linensScalarFieldEnum | New_linensScalarFieldEnum[]
  }

  /**
   * new_linens create
   */
  export type new_linensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
    /**
     * The data needed to create a new_linens.
     */
    data: XOR<new_linensCreateInput, new_linensUncheckedCreateInput>
  }

  /**
   * new_linens createMany
   */
  export type new_linensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many new_linens.
     */
    data: new_linensCreateManyInput | new_linensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * new_linens update
   */
  export type new_linensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
    /**
     * The data needed to update a new_linens.
     */
    data: XOR<new_linensUpdateInput, new_linensUncheckedUpdateInput>
    /**
     * Choose, which new_linens to update.
     */
    where: new_linensWhereUniqueInput
  }

  /**
   * new_linens updateMany
   */
  export type new_linensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update new_linens.
     */
    data: XOR<new_linensUpdateManyMutationInput, new_linensUncheckedUpdateManyInput>
    /**
     * Filter which new_linens to update
     */
    where?: new_linensWhereInput
    /**
     * Limit how many new_linens to update.
     */
    limit?: number
  }

  /**
   * new_linens upsert
   */
  export type new_linensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
    /**
     * The filter to search for the new_linens to update in case it exists.
     */
    where: new_linensWhereUniqueInput
    /**
     * In case the new_linens found by the `where` argument doesn't exist, create a new new_linens with this data.
     */
    create: XOR<new_linensCreateInput, new_linensUncheckedCreateInput>
    /**
     * In case the new_linens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<new_linensUpdateInput, new_linensUncheckedUpdateInput>
  }

  /**
   * new_linens delete
   */
  export type new_linensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
    /**
     * Filter which new_linens to delete.
     */
    where: new_linensWhereUniqueInput
  }

  /**
   * new_linens deleteMany
   */
  export type new_linensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which new_linens to delete
     */
    where?: new_linensWhereInput
    /**
     * Limit how many new_linens to delete.
     */
    limit?: number
  }

  /**
   * new_linens without action
   */
  export type new_linensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linens
     */
    select?: new_linensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linens
     */
    omit?: new_linensOmit<ExtArgs> | null
  }


  /**
   * Model new_linen_details
   */

  export type AggregateNew_linen_details = {
    _count: New_linen_detailsCountAggregateOutputType | null
    _avg: New_linen_detailsAvgAggregateOutputType | null
    _sum: New_linen_detailsSumAggregateOutputType | null
    _min: New_linen_detailsMinAggregateOutputType | null
    _max: New_linen_detailsMaxAggregateOutputType | null
  }

  export type New_linen_detailsAvgAggregateOutputType = {
    id: number | null
    new_linen_id: number | null
    department_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
  }

  export type New_linen_detailsSumAggregateOutputType = {
    id: number | null
    new_linen_id: number | null
    department_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
  }

  export type New_linen_detailsMinAggregateOutputType = {
    id: number | null
    new_linen_id: number | null
    department_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
    is_cancel: boolean | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type New_linen_detailsMaxAggregateOutputType = {
    id: number | null
    new_linen_id: number | null
    department_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
    is_cancel: boolean | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type New_linen_detailsCountAggregateOutputType = {
    id: number
    new_linen_id: number
    department_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type New_linen_detailsAvgAggregateInputType = {
    id?: true
    new_linen_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
  }

  export type New_linen_detailsSumAggregateInputType = {
    id?: true
    new_linen_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
  }

  export type New_linen_detailsMinAggregateInputType = {
    id?: true
    new_linen_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
    is_cancel?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type New_linen_detailsMaxAggregateInputType = {
    id?: true
    new_linen_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
    is_cancel?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type New_linen_detailsCountAggregateInputType = {
    id?: true
    new_linen_id?: true
    department_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
    is_cancel?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type New_linen_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which new_linen_details to aggregate.
     */
    where?: new_linen_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_linen_details to fetch.
     */
    orderBy?: new_linen_detailsOrderByWithRelationInput | new_linen_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: new_linen_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_linen_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_linen_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned new_linen_details
    **/
    _count?: true | New_linen_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: New_linen_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: New_linen_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: New_linen_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: New_linen_detailsMaxAggregateInputType
  }

  export type GetNew_linen_detailsAggregateType<T extends New_linen_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateNew_linen_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNew_linen_details[P]>
      : GetScalarType<T[P], AggregateNew_linen_details[P]>
  }




  export type new_linen_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: new_linen_detailsWhereInput
    orderBy?: new_linen_detailsOrderByWithAggregationInput | new_linen_detailsOrderByWithAggregationInput[]
    by: New_linen_detailsScalarFieldEnum[] | New_linen_detailsScalarFieldEnum
    having?: new_linen_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: New_linen_detailsCountAggregateInputType | true
    _avg?: New_linen_detailsAvgAggregateInputType
    _sum?: New_linen_detailsSumAggregateInputType
    _min?: New_linen_detailsMinAggregateInputType
    _max?: New_linen_detailsMaxAggregateInputType
  }

  export type New_linen_detailsGroupByOutputType = {
    id: number
    new_linen_id: number
    department_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    description: string | null
    status: boolean
    create_at: Date
    update_at: Date
    _count: New_linen_detailsCountAggregateOutputType | null
    _avg: New_linen_detailsAvgAggregateOutputType | null
    _sum: New_linen_detailsSumAggregateOutputType | null
    _min: New_linen_detailsMinAggregateOutputType | null
    _max: New_linen_detailsMaxAggregateOutputType | null
  }

  type GetNew_linen_detailsGroupByPayload<T extends new_linen_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<New_linen_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof New_linen_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], New_linen_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], New_linen_detailsGroupByOutputType[P]>
        }
      >
    >


  export type new_linen_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    new_linen_id?: boolean
    department_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    receive_qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["new_linen_details"]>



  export type new_linen_detailsSelectScalar = {
    id?: boolean
    new_linen_id?: boolean
    department_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    receive_qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type new_linen_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "new_linen_id" | "department_id" | "item_id" | "unit_id" | "qty" | "receive_qty" | "weight" | "is_cancel" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["new_linen_details"]>

  export type $new_linen_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "new_linen_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      new_linen_id: number
      department_id: number
      item_id: number
      unit_id: number
      qty: number
      receive_qty: number
      weight: number
      is_cancel: boolean
      description: string | null
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["new_linen_details"]>
    composites: {}
  }

  type new_linen_detailsGetPayload<S extends boolean | null | undefined | new_linen_detailsDefaultArgs> = $Result.GetResult<Prisma.$new_linen_detailsPayload, S>

  type new_linen_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<new_linen_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: New_linen_detailsCountAggregateInputType | true
    }

  export interface new_linen_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['new_linen_details'], meta: { name: 'new_linen_details' } }
    /**
     * Find zero or one New_linen_details that matches the filter.
     * @param {new_linen_detailsFindUniqueArgs} args - Arguments to find a New_linen_details
     * @example
     * // Get one New_linen_details
     * const new_linen_details = await prisma.new_linen_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends new_linen_detailsFindUniqueArgs>(args: SelectSubset<T, new_linen_detailsFindUniqueArgs<ExtArgs>>): Prisma__new_linen_detailsClient<$Result.GetResult<Prisma.$new_linen_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one New_linen_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {new_linen_detailsFindUniqueOrThrowArgs} args - Arguments to find a New_linen_details
     * @example
     * // Get one New_linen_details
     * const new_linen_details = await prisma.new_linen_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends new_linen_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, new_linen_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__new_linen_detailsClient<$Result.GetResult<Prisma.$new_linen_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first New_linen_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linen_detailsFindFirstArgs} args - Arguments to find a New_linen_details
     * @example
     * // Get one New_linen_details
     * const new_linen_details = await prisma.new_linen_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends new_linen_detailsFindFirstArgs>(args?: SelectSubset<T, new_linen_detailsFindFirstArgs<ExtArgs>>): Prisma__new_linen_detailsClient<$Result.GetResult<Prisma.$new_linen_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first New_linen_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linen_detailsFindFirstOrThrowArgs} args - Arguments to find a New_linen_details
     * @example
     * // Get one New_linen_details
     * const new_linen_details = await prisma.new_linen_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends new_linen_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, new_linen_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__new_linen_detailsClient<$Result.GetResult<Prisma.$new_linen_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more New_linen_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linen_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all New_linen_details
     * const new_linen_details = await prisma.new_linen_details.findMany()
     * 
     * // Get first 10 New_linen_details
     * const new_linen_details = await prisma.new_linen_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const new_linen_detailsWithIdOnly = await prisma.new_linen_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends new_linen_detailsFindManyArgs>(args?: SelectSubset<T, new_linen_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$new_linen_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a New_linen_details.
     * @param {new_linen_detailsCreateArgs} args - Arguments to create a New_linen_details.
     * @example
     * // Create one New_linen_details
     * const New_linen_details = await prisma.new_linen_details.create({
     *   data: {
     *     // ... data to create a New_linen_details
     *   }
     * })
     * 
     */
    create<T extends new_linen_detailsCreateArgs>(args: SelectSubset<T, new_linen_detailsCreateArgs<ExtArgs>>): Prisma__new_linen_detailsClient<$Result.GetResult<Prisma.$new_linen_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many New_linen_details.
     * @param {new_linen_detailsCreateManyArgs} args - Arguments to create many New_linen_details.
     * @example
     * // Create many New_linen_details
     * const new_linen_details = await prisma.new_linen_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends new_linen_detailsCreateManyArgs>(args?: SelectSubset<T, new_linen_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a New_linen_details.
     * @param {new_linen_detailsDeleteArgs} args - Arguments to delete one New_linen_details.
     * @example
     * // Delete one New_linen_details
     * const New_linen_details = await prisma.new_linen_details.delete({
     *   where: {
     *     // ... filter to delete one New_linen_details
     *   }
     * })
     * 
     */
    delete<T extends new_linen_detailsDeleteArgs>(args: SelectSubset<T, new_linen_detailsDeleteArgs<ExtArgs>>): Prisma__new_linen_detailsClient<$Result.GetResult<Prisma.$new_linen_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one New_linen_details.
     * @param {new_linen_detailsUpdateArgs} args - Arguments to update one New_linen_details.
     * @example
     * // Update one New_linen_details
     * const new_linen_details = await prisma.new_linen_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends new_linen_detailsUpdateArgs>(args: SelectSubset<T, new_linen_detailsUpdateArgs<ExtArgs>>): Prisma__new_linen_detailsClient<$Result.GetResult<Prisma.$new_linen_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more New_linen_details.
     * @param {new_linen_detailsDeleteManyArgs} args - Arguments to filter New_linen_details to delete.
     * @example
     * // Delete a few New_linen_details
     * const { count } = await prisma.new_linen_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends new_linen_detailsDeleteManyArgs>(args?: SelectSubset<T, new_linen_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more New_linen_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linen_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many New_linen_details
     * const new_linen_details = await prisma.new_linen_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends new_linen_detailsUpdateManyArgs>(args: SelectSubset<T, new_linen_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one New_linen_details.
     * @param {new_linen_detailsUpsertArgs} args - Arguments to update or create a New_linen_details.
     * @example
     * // Update or create a New_linen_details
     * const new_linen_details = await prisma.new_linen_details.upsert({
     *   create: {
     *     // ... data to create a New_linen_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the New_linen_details we want to update
     *   }
     * })
     */
    upsert<T extends new_linen_detailsUpsertArgs>(args: SelectSubset<T, new_linen_detailsUpsertArgs<ExtArgs>>): Prisma__new_linen_detailsClient<$Result.GetResult<Prisma.$new_linen_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of New_linen_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linen_detailsCountArgs} args - Arguments to filter New_linen_details to count.
     * @example
     * // Count the number of New_linen_details
     * const count = await prisma.new_linen_details.count({
     *   where: {
     *     // ... the filter for the New_linen_details we want to count
     *   }
     * })
    **/
    count<T extends new_linen_detailsCountArgs>(
      args?: Subset<T, new_linen_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], New_linen_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a New_linen_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {New_linen_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends New_linen_detailsAggregateArgs>(args: Subset<T, New_linen_detailsAggregateArgs>): Prisma.PrismaPromise<GetNew_linen_detailsAggregateType<T>>

    /**
     * Group by New_linen_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {new_linen_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends new_linen_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: new_linen_detailsGroupByArgs['orderBy'] }
        : { orderBy?: new_linen_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, new_linen_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNew_linen_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the new_linen_details model
   */
  readonly fields: new_linen_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for new_linen_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__new_linen_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the new_linen_details model
   */
  interface new_linen_detailsFieldRefs {
    readonly id: FieldRef<"new_linen_details", 'Int'>
    readonly new_linen_id: FieldRef<"new_linen_details", 'Int'>
    readonly department_id: FieldRef<"new_linen_details", 'Int'>
    readonly item_id: FieldRef<"new_linen_details", 'Int'>
    readonly unit_id: FieldRef<"new_linen_details", 'Int'>
    readonly qty: FieldRef<"new_linen_details", 'Float'>
    readonly receive_qty: FieldRef<"new_linen_details", 'Float'>
    readonly weight: FieldRef<"new_linen_details", 'Float'>
    readonly is_cancel: FieldRef<"new_linen_details", 'Boolean'>
    readonly description: FieldRef<"new_linen_details", 'String'>
    readonly status: FieldRef<"new_linen_details", 'Boolean'>
    readonly create_at: FieldRef<"new_linen_details", 'DateTime'>
    readonly update_at: FieldRef<"new_linen_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * new_linen_details findUnique
   */
  export type new_linen_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
    /**
     * Filter, which new_linen_details to fetch.
     */
    where: new_linen_detailsWhereUniqueInput
  }

  /**
   * new_linen_details findUniqueOrThrow
   */
  export type new_linen_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
    /**
     * Filter, which new_linen_details to fetch.
     */
    where: new_linen_detailsWhereUniqueInput
  }

  /**
   * new_linen_details findFirst
   */
  export type new_linen_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
    /**
     * Filter, which new_linen_details to fetch.
     */
    where?: new_linen_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_linen_details to fetch.
     */
    orderBy?: new_linen_detailsOrderByWithRelationInput | new_linen_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for new_linen_details.
     */
    cursor?: new_linen_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_linen_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_linen_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of new_linen_details.
     */
    distinct?: New_linen_detailsScalarFieldEnum | New_linen_detailsScalarFieldEnum[]
  }

  /**
   * new_linen_details findFirstOrThrow
   */
  export type new_linen_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
    /**
     * Filter, which new_linen_details to fetch.
     */
    where?: new_linen_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_linen_details to fetch.
     */
    orderBy?: new_linen_detailsOrderByWithRelationInput | new_linen_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for new_linen_details.
     */
    cursor?: new_linen_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_linen_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_linen_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of new_linen_details.
     */
    distinct?: New_linen_detailsScalarFieldEnum | New_linen_detailsScalarFieldEnum[]
  }

  /**
   * new_linen_details findMany
   */
  export type new_linen_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
    /**
     * Filter, which new_linen_details to fetch.
     */
    where?: new_linen_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of new_linen_details to fetch.
     */
    orderBy?: new_linen_detailsOrderByWithRelationInput | new_linen_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing new_linen_details.
     */
    cursor?: new_linen_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` new_linen_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` new_linen_details.
     */
    skip?: number
    distinct?: New_linen_detailsScalarFieldEnum | New_linen_detailsScalarFieldEnum[]
  }

  /**
   * new_linen_details create
   */
  export type new_linen_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
    /**
     * The data needed to create a new_linen_details.
     */
    data: XOR<new_linen_detailsCreateInput, new_linen_detailsUncheckedCreateInput>
  }

  /**
   * new_linen_details createMany
   */
  export type new_linen_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many new_linen_details.
     */
    data: new_linen_detailsCreateManyInput | new_linen_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * new_linen_details update
   */
  export type new_linen_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
    /**
     * The data needed to update a new_linen_details.
     */
    data: XOR<new_linen_detailsUpdateInput, new_linen_detailsUncheckedUpdateInput>
    /**
     * Choose, which new_linen_details to update.
     */
    where: new_linen_detailsWhereUniqueInput
  }

  /**
   * new_linen_details updateMany
   */
  export type new_linen_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update new_linen_details.
     */
    data: XOR<new_linen_detailsUpdateManyMutationInput, new_linen_detailsUncheckedUpdateManyInput>
    /**
     * Filter which new_linen_details to update
     */
    where?: new_linen_detailsWhereInput
    /**
     * Limit how many new_linen_details to update.
     */
    limit?: number
  }

  /**
   * new_linen_details upsert
   */
  export type new_linen_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
    /**
     * The filter to search for the new_linen_details to update in case it exists.
     */
    where: new_linen_detailsWhereUniqueInput
    /**
     * In case the new_linen_details found by the `where` argument doesn't exist, create a new new_linen_details with this data.
     */
    create: XOR<new_linen_detailsCreateInput, new_linen_detailsUncheckedCreateInput>
    /**
     * In case the new_linen_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<new_linen_detailsUpdateInput, new_linen_detailsUncheckedUpdateInput>
  }

  /**
   * new_linen_details delete
   */
  export type new_linen_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
    /**
     * Filter which new_linen_details to delete.
     */
    where: new_linen_detailsWhereUniqueInput
  }

  /**
   * new_linen_details deleteMany
   */
  export type new_linen_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which new_linen_details to delete
     */
    where?: new_linen_detailsWhereInput
    /**
     * Limit how many new_linen_details to delete.
     */
    limit?: number
  }

  /**
   * new_linen_details without action
   */
  export type new_linen_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the new_linen_details
     */
    select?: new_linen_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the new_linen_details
     */
    omit?: new_linen_detailsOmit<ExtArgs> | null
  }


  /**
   * Model repair_washs
   */

  export type AggregateRepair_washs = {
    _count: Repair_washsCountAggregateOutputType | null
    _avg: Repair_washsAvgAggregateOutputType | null
    _sum: Repair_washsSumAggregateOutputType | null
    _min: Repair_washsMinAggregateOutputType | null
    _max: Repair_washsMaxAggregateOutputType | null
  }

  export type Repair_washsAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    clean_id: number | null
    total: number | null
    factory_id: number | null
  }

  export type Repair_washsSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    clean_id: number | null
    total: number | null
    factory_id: number | null
  }

  export type Repair_washsMinAggregateOutputType = {
    id: number | null
    doc_no: string | null
    doc_date: Date | null
    ref_doc_no: string | null
    sale_office_id: number | null
    department_id: number | null
    clean_id: number | null
    total: number | null
    is_recive: boolean | null
    receive_date: Date | null
    receive_detail: string | null
    is_process: boolean | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Repair_washsMaxAggregateOutputType = {
    id: number | null
    doc_no: string | null
    doc_date: Date | null
    ref_doc_no: string | null
    sale_office_id: number | null
    department_id: number | null
    clean_id: number | null
    total: number | null
    is_recive: boolean | null
    receive_date: Date | null
    receive_detail: string | null
    is_process: boolean | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Repair_washsCountAggregateOutputType = {
    id: number
    doc_no: number
    doc_date: number
    ref_doc_no: number
    sale_office_id: number
    department_id: number
    clean_id: number
    total: number
    is_recive: number
    receive_date: number
    receive_detail: number
    is_process: number
    sign_factory: number
    sign_NH: number
    sign_factory_time: number
    sign_NH_time: number
    factory_id: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Repair_washsAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    clean_id?: true
    total?: true
    factory_id?: true
  }

  export type Repair_washsSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    clean_id?: true
    total?: true
    factory_id?: true
  }

  export type Repair_washsMinAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    clean_id?: true
    total?: true
    is_recive?: true
    receive_date?: true
    receive_detail?: true
    is_process?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Repair_washsMaxAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    clean_id?: true
    total?: true
    is_recive?: true
    receive_date?: true
    receive_detail?: true
    is_process?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Repair_washsCountAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    clean_id?: true
    total?: true
    is_recive?: true
    receive_date?: true
    receive_detail?: true
    is_process?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Repair_washsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which repair_washs to aggregate.
     */
    where?: repair_washsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repair_washs to fetch.
     */
    orderBy?: repair_washsOrderByWithRelationInput | repair_washsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: repair_washsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repair_washs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repair_washs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned repair_washs
    **/
    _count?: true | Repair_washsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Repair_washsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Repair_washsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Repair_washsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Repair_washsMaxAggregateInputType
  }

  export type GetRepair_washsAggregateType<T extends Repair_washsAggregateArgs> = {
        [P in keyof T & keyof AggregateRepair_washs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepair_washs[P]>
      : GetScalarType<T[P], AggregateRepair_washs[P]>
  }




  export type repair_washsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: repair_washsWhereInput
    orderBy?: repair_washsOrderByWithAggregationInput | repair_washsOrderByWithAggregationInput[]
    by: Repair_washsScalarFieldEnum[] | Repair_washsScalarFieldEnum
    having?: repair_washsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Repair_washsCountAggregateInputType | true
    _avg?: Repair_washsAvgAggregateInputType
    _sum?: Repair_washsSumAggregateInputType
    _min?: Repair_washsMinAggregateInputType
    _max?: Repair_washsMaxAggregateInputType
  }

  export type Repair_washsGroupByOutputType = {
    id: number
    doc_no: string
    doc_date: Date
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    clean_id: number
    total: number
    is_recive: boolean
    receive_date: Date
    receive_detail: string
    is_process: boolean
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date
    sign_NH_time: Date
    factory_id: number
    status: boolean
    create_at: Date
    update_at: Date
    _count: Repair_washsCountAggregateOutputType | null
    _avg: Repair_washsAvgAggregateOutputType | null
    _sum: Repair_washsSumAggregateOutputType | null
    _min: Repair_washsMinAggregateOutputType | null
    _max: Repair_washsMaxAggregateOutputType | null
  }

  type GetRepair_washsGroupByPayload<T extends repair_washsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Repair_washsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Repair_washsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Repair_washsGroupByOutputType[P]>
            : GetScalarType<T[P], Repair_washsGroupByOutputType[P]>
        }
      >
    >


  export type repair_washsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    ref_doc_no?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    clean_id?: boolean
    total?: boolean
    is_recive?: boolean
    receive_date?: boolean
    receive_detail?: boolean
    is_process?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["repair_washs"]>



  export type repair_washsSelectScalar = {
    id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    ref_doc_no?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    clean_id?: boolean
    total?: boolean
    is_recive?: boolean
    receive_date?: boolean
    receive_detail?: boolean
    is_process?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type repair_washsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doc_no" | "doc_date" | "ref_doc_no" | "sale_office_id" | "department_id" | "clean_id" | "total" | "is_recive" | "receive_date" | "receive_detail" | "is_process" | "sign_factory" | "sign_NH" | "sign_factory_time" | "sign_NH_time" | "factory_id" | "status" | "create_at" | "update_at", ExtArgs["result"]["repair_washs"]>

  export type $repair_washsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "repair_washs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doc_no: string
      doc_date: Date
      ref_doc_no: string
      sale_office_id: number
      department_id: number
      clean_id: number
      total: number
      is_recive: boolean
      receive_date: Date
      receive_detail: string
      is_process: boolean
      sign_factory: string
      sign_NH: string
      sign_factory_time: Date
      sign_NH_time: Date
      factory_id: number
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["repair_washs"]>
    composites: {}
  }

  type repair_washsGetPayload<S extends boolean | null | undefined | repair_washsDefaultArgs> = $Result.GetResult<Prisma.$repair_washsPayload, S>

  type repair_washsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<repair_washsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Repair_washsCountAggregateInputType | true
    }

  export interface repair_washsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['repair_washs'], meta: { name: 'repair_washs' } }
    /**
     * Find zero or one Repair_washs that matches the filter.
     * @param {repair_washsFindUniqueArgs} args - Arguments to find a Repair_washs
     * @example
     * // Get one Repair_washs
     * const repair_washs = await prisma.repair_washs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends repair_washsFindUniqueArgs>(args: SelectSubset<T, repair_washsFindUniqueArgs<ExtArgs>>): Prisma__repair_washsClient<$Result.GetResult<Prisma.$repair_washsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Repair_washs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {repair_washsFindUniqueOrThrowArgs} args - Arguments to find a Repair_washs
     * @example
     * // Get one Repair_washs
     * const repair_washs = await prisma.repair_washs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends repair_washsFindUniqueOrThrowArgs>(args: SelectSubset<T, repair_washsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__repair_washsClient<$Result.GetResult<Prisma.$repair_washsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repair_washs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_washsFindFirstArgs} args - Arguments to find a Repair_washs
     * @example
     * // Get one Repair_washs
     * const repair_washs = await prisma.repair_washs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends repair_washsFindFirstArgs>(args?: SelectSubset<T, repair_washsFindFirstArgs<ExtArgs>>): Prisma__repair_washsClient<$Result.GetResult<Prisma.$repair_washsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repair_washs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_washsFindFirstOrThrowArgs} args - Arguments to find a Repair_washs
     * @example
     * // Get one Repair_washs
     * const repair_washs = await prisma.repair_washs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends repair_washsFindFirstOrThrowArgs>(args?: SelectSubset<T, repair_washsFindFirstOrThrowArgs<ExtArgs>>): Prisma__repair_washsClient<$Result.GetResult<Prisma.$repair_washsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Repair_washs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_washsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Repair_washs
     * const repair_washs = await prisma.repair_washs.findMany()
     * 
     * // Get first 10 Repair_washs
     * const repair_washs = await prisma.repair_washs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repair_washsWithIdOnly = await prisma.repair_washs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends repair_washsFindManyArgs>(args?: SelectSubset<T, repair_washsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$repair_washsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Repair_washs.
     * @param {repair_washsCreateArgs} args - Arguments to create a Repair_washs.
     * @example
     * // Create one Repair_washs
     * const Repair_washs = await prisma.repair_washs.create({
     *   data: {
     *     // ... data to create a Repair_washs
     *   }
     * })
     * 
     */
    create<T extends repair_washsCreateArgs>(args: SelectSubset<T, repair_washsCreateArgs<ExtArgs>>): Prisma__repair_washsClient<$Result.GetResult<Prisma.$repair_washsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Repair_washs.
     * @param {repair_washsCreateManyArgs} args - Arguments to create many Repair_washs.
     * @example
     * // Create many Repair_washs
     * const repair_washs = await prisma.repair_washs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends repair_washsCreateManyArgs>(args?: SelectSubset<T, repair_washsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Repair_washs.
     * @param {repair_washsDeleteArgs} args - Arguments to delete one Repair_washs.
     * @example
     * // Delete one Repair_washs
     * const Repair_washs = await prisma.repair_washs.delete({
     *   where: {
     *     // ... filter to delete one Repair_washs
     *   }
     * })
     * 
     */
    delete<T extends repair_washsDeleteArgs>(args: SelectSubset<T, repair_washsDeleteArgs<ExtArgs>>): Prisma__repair_washsClient<$Result.GetResult<Prisma.$repair_washsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Repair_washs.
     * @param {repair_washsUpdateArgs} args - Arguments to update one Repair_washs.
     * @example
     * // Update one Repair_washs
     * const repair_washs = await prisma.repair_washs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends repair_washsUpdateArgs>(args: SelectSubset<T, repair_washsUpdateArgs<ExtArgs>>): Prisma__repair_washsClient<$Result.GetResult<Prisma.$repair_washsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Repair_washs.
     * @param {repair_washsDeleteManyArgs} args - Arguments to filter Repair_washs to delete.
     * @example
     * // Delete a few Repair_washs
     * const { count } = await prisma.repair_washs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends repair_washsDeleteManyArgs>(args?: SelectSubset<T, repair_washsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Repair_washs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_washsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Repair_washs
     * const repair_washs = await prisma.repair_washs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends repair_washsUpdateManyArgs>(args: SelectSubset<T, repair_washsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Repair_washs.
     * @param {repair_washsUpsertArgs} args - Arguments to update or create a Repair_washs.
     * @example
     * // Update or create a Repair_washs
     * const repair_washs = await prisma.repair_washs.upsert({
     *   create: {
     *     // ... data to create a Repair_washs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Repair_washs we want to update
     *   }
     * })
     */
    upsert<T extends repair_washsUpsertArgs>(args: SelectSubset<T, repair_washsUpsertArgs<ExtArgs>>): Prisma__repair_washsClient<$Result.GetResult<Prisma.$repair_washsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Repair_washs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_washsCountArgs} args - Arguments to filter Repair_washs to count.
     * @example
     * // Count the number of Repair_washs
     * const count = await prisma.repair_washs.count({
     *   where: {
     *     // ... the filter for the Repair_washs we want to count
     *   }
     * })
    **/
    count<T extends repair_washsCountArgs>(
      args?: Subset<T, repair_washsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Repair_washsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Repair_washs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Repair_washsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Repair_washsAggregateArgs>(args: Subset<T, Repair_washsAggregateArgs>): Prisma.PrismaPromise<GetRepair_washsAggregateType<T>>

    /**
     * Group by Repair_washs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_washsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends repair_washsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: repair_washsGroupByArgs['orderBy'] }
        : { orderBy?: repair_washsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, repair_washsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepair_washsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the repair_washs model
   */
  readonly fields: repair_washsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for repair_washs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__repair_washsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the repair_washs model
   */
  interface repair_washsFieldRefs {
    readonly id: FieldRef<"repair_washs", 'Int'>
    readonly doc_no: FieldRef<"repair_washs", 'String'>
    readonly doc_date: FieldRef<"repair_washs", 'DateTime'>
    readonly ref_doc_no: FieldRef<"repair_washs", 'String'>
    readonly sale_office_id: FieldRef<"repair_washs", 'Int'>
    readonly department_id: FieldRef<"repair_washs", 'Int'>
    readonly clean_id: FieldRef<"repair_washs", 'Int'>
    readonly total: FieldRef<"repair_washs", 'Float'>
    readonly is_recive: FieldRef<"repair_washs", 'Boolean'>
    readonly receive_date: FieldRef<"repair_washs", 'DateTime'>
    readonly receive_detail: FieldRef<"repair_washs", 'String'>
    readonly is_process: FieldRef<"repair_washs", 'Boolean'>
    readonly sign_factory: FieldRef<"repair_washs", 'String'>
    readonly sign_NH: FieldRef<"repair_washs", 'String'>
    readonly sign_factory_time: FieldRef<"repair_washs", 'DateTime'>
    readonly sign_NH_time: FieldRef<"repair_washs", 'DateTime'>
    readonly factory_id: FieldRef<"repair_washs", 'Int'>
    readonly status: FieldRef<"repair_washs", 'Boolean'>
    readonly create_at: FieldRef<"repair_washs", 'DateTime'>
    readonly update_at: FieldRef<"repair_washs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * repair_washs findUnique
   */
  export type repair_washsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
    /**
     * Filter, which repair_washs to fetch.
     */
    where: repair_washsWhereUniqueInput
  }

  /**
   * repair_washs findUniqueOrThrow
   */
  export type repair_washsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
    /**
     * Filter, which repair_washs to fetch.
     */
    where: repair_washsWhereUniqueInput
  }

  /**
   * repair_washs findFirst
   */
  export type repair_washsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
    /**
     * Filter, which repair_washs to fetch.
     */
    where?: repair_washsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repair_washs to fetch.
     */
    orderBy?: repair_washsOrderByWithRelationInput | repair_washsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for repair_washs.
     */
    cursor?: repair_washsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repair_washs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repair_washs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of repair_washs.
     */
    distinct?: Repair_washsScalarFieldEnum | Repair_washsScalarFieldEnum[]
  }

  /**
   * repair_washs findFirstOrThrow
   */
  export type repair_washsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
    /**
     * Filter, which repair_washs to fetch.
     */
    where?: repair_washsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repair_washs to fetch.
     */
    orderBy?: repair_washsOrderByWithRelationInput | repair_washsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for repair_washs.
     */
    cursor?: repair_washsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repair_washs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repair_washs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of repair_washs.
     */
    distinct?: Repair_washsScalarFieldEnum | Repair_washsScalarFieldEnum[]
  }

  /**
   * repair_washs findMany
   */
  export type repair_washsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
    /**
     * Filter, which repair_washs to fetch.
     */
    where?: repair_washsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repair_washs to fetch.
     */
    orderBy?: repair_washsOrderByWithRelationInput | repair_washsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing repair_washs.
     */
    cursor?: repair_washsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repair_washs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repair_washs.
     */
    skip?: number
    distinct?: Repair_washsScalarFieldEnum | Repair_washsScalarFieldEnum[]
  }

  /**
   * repair_washs create
   */
  export type repair_washsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
    /**
     * The data needed to create a repair_washs.
     */
    data: XOR<repair_washsCreateInput, repair_washsUncheckedCreateInput>
  }

  /**
   * repair_washs createMany
   */
  export type repair_washsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many repair_washs.
     */
    data: repair_washsCreateManyInput | repair_washsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * repair_washs update
   */
  export type repair_washsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
    /**
     * The data needed to update a repair_washs.
     */
    data: XOR<repair_washsUpdateInput, repair_washsUncheckedUpdateInput>
    /**
     * Choose, which repair_washs to update.
     */
    where: repair_washsWhereUniqueInput
  }

  /**
   * repair_washs updateMany
   */
  export type repair_washsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update repair_washs.
     */
    data: XOR<repair_washsUpdateManyMutationInput, repair_washsUncheckedUpdateManyInput>
    /**
     * Filter which repair_washs to update
     */
    where?: repair_washsWhereInput
    /**
     * Limit how many repair_washs to update.
     */
    limit?: number
  }

  /**
   * repair_washs upsert
   */
  export type repair_washsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
    /**
     * The filter to search for the repair_washs to update in case it exists.
     */
    where: repair_washsWhereUniqueInput
    /**
     * In case the repair_washs found by the `where` argument doesn't exist, create a new repair_washs with this data.
     */
    create: XOR<repair_washsCreateInput, repair_washsUncheckedCreateInput>
    /**
     * In case the repair_washs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<repair_washsUpdateInput, repair_washsUncheckedUpdateInput>
  }

  /**
   * repair_washs delete
   */
  export type repair_washsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
    /**
     * Filter which repair_washs to delete.
     */
    where: repair_washsWhereUniqueInput
  }

  /**
   * repair_washs deleteMany
   */
  export type repair_washsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which repair_washs to delete
     */
    where?: repair_washsWhereInput
    /**
     * Limit how many repair_washs to delete.
     */
    limit?: number
  }

  /**
   * repair_washs without action
   */
  export type repair_washsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_washs
     */
    select?: repair_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_washs
     */
    omit?: repair_washsOmit<ExtArgs> | null
  }


  /**
   * Model repair_wash_details
   */

  export type AggregateRepair_wash_details = {
    _count: Repair_wash_detailsCountAggregateOutputType | null
    _avg: Repair_wash_detailsAvgAggregateOutputType | null
    _sum: Repair_wash_detailsSumAggregateOutputType | null
    _min: Repair_wash_detailsMinAggregateOutputType | null
    _max: Repair_wash_detailsMaxAggregateOutputType | null
  }

  export type Repair_wash_detailsAvgAggregateOutputType = {
    id: number | null
    repair_wash_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
  }

  export type Repair_wash_detailsSumAggregateOutputType = {
    id: number | null
    repair_wash_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
  }

  export type Repair_wash_detailsMinAggregateOutputType = {
    id: number | null
    repair_wash_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
    is_cancel: boolean | null
    is_checklist: boolean | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Repair_wash_detailsMaxAggregateOutputType = {
    id: number | null
    repair_wash_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    receive_qty: number | null
    weight: number | null
    is_cancel: boolean | null
    is_checklist: boolean | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Repair_wash_detailsCountAggregateOutputType = {
    id: number
    repair_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: number
    is_checklist: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Repair_wash_detailsAvgAggregateInputType = {
    id?: true
    repair_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
  }

  export type Repair_wash_detailsSumAggregateInputType = {
    id?: true
    repair_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
  }

  export type Repair_wash_detailsMinAggregateInputType = {
    id?: true
    repair_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
    is_cancel?: true
    is_checklist?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Repair_wash_detailsMaxAggregateInputType = {
    id?: true
    repair_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
    is_cancel?: true
    is_checklist?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Repair_wash_detailsCountAggregateInputType = {
    id?: true
    repair_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    receive_qty?: true
    weight?: true
    is_cancel?: true
    is_checklist?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Repair_wash_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which repair_wash_details to aggregate.
     */
    where?: repair_wash_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repair_wash_details to fetch.
     */
    orderBy?: repair_wash_detailsOrderByWithRelationInput | repair_wash_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: repair_wash_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repair_wash_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repair_wash_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned repair_wash_details
    **/
    _count?: true | Repair_wash_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Repair_wash_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Repair_wash_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Repair_wash_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Repair_wash_detailsMaxAggregateInputType
  }

  export type GetRepair_wash_detailsAggregateType<T extends Repair_wash_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateRepair_wash_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepair_wash_details[P]>
      : GetScalarType<T[P], AggregateRepair_wash_details[P]>
  }




  export type repair_wash_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: repair_wash_detailsWhereInput
    orderBy?: repair_wash_detailsOrderByWithAggregationInput | repair_wash_detailsOrderByWithAggregationInput[]
    by: Repair_wash_detailsScalarFieldEnum[] | Repair_wash_detailsScalarFieldEnum
    having?: repair_wash_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Repair_wash_detailsCountAggregateInputType | true
    _avg?: Repair_wash_detailsAvgAggregateInputType
    _sum?: Repair_wash_detailsSumAggregateInputType
    _min?: Repair_wash_detailsMinAggregateInputType
    _max?: Repair_wash_detailsMaxAggregateInputType
  }

  export type Repair_wash_detailsGroupByOutputType = {
    id: number
    repair_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Repair_wash_detailsCountAggregateOutputType | null
    _avg: Repair_wash_detailsAvgAggregateOutputType | null
    _sum: Repair_wash_detailsSumAggregateOutputType | null
    _min: Repair_wash_detailsMinAggregateOutputType | null
    _max: Repair_wash_detailsMaxAggregateOutputType | null
  }

  type GetRepair_wash_detailsGroupByPayload<T extends repair_wash_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Repair_wash_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Repair_wash_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Repair_wash_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Repair_wash_detailsGroupByOutputType[P]>
        }
      >
    >


  export type repair_wash_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    repair_wash_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    receive_qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    is_checklist?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["repair_wash_details"]>



  export type repair_wash_detailsSelectScalar = {
    id?: boolean
    repair_wash_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    receive_qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    is_checklist?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type repair_wash_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "repair_wash_id" | "item_id" | "unit_id" | "qty" | "receive_qty" | "weight" | "is_cancel" | "is_checklist" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["repair_wash_details"]>

  export type $repair_wash_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "repair_wash_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      repair_wash_id: number
      item_id: number
      unit_id: number
      qty: number
      receive_qty: number
      weight: number
      is_cancel: boolean
      is_checklist: boolean
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["repair_wash_details"]>
    composites: {}
  }

  type repair_wash_detailsGetPayload<S extends boolean | null | undefined | repair_wash_detailsDefaultArgs> = $Result.GetResult<Prisma.$repair_wash_detailsPayload, S>

  type repair_wash_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<repair_wash_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Repair_wash_detailsCountAggregateInputType | true
    }

  export interface repair_wash_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['repair_wash_details'], meta: { name: 'repair_wash_details' } }
    /**
     * Find zero or one Repair_wash_details that matches the filter.
     * @param {repair_wash_detailsFindUniqueArgs} args - Arguments to find a Repair_wash_details
     * @example
     * // Get one Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends repair_wash_detailsFindUniqueArgs>(args: SelectSubset<T, repair_wash_detailsFindUniqueArgs<ExtArgs>>): Prisma__repair_wash_detailsClient<$Result.GetResult<Prisma.$repair_wash_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Repair_wash_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {repair_wash_detailsFindUniqueOrThrowArgs} args - Arguments to find a Repair_wash_details
     * @example
     * // Get one Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends repair_wash_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, repair_wash_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__repair_wash_detailsClient<$Result.GetResult<Prisma.$repair_wash_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repair_wash_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_wash_detailsFindFirstArgs} args - Arguments to find a Repair_wash_details
     * @example
     * // Get one Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends repair_wash_detailsFindFirstArgs>(args?: SelectSubset<T, repair_wash_detailsFindFirstArgs<ExtArgs>>): Prisma__repair_wash_detailsClient<$Result.GetResult<Prisma.$repair_wash_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Repair_wash_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_wash_detailsFindFirstOrThrowArgs} args - Arguments to find a Repair_wash_details
     * @example
     * // Get one Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends repair_wash_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, repair_wash_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__repair_wash_detailsClient<$Result.GetResult<Prisma.$repair_wash_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Repair_wash_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_wash_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.findMany()
     * 
     * // Get first 10 Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repair_wash_detailsWithIdOnly = await prisma.repair_wash_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends repair_wash_detailsFindManyArgs>(args?: SelectSubset<T, repair_wash_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$repair_wash_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Repair_wash_details.
     * @param {repair_wash_detailsCreateArgs} args - Arguments to create a Repair_wash_details.
     * @example
     * // Create one Repair_wash_details
     * const Repair_wash_details = await prisma.repair_wash_details.create({
     *   data: {
     *     // ... data to create a Repair_wash_details
     *   }
     * })
     * 
     */
    create<T extends repair_wash_detailsCreateArgs>(args: SelectSubset<T, repair_wash_detailsCreateArgs<ExtArgs>>): Prisma__repair_wash_detailsClient<$Result.GetResult<Prisma.$repair_wash_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Repair_wash_details.
     * @param {repair_wash_detailsCreateManyArgs} args - Arguments to create many Repair_wash_details.
     * @example
     * // Create many Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends repair_wash_detailsCreateManyArgs>(args?: SelectSubset<T, repair_wash_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Repair_wash_details.
     * @param {repair_wash_detailsDeleteArgs} args - Arguments to delete one Repair_wash_details.
     * @example
     * // Delete one Repair_wash_details
     * const Repair_wash_details = await prisma.repair_wash_details.delete({
     *   where: {
     *     // ... filter to delete one Repair_wash_details
     *   }
     * })
     * 
     */
    delete<T extends repair_wash_detailsDeleteArgs>(args: SelectSubset<T, repair_wash_detailsDeleteArgs<ExtArgs>>): Prisma__repair_wash_detailsClient<$Result.GetResult<Prisma.$repair_wash_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Repair_wash_details.
     * @param {repair_wash_detailsUpdateArgs} args - Arguments to update one Repair_wash_details.
     * @example
     * // Update one Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends repair_wash_detailsUpdateArgs>(args: SelectSubset<T, repair_wash_detailsUpdateArgs<ExtArgs>>): Prisma__repair_wash_detailsClient<$Result.GetResult<Prisma.$repair_wash_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Repair_wash_details.
     * @param {repair_wash_detailsDeleteManyArgs} args - Arguments to filter Repair_wash_details to delete.
     * @example
     * // Delete a few Repair_wash_details
     * const { count } = await prisma.repair_wash_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends repair_wash_detailsDeleteManyArgs>(args?: SelectSubset<T, repair_wash_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Repair_wash_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_wash_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends repair_wash_detailsUpdateManyArgs>(args: SelectSubset<T, repair_wash_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Repair_wash_details.
     * @param {repair_wash_detailsUpsertArgs} args - Arguments to update or create a Repair_wash_details.
     * @example
     * // Update or create a Repair_wash_details
     * const repair_wash_details = await prisma.repair_wash_details.upsert({
     *   create: {
     *     // ... data to create a Repair_wash_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Repair_wash_details we want to update
     *   }
     * })
     */
    upsert<T extends repair_wash_detailsUpsertArgs>(args: SelectSubset<T, repair_wash_detailsUpsertArgs<ExtArgs>>): Prisma__repair_wash_detailsClient<$Result.GetResult<Prisma.$repair_wash_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Repair_wash_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_wash_detailsCountArgs} args - Arguments to filter Repair_wash_details to count.
     * @example
     * // Count the number of Repair_wash_details
     * const count = await prisma.repair_wash_details.count({
     *   where: {
     *     // ... the filter for the Repair_wash_details we want to count
     *   }
     * })
    **/
    count<T extends repair_wash_detailsCountArgs>(
      args?: Subset<T, repair_wash_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Repair_wash_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Repair_wash_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Repair_wash_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Repair_wash_detailsAggregateArgs>(args: Subset<T, Repair_wash_detailsAggregateArgs>): Prisma.PrismaPromise<GetRepair_wash_detailsAggregateType<T>>

    /**
     * Group by Repair_wash_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {repair_wash_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends repair_wash_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: repair_wash_detailsGroupByArgs['orderBy'] }
        : { orderBy?: repair_wash_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, repair_wash_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepair_wash_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the repair_wash_details model
   */
  readonly fields: repair_wash_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for repair_wash_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__repair_wash_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the repair_wash_details model
   */
  interface repair_wash_detailsFieldRefs {
    readonly id: FieldRef<"repair_wash_details", 'Int'>
    readonly repair_wash_id: FieldRef<"repair_wash_details", 'Int'>
    readonly item_id: FieldRef<"repair_wash_details", 'Int'>
    readonly unit_id: FieldRef<"repair_wash_details", 'Int'>
    readonly qty: FieldRef<"repair_wash_details", 'Float'>
    readonly receive_qty: FieldRef<"repair_wash_details", 'Float'>
    readonly weight: FieldRef<"repair_wash_details", 'Float'>
    readonly is_cancel: FieldRef<"repair_wash_details", 'Boolean'>
    readonly is_checklist: FieldRef<"repair_wash_details", 'Boolean'>
    readonly description: FieldRef<"repair_wash_details", 'String'>
    readonly status: FieldRef<"repair_wash_details", 'Boolean'>
    readonly create_at: FieldRef<"repair_wash_details", 'DateTime'>
    readonly update_at: FieldRef<"repair_wash_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * repair_wash_details findUnique
   */
  export type repair_wash_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which repair_wash_details to fetch.
     */
    where: repair_wash_detailsWhereUniqueInput
  }

  /**
   * repair_wash_details findUniqueOrThrow
   */
  export type repair_wash_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which repair_wash_details to fetch.
     */
    where: repair_wash_detailsWhereUniqueInput
  }

  /**
   * repair_wash_details findFirst
   */
  export type repair_wash_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which repair_wash_details to fetch.
     */
    where?: repair_wash_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repair_wash_details to fetch.
     */
    orderBy?: repair_wash_detailsOrderByWithRelationInput | repair_wash_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for repair_wash_details.
     */
    cursor?: repair_wash_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repair_wash_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repair_wash_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of repair_wash_details.
     */
    distinct?: Repair_wash_detailsScalarFieldEnum | Repair_wash_detailsScalarFieldEnum[]
  }

  /**
   * repair_wash_details findFirstOrThrow
   */
  export type repair_wash_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which repair_wash_details to fetch.
     */
    where?: repair_wash_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repair_wash_details to fetch.
     */
    orderBy?: repair_wash_detailsOrderByWithRelationInput | repair_wash_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for repair_wash_details.
     */
    cursor?: repair_wash_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repair_wash_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repair_wash_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of repair_wash_details.
     */
    distinct?: Repair_wash_detailsScalarFieldEnum | Repair_wash_detailsScalarFieldEnum[]
  }

  /**
   * repair_wash_details findMany
   */
  export type repair_wash_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which repair_wash_details to fetch.
     */
    where?: repair_wash_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of repair_wash_details to fetch.
     */
    orderBy?: repair_wash_detailsOrderByWithRelationInput | repair_wash_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing repair_wash_details.
     */
    cursor?: repair_wash_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` repair_wash_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` repair_wash_details.
     */
    skip?: number
    distinct?: Repair_wash_detailsScalarFieldEnum | Repair_wash_detailsScalarFieldEnum[]
  }

  /**
   * repair_wash_details create
   */
  export type repair_wash_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
    /**
     * The data needed to create a repair_wash_details.
     */
    data: XOR<repair_wash_detailsCreateInput, repair_wash_detailsUncheckedCreateInput>
  }

  /**
   * repair_wash_details createMany
   */
  export type repair_wash_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many repair_wash_details.
     */
    data: repair_wash_detailsCreateManyInput | repair_wash_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * repair_wash_details update
   */
  export type repair_wash_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
    /**
     * The data needed to update a repair_wash_details.
     */
    data: XOR<repair_wash_detailsUpdateInput, repair_wash_detailsUncheckedUpdateInput>
    /**
     * Choose, which repair_wash_details to update.
     */
    where: repair_wash_detailsWhereUniqueInput
  }

  /**
   * repair_wash_details updateMany
   */
  export type repair_wash_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update repair_wash_details.
     */
    data: XOR<repair_wash_detailsUpdateManyMutationInput, repair_wash_detailsUncheckedUpdateManyInput>
    /**
     * Filter which repair_wash_details to update
     */
    where?: repair_wash_detailsWhereInput
    /**
     * Limit how many repair_wash_details to update.
     */
    limit?: number
  }

  /**
   * repair_wash_details upsert
   */
  export type repair_wash_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
    /**
     * The filter to search for the repair_wash_details to update in case it exists.
     */
    where: repair_wash_detailsWhereUniqueInput
    /**
     * In case the repair_wash_details found by the `where` argument doesn't exist, create a new repair_wash_details with this data.
     */
    create: XOR<repair_wash_detailsCreateInput, repair_wash_detailsUncheckedCreateInput>
    /**
     * In case the repair_wash_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<repair_wash_detailsUpdateInput, repair_wash_detailsUncheckedUpdateInput>
  }

  /**
   * repair_wash_details delete
   */
  export type repair_wash_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter which repair_wash_details to delete.
     */
    where: repair_wash_detailsWhereUniqueInput
  }

  /**
   * repair_wash_details deleteMany
   */
  export type repair_wash_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which repair_wash_details to delete
     */
    where?: repair_wash_detailsWhereInput
    /**
     * Limit how many repair_wash_details to delete.
     */
    limit?: number
  }

  /**
   * repair_wash_details without action
   */
  export type repair_wash_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the repair_wash_details
     */
    select?: repair_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the repair_wash_details
     */
    omit?: repair_wash_detailsOmit<ExtArgs> | null
  }


  /**
   * Model cleans
   */

  export type AggregateCleans = {
    _count: CleansCountAggregateOutputType | null
    _avg: CleansAvgAggregateOutputType | null
    _sum: CleansSumAggregateOutputType | null
    _min: CleansMinAggregateOutputType | null
    _max: CleansMaxAggregateOutputType | null
  }

  export type CleansAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    dirty_id: number | null
    user_id: number | null
    factory_id: number | null
  }

  export type CleansSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    dirty_id: number | null
    user_id: number | null
    factory_id: number | null
  }

  export type CleansMinAggregateOutputType = {
    id: number | null
    clean_doc_no: string | null
    doc_date: Date | null
    sale_office_id: number | null
    department_id: number | null
    dirty_id: number | null
    user_id: number | null
    signature: string | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type CleansMaxAggregateOutputType = {
    id: number | null
    clean_doc_no: string | null
    doc_date: Date | null
    sale_office_id: number | null
    department_id: number | null
    dirty_id: number | null
    user_id: number | null
    signature: string | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type CleansCountAggregateOutputType = {
    id: number
    clean_doc_no: number
    doc_date: number
    sale_office_id: number
    department_id: number
    dirty_id: number
    user_id: number
    signature: number
    sign_factory: number
    sign_NH: number
    sign_factory_time: number
    sign_NH_time: number
    factory_id: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type CleansAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    dirty_id?: true
    user_id?: true
    factory_id?: true
  }

  export type CleansSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    dirty_id?: true
    user_id?: true
    factory_id?: true
  }

  export type CleansMinAggregateInputType = {
    id?: true
    clean_doc_no?: true
    doc_date?: true
    sale_office_id?: true
    department_id?: true
    dirty_id?: true
    user_id?: true
    signature?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type CleansMaxAggregateInputType = {
    id?: true
    clean_doc_no?: true
    doc_date?: true
    sale_office_id?: true
    department_id?: true
    dirty_id?: true
    user_id?: true
    signature?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type CleansCountAggregateInputType = {
    id?: true
    clean_doc_no?: true
    doc_date?: true
    sale_office_id?: true
    department_id?: true
    dirty_id?: true
    user_id?: true
    signature?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type CleansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cleans to aggregate.
     */
    where?: cleansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cleans to fetch.
     */
    orderBy?: cleansOrderByWithRelationInput | cleansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cleansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cleans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cleans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cleans
    **/
    _count?: true | CleansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CleansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CleansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleansMaxAggregateInputType
  }

  export type GetCleansAggregateType<T extends CleansAggregateArgs> = {
        [P in keyof T & keyof AggregateCleans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleans[P]>
      : GetScalarType<T[P], AggregateCleans[P]>
  }




  export type cleansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cleansWhereInput
    orderBy?: cleansOrderByWithAggregationInput | cleansOrderByWithAggregationInput[]
    by: CleansScalarFieldEnum[] | CleansScalarFieldEnum
    having?: cleansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleansCountAggregateInputType | true
    _avg?: CleansAvgAggregateInputType
    _sum?: CleansSumAggregateInputType
    _min?: CleansMinAggregateInputType
    _max?: CleansMaxAggregateInputType
  }

  export type CleansGroupByOutputType = {
    id: number
    clean_doc_no: string
    doc_date: Date
    sale_office_id: number
    department_id: number
    dirty_id: number
    user_id: number
    signature: string
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date
    sign_NH_time: Date
    factory_id: number
    status: boolean
    create_at: Date
    update_at: Date
    _count: CleansCountAggregateOutputType | null
    _avg: CleansAvgAggregateOutputType | null
    _sum: CleansSumAggregateOutputType | null
    _min: CleansMinAggregateOutputType | null
    _max: CleansMaxAggregateOutputType | null
  }

  type GetCleansGroupByPayload<T extends cleansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleansGroupByOutputType[P]>
            : GetScalarType<T[P], CleansGroupByOutputType[P]>
        }
      >
    >


  export type cleansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clean_doc_no?: boolean
    doc_date?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    dirty_id?: boolean
    user_id?: boolean
    signature?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["cleans"]>



  export type cleansSelectScalar = {
    id?: boolean
    clean_doc_no?: boolean
    doc_date?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    dirty_id?: boolean
    user_id?: boolean
    signature?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type cleansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clean_doc_no" | "doc_date" | "sale_office_id" | "department_id" | "dirty_id" | "user_id" | "signature" | "sign_factory" | "sign_NH" | "sign_factory_time" | "sign_NH_time" | "factory_id" | "status" | "create_at" | "update_at", ExtArgs["result"]["cleans"]>

  export type $cleansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cleans"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clean_doc_no: string
      doc_date: Date
      sale_office_id: number
      department_id: number
      dirty_id: number
      user_id: number
      signature: string
      sign_factory: string
      sign_NH: string
      sign_factory_time: Date
      sign_NH_time: Date
      factory_id: number
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["cleans"]>
    composites: {}
  }

  type cleansGetPayload<S extends boolean | null | undefined | cleansDefaultArgs> = $Result.GetResult<Prisma.$cleansPayload, S>

  type cleansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cleansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleansCountAggregateInputType | true
    }

  export interface cleansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cleans'], meta: { name: 'cleans' } }
    /**
     * Find zero or one Cleans that matches the filter.
     * @param {cleansFindUniqueArgs} args - Arguments to find a Cleans
     * @example
     * // Get one Cleans
     * const cleans = await prisma.cleans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cleansFindUniqueArgs>(args: SelectSubset<T, cleansFindUniqueArgs<ExtArgs>>): Prisma__cleansClient<$Result.GetResult<Prisma.$cleansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cleans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cleansFindUniqueOrThrowArgs} args - Arguments to find a Cleans
     * @example
     * // Get one Cleans
     * const cleans = await prisma.cleans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cleansFindUniqueOrThrowArgs>(args: SelectSubset<T, cleansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cleansClient<$Result.GetResult<Prisma.$cleansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cleans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleansFindFirstArgs} args - Arguments to find a Cleans
     * @example
     * // Get one Cleans
     * const cleans = await prisma.cleans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cleansFindFirstArgs>(args?: SelectSubset<T, cleansFindFirstArgs<ExtArgs>>): Prisma__cleansClient<$Result.GetResult<Prisma.$cleansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cleans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleansFindFirstOrThrowArgs} args - Arguments to find a Cleans
     * @example
     * // Get one Cleans
     * const cleans = await prisma.cleans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cleansFindFirstOrThrowArgs>(args?: SelectSubset<T, cleansFindFirstOrThrowArgs<ExtArgs>>): Prisma__cleansClient<$Result.GetResult<Prisma.$cleansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cleans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cleans
     * const cleans = await prisma.cleans.findMany()
     * 
     * // Get first 10 Cleans
     * const cleans = await prisma.cleans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleansWithIdOnly = await prisma.cleans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cleansFindManyArgs>(args?: SelectSubset<T, cleansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cleansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cleans.
     * @param {cleansCreateArgs} args - Arguments to create a Cleans.
     * @example
     * // Create one Cleans
     * const Cleans = await prisma.cleans.create({
     *   data: {
     *     // ... data to create a Cleans
     *   }
     * })
     * 
     */
    create<T extends cleansCreateArgs>(args: SelectSubset<T, cleansCreateArgs<ExtArgs>>): Prisma__cleansClient<$Result.GetResult<Prisma.$cleansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cleans.
     * @param {cleansCreateManyArgs} args - Arguments to create many Cleans.
     * @example
     * // Create many Cleans
     * const cleans = await prisma.cleans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cleansCreateManyArgs>(args?: SelectSubset<T, cleansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cleans.
     * @param {cleansDeleteArgs} args - Arguments to delete one Cleans.
     * @example
     * // Delete one Cleans
     * const Cleans = await prisma.cleans.delete({
     *   where: {
     *     // ... filter to delete one Cleans
     *   }
     * })
     * 
     */
    delete<T extends cleansDeleteArgs>(args: SelectSubset<T, cleansDeleteArgs<ExtArgs>>): Prisma__cleansClient<$Result.GetResult<Prisma.$cleansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cleans.
     * @param {cleansUpdateArgs} args - Arguments to update one Cleans.
     * @example
     * // Update one Cleans
     * const cleans = await prisma.cleans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cleansUpdateArgs>(args: SelectSubset<T, cleansUpdateArgs<ExtArgs>>): Prisma__cleansClient<$Result.GetResult<Prisma.$cleansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cleans.
     * @param {cleansDeleteManyArgs} args - Arguments to filter Cleans to delete.
     * @example
     * // Delete a few Cleans
     * const { count } = await prisma.cleans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cleansDeleteManyArgs>(args?: SelectSubset<T, cleansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cleans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cleans
     * const cleans = await prisma.cleans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cleansUpdateManyArgs>(args: SelectSubset<T, cleansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cleans.
     * @param {cleansUpsertArgs} args - Arguments to update or create a Cleans.
     * @example
     * // Update or create a Cleans
     * const cleans = await prisma.cleans.upsert({
     *   create: {
     *     // ... data to create a Cleans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cleans we want to update
     *   }
     * })
     */
    upsert<T extends cleansUpsertArgs>(args: SelectSubset<T, cleansUpsertArgs<ExtArgs>>): Prisma__cleansClient<$Result.GetResult<Prisma.$cleansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cleans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleansCountArgs} args - Arguments to filter Cleans to count.
     * @example
     * // Count the number of Cleans
     * const count = await prisma.cleans.count({
     *   where: {
     *     // ... the filter for the Cleans we want to count
     *   }
     * })
    **/
    count<T extends cleansCountArgs>(
      args?: Subset<T, cleansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cleans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleansAggregateArgs>(args: Subset<T, CleansAggregateArgs>): Prisma.PrismaPromise<GetCleansAggregateType<T>>

    /**
     * Group by Cleans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cleansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cleansGroupByArgs['orderBy'] }
        : { orderBy?: cleansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cleansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cleans model
   */
  readonly fields: cleansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cleans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cleansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cleans model
   */
  interface cleansFieldRefs {
    readonly id: FieldRef<"cleans", 'Int'>
    readonly clean_doc_no: FieldRef<"cleans", 'String'>
    readonly doc_date: FieldRef<"cleans", 'DateTime'>
    readonly sale_office_id: FieldRef<"cleans", 'Int'>
    readonly department_id: FieldRef<"cleans", 'Int'>
    readonly dirty_id: FieldRef<"cleans", 'Int'>
    readonly user_id: FieldRef<"cleans", 'Int'>
    readonly signature: FieldRef<"cleans", 'String'>
    readonly sign_factory: FieldRef<"cleans", 'String'>
    readonly sign_NH: FieldRef<"cleans", 'String'>
    readonly sign_factory_time: FieldRef<"cleans", 'DateTime'>
    readonly sign_NH_time: FieldRef<"cleans", 'DateTime'>
    readonly factory_id: FieldRef<"cleans", 'Int'>
    readonly status: FieldRef<"cleans", 'Boolean'>
    readonly create_at: FieldRef<"cleans", 'DateTime'>
    readonly update_at: FieldRef<"cleans", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cleans findUnique
   */
  export type cleansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
    /**
     * Filter, which cleans to fetch.
     */
    where: cleansWhereUniqueInput
  }

  /**
   * cleans findUniqueOrThrow
   */
  export type cleansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
    /**
     * Filter, which cleans to fetch.
     */
    where: cleansWhereUniqueInput
  }

  /**
   * cleans findFirst
   */
  export type cleansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
    /**
     * Filter, which cleans to fetch.
     */
    where?: cleansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cleans to fetch.
     */
    orderBy?: cleansOrderByWithRelationInput | cleansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cleans.
     */
    cursor?: cleansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cleans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cleans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cleans.
     */
    distinct?: CleansScalarFieldEnum | CleansScalarFieldEnum[]
  }

  /**
   * cleans findFirstOrThrow
   */
  export type cleansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
    /**
     * Filter, which cleans to fetch.
     */
    where?: cleansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cleans to fetch.
     */
    orderBy?: cleansOrderByWithRelationInput | cleansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cleans.
     */
    cursor?: cleansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cleans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cleans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cleans.
     */
    distinct?: CleansScalarFieldEnum | CleansScalarFieldEnum[]
  }

  /**
   * cleans findMany
   */
  export type cleansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
    /**
     * Filter, which cleans to fetch.
     */
    where?: cleansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cleans to fetch.
     */
    orderBy?: cleansOrderByWithRelationInput | cleansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cleans.
     */
    cursor?: cleansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cleans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cleans.
     */
    skip?: number
    distinct?: CleansScalarFieldEnum | CleansScalarFieldEnum[]
  }

  /**
   * cleans create
   */
  export type cleansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
    /**
     * The data needed to create a cleans.
     */
    data: XOR<cleansCreateInput, cleansUncheckedCreateInput>
  }

  /**
   * cleans createMany
   */
  export type cleansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cleans.
     */
    data: cleansCreateManyInput | cleansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cleans update
   */
  export type cleansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
    /**
     * The data needed to update a cleans.
     */
    data: XOR<cleansUpdateInput, cleansUncheckedUpdateInput>
    /**
     * Choose, which cleans to update.
     */
    where: cleansWhereUniqueInput
  }

  /**
   * cleans updateMany
   */
  export type cleansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cleans.
     */
    data: XOR<cleansUpdateManyMutationInput, cleansUncheckedUpdateManyInput>
    /**
     * Filter which cleans to update
     */
    where?: cleansWhereInput
    /**
     * Limit how many cleans to update.
     */
    limit?: number
  }

  /**
   * cleans upsert
   */
  export type cleansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
    /**
     * The filter to search for the cleans to update in case it exists.
     */
    where: cleansWhereUniqueInput
    /**
     * In case the cleans found by the `where` argument doesn't exist, create a new cleans with this data.
     */
    create: XOR<cleansCreateInput, cleansUncheckedCreateInput>
    /**
     * In case the cleans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cleansUpdateInput, cleansUncheckedUpdateInput>
  }

  /**
   * cleans delete
   */
  export type cleansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
    /**
     * Filter which cleans to delete.
     */
    where: cleansWhereUniqueInput
  }

  /**
   * cleans deleteMany
   */
  export type cleansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cleans to delete
     */
    where?: cleansWhereInput
    /**
     * Limit how many cleans to delete.
     */
    limit?: number
  }

  /**
   * cleans without action
   */
  export type cleansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleans
     */
    select?: cleansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleans
     */
    omit?: cleansOmit<ExtArgs> | null
  }


  /**
   * Model clean_details
   */

  export type AggregateClean_details = {
    _count: Clean_detailsCountAggregateOutputType | null
    _avg: Clean_detailsAvgAggregateOutputType | null
    _sum: Clean_detailsSumAggregateOutputType | null
    _min: Clean_detailsMinAggregateOutputType | null
    _max: Clean_detailsMaxAggregateOutputType | null
  }

  export type Clean_detailsAvgAggregateOutputType = {
    id: number | null
    clean_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
  }

  export type Clean_detailsSumAggregateOutputType = {
    id: number | null
    clean_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
  }

  export type Clean_detailsMinAggregateOutputType = {
    id: number | null
    clean_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
    request_name: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Clean_detailsMaxAggregateOutputType = {
    id: number | null
    clean_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
    request_name: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Clean_detailsCountAggregateOutputType = {
    id: number
    clean_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    request_name: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Clean_detailsAvgAggregateInputType = {
    id?: true
    clean_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
  }

  export type Clean_detailsSumAggregateInputType = {
    id?: true
    clean_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
  }

  export type Clean_detailsMinAggregateInputType = {
    id?: true
    clean_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
    request_name?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Clean_detailsMaxAggregateInputType = {
    id?: true
    clean_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
    request_name?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Clean_detailsCountAggregateInputType = {
    id?: true
    clean_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
    request_name?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Clean_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clean_details to aggregate.
     */
    where?: clean_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clean_details to fetch.
     */
    orderBy?: clean_detailsOrderByWithRelationInput | clean_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clean_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clean_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clean_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clean_details
    **/
    _count?: true | Clean_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Clean_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Clean_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Clean_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Clean_detailsMaxAggregateInputType
  }

  export type GetClean_detailsAggregateType<T extends Clean_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateClean_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClean_details[P]>
      : GetScalarType<T[P], AggregateClean_details[P]>
  }




  export type clean_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clean_detailsWhereInput
    orderBy?: clean_detailsOrderByWithAggregationInput | clean_detailsOrderByWithAggregationInput[]
    by: Clean_detailsScalarFieldEnum[] | Clean_detailsScalarFieldEnum
    having?: clean_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Clean_detailsCountAggregateInputType | true
    _avg?: Clean_detailsAvgAggregateInputType
    _sum?: Clean_detailsSumAggregateInputType
    _min?: Clean_detailsMinAggregateInputType
    _max?: Clean_detailsMaxAggregateInputType
  }

  export type Clean_detailsGroupByOutputType = {
    id: number
    clean_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    request_name: string
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Clean_detailsCountAggregateOutputType | null
    _avg: Clean_detailsAvgAggregateOutputType | null
    _sum: Clean_detailsSumAggregateOutputType | null
    _min: Clean_detailsMinAggregateOutputType | null
    _max: Clean_detailsMaxAggregateOutputType | null
  }

  type GetClean_detailsGroupByPayload<T extends clean_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Clean_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Clean_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Clean_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Clean_detailsGroupByOutputType[P]>
        }
      >
    >


  export type clean_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clean_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    weight?: boolean
    request_name?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["clean_details"]>



  export type clean_detailsSelectScalar = {
    id?: boolean
    clean_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    weight?: boolean
    request_name?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type clean_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clean_id" | "item_id" | "unit_id" | "qty" | "weight" | "request_name" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["clean_details"]>

  export type $clean_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clean_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clean_id: number
      item_id: number
      unit_id: number
      qty: number
      weight: number
      request_name: string
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["clean_details"]>
    composites: {}
  }

  type clean_detailsGetPayload<S extends boolean | null | undefined | clean_detailsDefaultArgs> = $Result.GetResult<Prisma.$clean_detailsPayload, S>

  type clean_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clean_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Clean_detailsCountAggregateInputType | true
    }

  export interface clean_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clean_details'], meta: { name: 'clean_details' } }
    /**
     * Find zero or one Clean_details that matches the filter.
     * @param {clean_detailsFindUniqueArgs} args - Arguments to find a Clean_details
     * @example
     * // Get one Clean_details
     * const clean_details = await prisma.clean_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clean_detailsFindUniqueArgs>(args: SelectSubset<T, clean_detailsFindUniqueArgs<ExtArgs>>): Prisma__clean_detailsClient<$Result.GetResult<Prisma.$clean_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clean_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clean_detailsFindUniqueOrThrowArgs} args - Arguments to find a Clean_details
     * @example
     * // Get one Clean_details
     * const clean_details = await prisma.clean_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clean_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, clean_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clean_detailsClient<$Result.GetResult<Prisma.$clean_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clean_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clean_detailsFindFirstArgs} args - Arguments to find a Clean_details
     * @example
     * // Get one Clean_details
     * const clean_details = await prisma.clean_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clean_detailsFindFirstArgs>(args?: SelectSubset<T, clean_detailsFindFirstArgs<ExtArgs>>): Prisma__clean_detailsClient<$Result.GetResult<Prisma.$clean_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clean_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clean_detailsFindFirstOrThrowArgs} args - Arguments to find a Clean_details
     * @example
     * // Get one Clean_details
     * const clean_details = await prisma.clean_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clean_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, clean_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__clean_detailsClient<$Result.GetResult<Prisma.$clean_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clean_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clean_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clean_details
     * const clean_details = await prisma.clean_details.findMany()
     * 
     * // Get first 10 Clean_details
     * const clean_details = await prisma.clean_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clean_detailsWithIdOnly = await prisma.clean_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clean_detailsFindManyArgs>(args?: SelectSubset<T, clean_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clean_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clean_details.
     * @param {clean_detailsCreateArgs} args - Arguments to create a Clean_details.
     * @example
     * // Create one Clean_details
     * const Clean_details = await prisma.clean_details.create({
     *   data: {
     *     // ... data to create a Clean_details
     *   }
     * })
     * 
     */
    create<T extends clean_detailsCreateArgs>(args: SelectSubset<T, clean_detailsCreateArgs<ExtArgs>>): Prisma__clean_detailsClient<$Result.GetResult<Prisma.$clean_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clean_details.
     * @param {clean_detailsCreateManyArgs} args - Arguments to create many Clean_details.
     * @example
     * // Create many Clean_details
     * const clean_details = await prisma.clean_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clean_detailsCreateManyArgs>(args?: SelectSubset<T, clean_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clean_details.
     * @param {clean_detailsDeleteArgs} args - Arguments to delete one Clean_details.
     * @example
     * // Delete one Clean_details
     * const Clean_details = await prisma.clean_details.delete({
     *   where: {
     *     // ... filter to delete one Clean_details
     *   }
     * })
     * 
     */
    delete<T extends clean_detailsDeleteArgs>(args: SelectSubset<T, clean_detailsDeleteArgs<ExtArgs>>): Prisma__clean_detailsClient<$Result.GetResult<Prisma.$clean_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clean_details.
     * @param {clean_detailsUpdateArgs} args - Arguments to update one Clean_details.
     * @example
     * // Update one Clean_details
     * const clean_details = await prisma.clean_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clean_detailsUpdateArgs>(args: SelectSubset<T, clean_detailsUpdateArgs<ExtArgs>>): Prisma__clean_detailsClient<$Result.GetResult<Prisma.$clean_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clean_details.
     * @param {clean_detailsDeleteManyArgs} args - Arguments to filter Clean_details to delete.
     * @example
     * // Delete a few Clean_details
     * const { count } = await prisma.clean_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clean_detailsDeleteManyArgs>(args?: SelectSubset<T, clean_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clean_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clean_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clean_details
     * const clean_details = await prisma.clean_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clean_detailsUpdateManyArgs>(args: SelectSubset<T, clean_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clean_details.
     * @param {clean_detailsUpsertArgs} args - Arguments to update or create a Clean_details.
     * @example
     * // Update or create a Clean_details
     * const clean_details = await prisma.clean_details.upsert({
     *   create: {
     *     // ... data to create a Clean_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clean_details we want to update
     *   }
     * })
     */
    upsert<T extends clean_detailsUpsertArgs>(args: SelectSubset<T, clean_detailsUpsertArgs<ExtArgs>>): Prisma__clean_detailsClient<$Result.GetResult<Prisma.$clean_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clean_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clean_detailsCountArgs} args - Arguments to filter Clean_details to count.
     * @example
     * // Count the number of Clean_details
     * const count = await prisma.clean_details.count({
     *   where: {
     *     // ... the filter for the Clean_details we want to count
     *   }
     * })
    **/
    count<T extends clean_detailsCountArgs>(
      args?: Subset<T, clean_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Clean_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clean_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Clean_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Clean_detailsAggregateArgs>(args: Subset<T, Clean_detailsAggregateArgs>): Prisma.PrismaPromise<GetClean_detailsAggregateType<T>>

    /**
     * Group by Clean_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clean_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clean_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clean_detailsGroupByArgs['orderBy'] }
        : { orderBy?: clean_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clean_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClean_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clean_details model
   */
  readonly fields: clean_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clean_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clean_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clean_details model
   */
  interface clean_detailsFieldRefs {
    readonly id: FieldRef<"clean_details", 'Int'>
    readonly clean_id: FieldRef<"clean_details", 'Int'>
    readonly item_id: FieldRef<"clean_details", 'Int'>
    readonly unit_id: FieldRef<"clean_details", 'Int'>
    readonly qty: FieldRef<"clean_details", 'Float'>
    readonly weight: FieldRef<"clean_details", 'Float'>
    readonly request_name: FieldRef<"clean_details", 'String'>
    readonly description: FieldRef<"clean_details", 'String'>
    readonly status: FieldRef<"clean_details", 'Boolean'>
    readonly create_at: FieldRef<"clean_details", 'DateTime'>
    readonly update_at: FieldRef<"clean_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clean_details findUnique
   */
  export type clean_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
    /**
     * Filter, which clean_details to fetch.
     */
    where: clean_detailsWhereUniqueInput
  }

  /**
   * clean_details findUniqueOrThrow
   */
  export type clean_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
    /**
     * Filter, which clean_details to fetch.
     */
    where: clean_detailsWhereUniqueInput
  }

  /**
   * clean_details findFirst
   */
  export type clean_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
    /**
     * Filter, which clean_details to fetch.
     */
    where?: clean_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clean_details to fetch.
     */
    orderBy?: clean_detailsOrderByWithRelationInput | clean_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clean_details.
     */
    cursor?: clean_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clean_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clean_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clean_details.
     */
    distinct?: Clean_detailsScalarFieldEnum | Clean_detailsScalarFieldEnum[]
  }

  /**
   * clean_details findFirstOrThrow
   */
  export type clean_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
    /**
     * Filter, which clean_details to fetch.
     */
    where?: clean_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clean_details to fetch.
     */
    orderBy?: clean_detailsOrderByWithRelationInput | clean_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clean_details.
     */
    cursor?: clean_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clean_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clean_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clean_details.
     */
    distinct?: Clean_detailsScalarFieldEnum | Clean_detailsScalarFieldEnum[]
  }

  /**
   * clean_details findMany
   */
  export type clean_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
    /**
     * Filter, which clean_details to fetch.
     */
    where?: clean_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clean_details to fetch.
     */
    orderBy?: clean_detailsOrderByWithRelationInput | clean_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clean_details.
     */
    cursor?: clean_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clean_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clean_details.
     */
    skip?: number
    distinct?: Clean_detailsScalarFieldEnum | Clean_detailsScalarFieldEnum[]
  }

  /**
   * clean_details create
   */
  export type clean_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
    /**
     * The data needed to create a clean_details.
     */
    data: XOR<clean_detailsCreateInput, clean_detailsUncheckedCreateInput>
  }

  /**
   * clean_details createMany
   */
  export type clean_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clean_details.
     */
    data: clean_detailsCreateManyInput | clean_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clean_details update
   */
  export type clean_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
    /**
     * The data needed to update a clean_details.
     */
    data: XOR<clean_detailsUpdateInput, clean_detailsUncheckedUpdateInput>
    /**
     * Choose, which clean_details to update.
     */
    where: clean_detailsWhereUniqueInput
  }

  /**
   * clean_details updateMany
   */
  export type clean_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clean_details.
     */
    data: XOR<clean_detailsUpdateManyMutationInput, clean_detailsUncheckedUpdateManyInput>
    /**
     * Filter which clean_details to update
     */
    where?: clean_detailsWhereInput
    /**
     * Limit how many clean_details to update.
     */
    limit?: number
  }

  /**
   * clean_details upsert
   */
  export type clean_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
    /**
     * The filter to search for the clean_details to update in case it exists.
     */
    where: clean_detailsWhereUniqueInput
    /**
     * In case the clean_details found by the `where` argument doesn't exist, create a new clean_details with this data.
     */
    create: XOR<clean_detailsCreateInput, clean_detailsUncheckedCreateInput>
    /**
     * In case the clean_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clean_detailsUpdateInput, clean_detailsUncheckedUpdateInput>
  }

  /**
   * clean_details delete
   */
  export type clean_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
    /**
     * Filter which clean_details to delete.
     */
    where: clean_detailsWhereUniqueInput
  }

  /**
   * clean_details deleteMany
   */
  export type clean_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clean_details to delete
     */
    where?: clean_detailsWhereInput
    /**
     * Limit how many clean_details to delete.
     */
    limit?: number
  }

  /**
   * clean_details without action
   */
  export type clean_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clean_details
     */
    select?: clean_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clean_details
     */
    omit?: clean_detailsOmit<ExtArgs> | null
  }


  /**
   * Model return_washs
   */

  export type AggregateReturn_washs = {
    _count: Return_washsCountAggregateOutputType | null
    _avg: Return_washsAvgAggregateOutputType | null
    _sum: Return_washsSumAggregateOutputType | null
    _min: Return_washsMinAggregateOutputType | null
    _max: Return_washsMaxAggregateOutputType | null
  }

  export type Return_washsAvgAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    dirty_id: number | null
    user_id: number | null
    factory_id: number | null
  }

  export type Return_washsSumAggregateOutputType = {
    id: number | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    dirty_id: number | null
    user_id: number | null
    factory_id: number | null
  }

  export type Return_washsMinAggregateOutputType = {
    id: number | null
    doc_no: string | null
    doc_date: Date | null
    ref_doc_no: string | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    dirty_id: number | null
    user_id: number | null
    signature: string | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Return_washsMaxAggregateOutputType = {
    id: number | null
    doc_no: string | null
    doc_date: Date | null
    ref_doc_no: string | null
    sale_office_id: number | null
    department_id: number | null
    total: number | null
    dirty_id: number | null
    user_id: number | null
    signature: string | null
    sign_factory: string | null
    sign_NH: string | null
    sign_factory_time: Date | null
    sign_NH_time: Date | null
    factory_id: number | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Return_washsCountAggregateOutputType = {
    id: number
    doc_no: number
    doc_date: number
    ref_doc_no: number
    sale_office_id: number
    department_id: number
    total: number
    dirty_id: number
    user_id: number
    signature: number
    sign_factory: number
    sign_NH: number
    sign_factory_time: number
    sign_NH_time: number
    factory_id: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Return_washsAvgAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    dirty_id?: true
    user_id?: true
    factory_id?: true
  }

  export type Return_washsSumAggregateInputType = {
    id?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    dirty_id?: true
    user_id?: true
    factory_id?: true
  }

  export type Return_washsMinAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    dirty_id?: true
    user_id?: true
    signature?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Return_washsMaxAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    dirty_id?: true
    user_id?: true
    signature?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Return_washsCountAggregateInputType = {
    id?: true
    doc_no?: true
    doc_date?: true
    ref_doc_no?: true
    sale_office_id?: true
    department_id?: true
    total?: true
    dirty_id?: true
    user_id?: true
    signature?: true
    sign_factory?: true
    sign_NH?: true
    sign_factory_time?: true
    sign_NH_time?: true
    factory_id?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Return_washsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which return_washs to aggregate.
     */
    where?: return_washsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_washs to fetch.
     */
    orderBy?: return_washsOrderByWithRelationInput | return_washsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: return_washsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_washs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_washs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned return_washs
    **/
    _count?: true | Return_washsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Return_washsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Return_washsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Return_washsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Return_washsMaxAggregateInputType
  }

  export type GetReturn_washsAggregateType<T extends Return_washsAggregateArgs> = {
        [P in keyof T & keyof AggregateReturn_washs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturn_washs[P]>
      : GetScalarType<T[P], AggregateReturn_washs[P]>
  }




  export type return_washsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: return_washsWhereInput
    orderBy?: return_washsOrderByWithAggregationInput | return_washsOrderByWithAggregationInput[]
    by: Return_washsScalarFieldEnum[] | Return_washsScalarFieldEnum
    having?: return_washsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Return_washsCountAggregateInputType | true
    _avg?: Return_washsAvgAggregateInputType
    _sum?: Return_washsSumAggregateInputType
    _min?: Return_washsMinAggregateInputType
    _max?: Return_washsMaxAggregateInputType
  }

  export type Return_washsGroupByOutputType = {
    id: number
    doc_no: string
    doc_date: Date
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    total: number
    dirty_id: number
    user_id: number
    signature: string
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date
    sign_NH_time: Date
    factory_id: number
    status: boolean
    create_at: Date
    update_at: Date
    _count: Return_washsCountAggregateOutputType | null
    _avg: Return_washsAvgAggregateOutputType | null
    _sum: Return_washsSumAggregateOutputType | null
    _min: Return_washsMinAggregateOutputType | null
    _max: Return_washsMaxAggregateOutputType | null
  }

  type GetReturn_washsGroupByPayload<T extends return_washsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Return_washsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Return_washsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Return_washsGroupByOutputType[P]>
            : GetScalarType<T[P], Return_washsGroupByOutputType[P]>
        }
      >
    >


  export type return_washsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    ref_doc_no?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    total?: boolean
    dirty_id?: boolean
    user_id?: boolean
    signature?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["return_washs"]>



  export type return_washsSelectScalar = {
    id?: boolean
    doc_no?: boolean
    doc_date?: boolean
    ref_doc_no?: boolean
    sale_office_id?: boolean
    department_id?: boolean
    total?: boolean
    dirty_id?: boolean
    user_id?: boolean
    signature?: boolean
    sign_factory?: boolean
    sign_NH?: boolean
    sign_factory_time?: boolean
    sign_NH_time?: boolean
    factory_id?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type return_washsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doc_no" | "doc_date" | "ref_doc_no" | "sale_office_id" | "department_id" | "total" | "dirty_id" | "user_id" | "signature" | "sign_factory" | "sign_NH" | "sign_factory_time" | "sign_NH_time" | "factory_id" | "status" | "create_at" | "update_at", ExtArgs["result"]["return_washs"]>

  export type $return_washsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "return_washs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doc_no: string
      doc_date: Date
      ref_doc_no: string
      sale_office_id: number
      department_id: number
      total: number
      dirty_id: number
      user_id: number
      signature: string
      sign_factory: string
      sign_NH: string
      sign_factory_time: Date
      sign_NH_time: Date
      factory_id: number
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["return_washs"]>
    composites: {}
  }

  type return_washsGetPayload<S extends boolean | null | undefined | return_washsDefaultArgs> = $Result.GetResult<Prisma.$return_washsPayload, S>

  type return_washsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<return_washsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Return_washsCountAggregateInputType | true
    }

  export interface return_washsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['return_washs'], meta: { name: 'return_washs' } }
    /**
     * Find zero or one Return_washs that matches the filter.
     * @param {return_washsFindUniqueArgs} args - Arguments to find a Return_washs
     * @example
     * // Get one Return_washs
     * const return_washs = await prisma.return_washs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends return_washsFindUniqueArgs>(args: SelectSubset<T, return_washsFindUniqueArgs<ExtArgs>>): Prisma__return_washsClient<$Result.GetResult<Prisma.$return_washsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Return_washs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {return_washsFindUniqueOrThrowArgs} args - Arguments to find a Return_washs
     * @example
     * // Get one Return_washs
     * const return_washs = await prisma.return_washs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends return_washsFindUniqueOrThrowArgs>(args: SelectSubset<T, return_washsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__return_washsClient<$Result.GetResult<Prisma.$return_washsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Return_washs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_washsFindFirstArgs} args - Arguments to find a Return_washs
     * @example
     * // Get one Return_washs
     * const return_washs = await prisma.return_washs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends return_washsFindFirstArgs>(args?: SelectSubset<T, return_washsFindFirstArgs<ExtArgs>>): Prisma__return_washsClient<$Result.GetResult<Prisma.$return_washsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Return_washs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_washsFindFirstOrThrowArgs} args - Arguments to find a Return_washs
     * @example
     * // Get one Return_washs
     * const return_washs = await prisma.return_washs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends return_washsFindFirstOrThrowArgs>(args?: SelectSubset<T, return_washsFindFirstOrThrowArgs<ExtArgs>>): Prisma__return_washsClient<$Result.GetResult<Prisma.$return_washsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Return_washs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_washsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Return_washs
     * const return_washs = await prisma.return_washs.findMany()
     * 
     * // Get first 10 Return_washs
     * const return_washs = await prisma.return_washs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const return_washsWithIdOnly = await prisma.return_washs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends return_washsFindManyArgs>(args?: SelectSubset<T, return_washsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_washsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Return_washs.
     * @param {return_washsCreateArgs} args - Arguments to create a Return_washs.
     * @example
     * // Create one Return_washs
     * const Return_washs = await prisma.return_washs.create({
     *   data: {
     *     // ... data to create a Return_washs
     *   }
     * })
     * 
     */
    create<T extends return_washsCreateArgs>(args: SelectSubset<T, return_washsCreateArgs<ExtArgs>>): Prisma__return_washsClient<$Result.GetResult<Prisma.$return_washsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Return_washs.
     * @param {return_washsCreateManyArgs} args - Arguments to create many Return_washs.
     * @example
     * // Create many Return_washs
     * const return_washs = await prisma.return_washs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends return_washsCreateManyArgs>(args?: SelectSubset<T, return_washsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Return_washs.
     * @param {return_washsDeleteArgs} args - Arguments to delete one Return_washs.
     * @example
     * // Delete one Return_washs
     * const Return_washs = await prisma.return_washs.delete({
     *   where: {
     *     // ... filter to delete one Return_washs
     *   }
     * })
     * 
     */
    delete<T extends return_washsDeleteArgs>(args: SelectSubset<T, return_washsDeleteArgs<ExtArgs>>): Prisma__return_washsClient<$Result.GetResult<Prisma.$return_washsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Return_washs.
     * @param {return_washsUpdateArgs} args - Arguments to update one Return_washs.
     * @example
     * // Update one Return_washs
     * const return_washs = await prisma.return_washs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends return_washsUpdateArgs>(args: SelectSubset<T, return_washsUpdateArgs<ExtArgs>>): Prisma__return_washsClient<$Result.GetResult<Prisma.$return_washsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Return_washs.
     * @param {return_washsDeleteManyArgs} args - Arguments to filter Return_washs to delete.
     * @example
     * // Delete a few Return_washs
     * const { count } = await prisma.return_washs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends return_washsDeleteManyArgs>(args?: SelectSubset<T, return_washsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Return_washs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_washsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Return_washs
     * const return_washs = await prisma.return_washs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends return_washsUpdateManyArgs>(args: SelectSubset<T, return_washsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Return_washs.
     * @param {return_washsUpsertArgs} args - Arguments to update or create a Return_washs.
     * @example
     * // Update or create a Return_washs
     * const return_washs = await prisma.return_washs.upsert({
     *   create: {
     *     // ... data to create a Return_washs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Return_washs we want to update
     *   }
     * })
     */
    upsert<T extends return_washsUpsertArgs>(args: SelectSubset<T, return_washsUpsertArgs<ExtArgs>>): Prisma__return_washsClient<$Result.GetResult<Prisma.$return_washsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Return_washs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_washsCountArgs} args - Arguments to filter Return_washs to count.
     * @example
     * // Count the number of Return_washs
     * const count = await prisma.return_washs.count({
     *   where: {
     *     // ... the filter for the Return_washs we want to count
     *   }
     * })
    **/
    count<T extends return_washsCountArgs>(
      args?: Subset<T, return_washsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Return_washsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Return_washs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Return_washsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Return_washsAggregateArgs>(args: Subset<T, Return_washsAggregateArgs>): Prisma.PrismaPromise<GetReturn_washsAggregateType<T>>

    /**
     * Group by Return_washs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_washsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends return_washsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: return_washsGroupByArgs['orderBy'] }
        : { orderBy?: return_washsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, return_washsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturn_washsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the return_washs model
   */
  readonly fields: return_washsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for return_washs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__return_washsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the return_washs model
   */
  interface return_washsFieldRefs {
    readonly id: FieldRef<"return_washs", 'Int'>
    readonly doc_no: FieldRef<"return_washs", 'String'>
    readonly doc_date: FieldRef<"return_washs", 'DateTime'>
    readonly ref_doc_no: FieldRef<"return_washs", 'String'>
    readonly sale_office_id: FieldRef<"return_washs", 'Int'>
    readonly department_id: FieldRef<"return_washs", 'Int'>
    readonly total: FieldRef<"return_washs", 'Float'>
    readonly dirty_id: FieldRef<"return_washs", 'Int'>
    readonly user_id: FieldRef<"return_washs", 'Int'>
    readonly signature: FieldRef<"return_washs", 'String'>
    readonly sign_factory: FieldRef<"return_washs", 'String'>
    readonly sign_NH: FieldRef<"return_washs", 'String'>
    readonly sign_factory_time: FieldRef<"return_washs", 'DateTime'>
    readonly sign_NH_time: FieldRef<"return_washs", 'DateTime'>
    readonly factory_id: FieldRef<"return_washs", 'Int'>
    readonly status: FieldRef<"return_washs", 'Boolean'>
    readonly create_at: FieldRef<"return_washs", 'DateTime'>
    readonly update_at: FieldRef<"return_washs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * return_washs findUnique
   */
  export type return_washsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
    /**
     * Filter, which return_washs to fetch.
     */
    where: return_washsWhereUniqueInput
  }

  /**
   * return_washs findUniqueOrThrow
   */
  export type return_washsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
    /**
     * Filter, which return_washs to fetch.
     */
    where: return_washsWhereUniqueInput
  }

  /**
   * return_washs findFirst
   */
  export type return_washsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
    /**
     * Filter, which return_washs to fetch.
     */
    where?: return_washsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_washs to fetch.
     */
    orderBy?: return_washsOrderByWithRelationInput | return_washsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for return_washs.
     */
    cursor?: return_washsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_washs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_washs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of return_washs.
     */
    distinct?: Return_washsScalarFieldEnum | Return_washsScalarFieldEnum[]
  }

  /**
   * return_washs findFirstOrThrow
   */
  export type return_washsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
    /**
     * Filter, which return_washs to fetch.
     */
    where?: return_washsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_washs to fetch.
     */
    orderBy?: return_washsOrderByWithRelationInput | return_washsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for return_washs.
     */
    cursor?: return_washsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_washs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_washs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of return_washs.
     */
    distinct?: Return_washsScalarFieldEnum | Return_washsScalarFieldEnum[]
  }

  /**
   * return_washs findMany
   */
  export type return_washsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
    /**
     * Filter, which return_washs to fetch.
     */
    where?: return_washsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_washs to fetch.
     */
    orderBy?: return_washsOrderByWithRelationInput | return_washsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing return_washs.
     */
    cursor?: return_washsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_washs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_washs.
     */
    skip?: number
    distinct?: Return_washsScalarFieldEnum | Return_washsScalarFieldEnum[]
  }

  /**
   * return_washs create
   */
  export type return_washsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
    /**
     * The data needed to create a return_washs.
     */
    data: XOR<return_washsCreateInput, return_washsUncheckedCreateInput>
  }

  /**
   * return_washs createMany
   */
  export type return_washsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many return_washs.
     */
    data: return_washsCreateManyInput | return_washsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * return_washs update
   */
  export type return_washsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
    /**
     * The data needed to update a return_washs.
     */
    data: XOR<return_washsUpdateInput, return_washsUncheckedUpdateInput>
    /**
     * Choose, which return_washs to update.
     */
    where: return_washsWhereUniqueInput
  }

  /**
   * return_washs updateMany
   */
  export type return_washsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update return_washs.
     */
    data: XOR<return_washsUpdateManyMutationInput, return_washsUncheckedUpdateManyInput>
    /**
     * Filter which return_washs to update
     */
    where?: return_washsWhereInput
    /**
     * Limit how many return_washs to update.
     */
    limit?: number
  }

  /**
   * return_washs upsert
   */
  export type return_washsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
    /**
     * The filter to search for the return_washs to update in case it exists.
     */
    where: return_washsWhereUniqueInput
    /**
     * In case the return_washs found by the `where` argument doesn't exist, create a new return_washs with this data.
     */
    create: XOR<return_washsCreateInput, return_washsUncheckedCreateInput>
    /**
     * In case the return_washs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<return_washsUpdateInput, return_washsUncheckedUpdateInput>
  }

  /**
   * return_washs delete
   */
  export type return_washsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
    /**
     * Filter which return_washs to delete.
     */
    where: return_washsWhereUniqueInput
  }

  /**
   * return_washs deleteMany
   */
  export type return_washsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which return_washs to delete
     */
    where?: return_washsWhereInput
    /**
     * Limit how many return_washs to delete.
     */
    limit?: number
  }

  /**
   * return_washs without action
   */
  export type return_washsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_washs
     */
    select?: return_washsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the return_washs
     */
    omit?: return_washsOmit<ExtArgs> | null
  }


  /**
   * Model retrun_wash_details
   */

  export type AggregateRetrun_wash_details = {
    _count: Retrun_wash_detailsCountAggregateOutputType | null
    _avg: Retrun_wash_detailsAvgAggregateOutputType | null
    _sum: Retrun_wash_detailsSumAggregateOutputType | null
    _min: Retrun_wash_detailsMinAggregateOutputType | null
    _max: Retrun_wash_detailsMaxAggregateOutputType | null
  }

  export type Retrun_wash_detailsAvgAggregateOutputType = {
    id: number | null
    return_wash_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
  }

  export type Retrun_wash_detailsSumAggregateOutputType = {
    id: number | null
    return_wash_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
  }

  export type Retrun_wash_detailsMinAggregateOutputType = {
    id: number | null
    return_wash_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
    is_cancel: boolean | null
    is_checklist: boolean | null
    request_name: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Retrun_wash_detailsMaxAggregateOutputType = {
    id: number | null
    return_wash_id: number | null
    item_id: number | null
    unit_id: number | null
    qty: number | null
    weight: number | null
    is_cancel: boolean | null
    is_checklist: boolean | null
    request_name: string | null
    description: string | null
    status: boolean | null
    create_at: Date | null
    update_at: Date | null
  }

  export type Retrun_wash_detailsCountAggregateOutputType = {
    id: number
    return_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: number
    is_checklist: number
    request_name: number
    description: number
    status: number
    create_at: number
    update_at: number
    _all: number
  }


  export type Retrun_wash_detailsAvgAggregateInputType = {
    id?: true
    return_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
  }

  export type Retrun_wash_detailsSumAggregateInputType = {
    id?: true
    return_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
  }

  export type Retrun_wash_detailsMinAggregateInputType = {
    id?: true
    return_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
    is_cancel?: true
    is_checklist?: true
    request_name?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Retrun_wash_detailsMaxAggregateInputType = {
    id?: true
    return_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
    is_cancel?: true
    is_checklist?: true
    request_name?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
  }

  export type Retrun_wash_detailsCountAggregateInputType = {
    id?: true
    return_wash_id?: true
    item_id?: true
    unit_id?: true
    qty?: true
    weight?: true
    is_cancel?: true
    is_checklist?: true
    request_name?: true
    description?: true
    status?: true
    create_at?: true
    update_at?: true
    _all?: true
  }

  export type Retrun_wash_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which retrun_wash_details to aggregate.
     */
    where?: retrun_wash_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of retrun_wash_details to fetch.
     */
    orderBy?: retrun_wash_detailsOrderByWithRelationInput | retrun_wash_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: retrun_wash_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` retrun_wash_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` retrun_wash_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned retrun_wash_details
    **/
    _count?: true | Retrun_wash_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Retrun_wash_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Retrun_wash_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Retrun_wash_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Retrun_wash_detailsMaxAggregateInputType
  }

  export type GetRetrun_wash_detailsAggregateType<T extends Retrun_wash_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateRetrun_wash_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRetrun_wash_details[P]>
      : GetScalarType<T[P], AggregateRetrun_wash_details[P]>
  }




  export type retrun_wash_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: retrun_wash_detailsWhereInput
    orderBy?: retrun_wash_detailsOrderByWithAggregationInput | retrun_wash_detailsOrderByWithAggregationInput[]
    by: Retrun_wash_detailsScalarFieldEnum[] | Retrun_wash_detailsScalarFieldEnum
    having?: retrun_wash_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Retrun_wash_detailsCountAggregateInputType | true
    _avg?: Retrun_wash_detailsAvgAggregateInputType
    _sum?: Retrun_wash_detailsSumAggregateInputType
    _min?: Retrun_wash_detailsMinAggregateInputType
    _max?: Retrun_wash_detailsMaxAggregateInputType
  }

  export type Retrun_wash_detailsGroupByOutputType = {
    id: number
    return_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    request_name: string
    description: string
    status: boolean
    create_at: Date
    update_at: Date
    _count: Retrun_wash_detailsCountAggregateOutputType | null
    _avg: Retrun_wash_detailsAvgAggregateOutputType | null
    _sum: Retrun_wash_detailsSumAggregateOutputType | null
    _min: Retrun_wash_detailsMinAggregateOutputType | null
    _max: Retrun_wash_detailsMaxAggregateOutputType | null
  }

  type GetRetrun_wash_detailsGroupByPayload<T extends retrun_wash_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Retrun_wash_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Retrun_wash_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Retrun_wash_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Retrun_wash_detailsGroupByOutputType[P]>
        }
      >
    >


  export type retrun_wash_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    return_wash_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    is_checklist?: boolean
    request_name?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }, ExtArgs["result"]["retrun_wash_details"]>



  export type retrun_wash_detailsSelectScalar = {
    id?: boolean
    return_wash_id?: boolean
    item_id?: boolean
    unit_id?: boolean
    qty?: boolean
    weight?: boolean
    is_cancel?: boolean
    is_checklist?: boolean
    request_name?: boolean
    description?: boolean
    status?: boolean
    create_at?: boolean
    update_at?: boolean
  }

  export type retrun_wash_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "return_wash_id" | "item_id" | "unit_id" | "qty" | "weight" | "is_cancel" | "is_checklist" | "request_name" | "description" | "status" | "create_at" | "update_at", ExtArgs["result"]["retrun_wash_details"]>

  export type $retrun_wash_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "retrun_wash_details"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      return_wash_id: number
      item_id: number
      unit_id: number
      qty: number
      weight: number
      is_cancel: boolean
      is_checklist: boolean
      request_name: string
      description: string
      status: boolean
      create_at: Date
      update_at: Date
    }, ExtArgs["result"]["retrun_wash_details"]>
    composites: {}
  }

  type retrun_wash_detailsGetPayload<S extends boolean | null | undefined | retrun_wash_detailsDefaultArgs> = $Result.GetResult<Prisma.$retrun_wash_detailsPayload, S>

  type retrun_wash_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<retrun_wash_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Retrun_wash_detailsCountAggregateInputType | true
    }

  export interface retrun_wash_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['retrun_wash_details'], meta: { name: 'retrun_wash_details' } }
    /**
     * Find zero or one Retrun_wash_details that matches the filter.
     * @param {retrun_wash_detailsFindUniqueArgs} args - Arguments to find a Retrun_wash_details
     * @example
     * // Get one Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends retrun_wash_detailsFindUniqueArgs>(args: SelectSubset<T, retrun_wash_detailsFindUniqueArgs<ExtArgs>>): Prisma__retrun_wash_detailsClient<$Result.GetResult<Prisma.$retrun_wash_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Retrun_wash_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {retrun_wash_detailsFindUniqueOrThrowArgs} args - Arguments to find a Retrun_wash_details
     * @example
     * // Get one Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends retrun_wash_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, retrun_wash_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__retrun_wash_detailsClient<$Result.GetResult<Prisma.$retrun_wash_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Retrun_wash_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {retrun_wash_detailsFindFirstArgs} args - Arguments to find a Retrun_wash_details
     * @example
     * // Get one Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends retrun_wash_detailsFindFirstArgs>(args?: SelectSubset<T, retrun_wash_detailsFindFirstArgs<ExtArgs>>): Prisma__retrun_wash_detailsClient<$Result.GetResult<Prisma.$retrun_wash_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Retrun_wash_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {retrun_wash_detailsFindFirstOrThrowArgs} args - Arguments to find a Retrun_wash_details
     * @example
     * // Get one Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends retrun_wash_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, retrun_wash_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__retrun_wash_detailsClient<$Result.GetResult<Prisma.$retrun_wash_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Retrun_wash_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {retrun_wash_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.findMany()
     * 
     * // Get first 10 Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const retrun_wash_detailsWithIdOnly = await prisma.retrun_wash_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends retrun_wash_detailsFindManyArgs>(args?: SelectSubset<T, retrun_wash_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$retrun_wash_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Retrun_wash_details.
     * @param {retrun_wash_detailsCreateArgs} args - Arguments to create a Retrun_wash_details.
     * @example
     * // Create one Retrun_wash_details
     * const Retrun_wash_details = await prisma.retrun_wash_details.create({
     *   data: {
     *     // ... data to create a Retrun_wash_details
     *   }
     * })
     * 
     */
    create<T extends retrun_wash_detailsCreateArgs>(args: SelectSubset<T, retrun_wash_detailsCreateArgs<ExtArgs>>): Prisma__retrun_wash_detailsClient<$Result.GetResult<Prisma.$retrun_wash_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Retrun_wash_details.
     * @param {retrun_wash_detailsCreateManyArgs} args - Arguments to create many Retrun_wash_details.
     * @example
     * // Create many Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends retrun_wash_detailsCreateManyArgs>(args?: SelectSubset<T, retrun_wash_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Retrun_wash_details.
     * @param {retrun_wash_detailsDeleteArgs} args - Arguments to delete one Retrun_wash_details.
     * @example
     * // Delete one Retrun_wash_details
     * const Retrun_wash_details = await prisma.retrun_wash_details.delete({
     *   where: {
     *     // ... filter to delete one Retrun_wash_details
     *   }
     * })
     * 
     */
    delete<T extends retrun_wash_detailsDeleteArgs>(args: SelectSubset<T, retrun_wash_detailsDeleteArgs<ExtArgs>>): Prisma__retrun_wash_detailsClient<$Result.GetResult<Prisma.$retrun_wash_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Retrun_wash_details.
     * @param {retrun_wash_detailsUpdateArgs} args - Arguments to update one Retrun_wash_details.
     * @example
     * // Update one Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends retrun_wash_detailsUpdateArgs>(args: SelectSubset<T, retrun_wash_detailsUpdateArgs<ExtArgs>>): Prisma__retrun_wash_detailsClient<$Result.GetResult<Prisma.$retrun_wash_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Retrun_wash_details.
     * @param {retrun_wash_detailsDeleteManyArgs} args - Arguments to filter Retrun_wash_details to delete.
     * @example
     * // Delete a few Retrun_wash_details
     * const { count } = await prisma.retrun_wash_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends retrun_wash_detailsDeleteManyArgs>(args?: SelectSubset<T, retrun_wash_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Retrun_wash_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {retrun_wash_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends retrun_wash_detailsUpdateManyArgs>(args: SelectSubset<T, retrun_wash_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Retrun_wash_details.
     * @param {retrun_wash_detailsUpsertArgs} args - Arguments to update or create a Retrun_wash_details.
     * @example
     * // Update or create a Retrun_wash_details
     * const retrun_wash_details = await prisma.retrun_wash_details.upsert({
     *   create: {
     *     // ... data to create a Retrun_wash_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Retrun_wash_details we want to update
     *   }
     * })
     */
    upsert<T extends retrun_wash_detailsUpsertArgs>(args: SelectSubset<T, retrun_wash_detailsUpsertArgs<ExtArgs>>): Prisma__retrun_wash_detailsClient<$Result.GetResult<Prisma.$retrun_wash_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Retrun_wash_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {retrun_wash_detailsCountArgs} args - Arguments to filter Retrun_wash_details to count.
     * @example
     * // Count the number of Retrun_wash_details
     * const count = await prisma.retrun_wash_details.count({
     *   where: {
     *     // ... the filter for the Retrun_wash_details we want to count
     *   }
     * })
    **/
    count<T extends retrun_wash_detailsCountArgs>(
      args?: Subset<T, retrun_wash_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Retrun_wash_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Retrun_wash_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Retrun_wash_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Retrun_wash_detailsAggregateArgs>(args: Subset<T, Retrun_wash_detailsAggregateArgs>): Prisma.PrismaPromise<GetRetrun_wash_detailsAggregateType<T>>

    /**
     * Group by Retrun_wash_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {retrun_wash_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends retrun_wash_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: retrun_wash_detailsGroupByArgs['orderBy'] }
        : { orderBy?: retrun_wash_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, retrun_wash_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRetrun_wash_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the retrun_wash_details model
   */
  readonly fields: retrun_wash_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for retrun_wash_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__retrun_wash_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the retrun_wash_details model
   */
  interface retrun_wash_detailsFieldRefs {
    readonly id: FieldRef<"retrun_wash_details", 'Int'>
    readonly return_wash_id: FieldRef<"retrun_wash_details", 'Int'>
    readonly item_id: FieldRef<"retrun_wash_details", 'Int'>
    readonly unit_id: FieldRef<"retrun_wash_details", 'Int'>
    readonly qty: FieldRef<"retrun_wash_details", 'Float'>
    readonly weight: FieldRef<"retrun_wash_details", 'Float'>
    readonly is_cancel: FieldRef<"retrun_wash_details", 'Boolean'>
    readonly is_checklist: FieldRef<"retrun_wash_details", 'Boolean'>
    readonly request_name: FieldRef<"retrun_wash_details", 'String'>
    readonly description: FieldRef<"retrun_wash_details", 'String'>
    readonly status: FieldRef<"retrun_wash_details", 'Boolean'>
    readonly create_at: FieldRef<"retrun_wash_details", 'DateTime'>
    readonly update_at: FieldRef<"retrun_wash_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * retrun_wash_details findUnique
   */
  export type retrun_wash_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which retrun_wash_details to fetch.
     */
    where: retrun_wash_detailsWhereUniqueInput
  }

  /**
   * retrun_wash_details findUniqueOrThrow
   */
  export type retrun_wash_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which retrun_wash_details to fetch.
     */
    where: retrun_wash_detailsWhereUniqueInput
  }

  /**
   * retrun_wash_details findFirst
   */
  export type retrun_wash_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which retrun_wash_details to fetch.
     */
    where?: retrun_wash_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of retrun_wash_details to fetch.
     */
    orderBy?: retrun_wash_detailsOrderByWithRelationInput | retrun_wash_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for retrun_wash_details.
     */
    cursor?: retrun_wash_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` retrun_wash_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` retrun_wash_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of retrun_wash_details.
     */
    distinct?: Retrun_wash_detailsScalarFieldEnum | Retrun_wash_detailsScalarFieldEnum[]
  }

  /**
   * retrun_wash_details findFirstOrThrow
   */
  export type retrun_wash_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which retrun_wash_details to fetch.
     */
    where?: retrun_wash_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of retrun_wash_details to fetch.
     */
    orderBy?: retrun_wash_detailsOrderByWithRelationInput | retrun_wash_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for retrun_wash_details.
     */
    cursor?: retrun_wash_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` retrun_wash_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` retrun_wash_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of retrun_wash_details.
     */
    distinct?: Retrun_wash_detailsScalarFieldEnum | Retrun_wash_detailsScalarFieldEnum[]
  }

  /**
   * retrun_wash_details findMany
   */
  export type retrun_wash_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter, which retrun_wash_details to fetch.
     */
    where?: retrun_wash_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of retrun_wash_details to fetch.
     */
    orderBy?: retrun_wash_detailsOrderByWithRelationInput | retrun_wash_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing retrun_wash_details.
     */
    cursor?: retrun_wash_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` retrun_wash_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` retrun_wash_details.
     */
    skip?: number
    distinct?: Retrun_wash_detailsScalarFieldEnum | Retrun_wash_detailsScalarFieldEnum[]
  }

  /**
   * retrun_wash_details create
   */
  export type retrun_wash_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
    /**
     * The data needed to create a retrun_wash_details.
     */
    data: XOR<retrun_wash_detailsCreateInput, retrun_wash_detailsUncheckedCreateInput>
  }

  /**
   * retrun_wash_details createMany
   */
  export type retrun_wash_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many retrun_wash_details.
     */
    data: retrun_wash_detailsCreateManyInput | retrun_wash_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * retrun_wash_details update
   */
  export type retrun_wash_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
    /**
     * The data needed to update a retrun_wash_details.
     */
    data: XOR<retrun_wash_detailsUpdateInput, retrun_wash_detailsUncheckedUpdateInput>
    /**
     * Choose, which retrun_wash_details to update.
     */
    where: retrun_wash_detailsWhereUniqueInput
  }

  /**
   * retrun_wash_details updateMany
   */
  export type retrun_wash_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update retrun_wash_details.
     */
    data: XOR<retrun_wash_detailsUpdateManyMutationInput, retrun_wash_detailsUncheckedUpdateManyInput>
    /**
     * Filter which retrun_wash_details to update
     */
    where?: retrun_wash_detailsWhereInput
    /**
     * Limit how many retrun_wash_details to update.
     */
    limit?: number
  }

  /**
   * retrun_wash_details upsert
   */
  export type retrun_wash_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
    /**
     * The filter to search for the retrun_wash_details to update in case it exists.
     */
    where: retrun_wash_detailsWhereUniqueInput
    /**
     * In case the retrun_wash_details found by the `where` argument doesn't exist, create a new retrun_wash_details with this data.
     */
    create: XOR<retrun_wash_detailsCreateInput, retrun_wash_detailsUncheckedCreateInput>
    /**
     * In case the retrun_wash_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<retrun_wash_detailsUpdateInput, retrun_wash_detailsUncheckedUpdateInput>
  }

  /**
   * retrun_wash_details delete
   */
  export type retrun_wash_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
    /**
     * Filter which retrun_wash_details to delete.
     */
    where: retrun_wash_detailsWhereUniqueInput
  }

  /**
   * retrun_wash_details deleteMany
   */
  export type retrun_wash_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which retrun_wash_details to delete
     */
    where?: retrun_wash_detailsWhereInput
    /**
     * Limit how many retrun_wash_details to delete.
     */
    limit?: number
  }

  /**
   * retrun_wash_details without action
   */
  export type retrun_wash_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the retrun_wash_details
     */
    select?: retrun_wash_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the retrun_wash_details
     */
    omit?: retrun_wash_detailsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    permission_id: 'permission_id',
    email_verified_at: 'email_verified_at',
    password: 'password',
    two_factor_secret: 'two_factor_secret',
    two_factor_recovery_codes: 'two_factor_recovery_codes',
    two_factor_confirmed_at: 'two_factor_confirmed_at',
    is_two_factor_enabled: 'is_two_factor_enabled',
    remember_token: 'remember_token',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Verification_tokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Verification_tokenScalarFieldEnum = (typeof Verification_tokenScalarFieldEnum)[keyof typeof Verification_tokenScalarFieldEnum]


  export const Password_reset_tokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Password_reset_tokenScalarFieldEnum = (typeof Password_reset_tokenScalarFieldEnum)[keyof typeof Password_reset_tokenScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    message: 'message',
    type: 'type',
    is_read: 'is_read',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const Sale_officesScalarFieldEnum: {
    id: 'id',
    site_code: 'site_code',
    site_office_name_th: 'site_office_name_th',
    site_office_name_en: 'site_office_name_en',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Sale_officesScalarFieldEnum = (typeof Sale_officesScalarFieldEnum)[keyof typeof Sale_officesScalarFieldEnum]


  export const DepartmentsScalarFieldEnum: {
    id: 'id',
    department_code: 'department_code',
    sale_office_id: 'sale_office_id',
    description: 'description',
    group_code: 'group_code',
    ship_id: 'ship_id',
    is_default: 'is_default',
    name_th: 'name_th',
    name_en: 'name_en',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type DepartmentsScalarFieldEnum = (typeof DepartmentsScalarFieldEnum)[keyof typeof DepartmentsScalarFieldEnum]


  export const Factory_sale_officeScalarFieldEnum: {
    id: 'id',
    sale_office_id: 'sale_office_id',
    factory_id: 'factory_id',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Factory_sale_officeScalarFieldEnum = (typeof Factory_sale_officeScalarFieldEnum)[keyof typeof Factory_sale_officeScalarFieldEnum]


  export const FactoriesScalarFieldEnum: {
    id: 'id',
    price: 'price',
    address: 'address',
    post: 'post',
    tel: 'tel',
    tax_id: 'tax_id',
    name_th: 'name_th',
    name_en: 'name_en',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type FactoriesScalarFieldEnum = (typeof FactoriesScalarFieldEnum)[keyof typeof FactoriesScalarFieldEnum]


  export const MachinesScalarFieldEnum: {
    id: 'id',
    facetory_id: 'facetory_id',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type MachinesScalarFieldEnum = (typeof MachinesScalarFieldEnum)[keyof typeof MachinesScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    sale_office_id: 'sale_office_id',
    factory_sale_office_id: 'factory_sale_office_id',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const MaterialsScalarFieldEnum: {
    id: 'id',
    material_code: 'material_code',
    material_name_th: 'material_name_th',
    material_name_en: 'material_name_en',
    long_meterial_name: 'long_meterial_name',
    material_type_id: 'material_type_id',
    material_unit_id: 'material_unit_id',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type MaterialsScalarFieldEnum = (typeof MaterialsScalarFieldEnum)[keyof typeof MaterialsScalarFieldEnum]


  export const Material_typesScalarFieldEnum: {
    id: 'id',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Material_typesScalarFieldEnum = (typeof Material_typesScalarFieldEnum)[keyof typeof Material_typesScalarFieldEnum]


  export const Item_units_meauresScalarFieldEnum: {
    id: 'id',
    material_id: 'material_id',
    packing: 'packing',
    qty: 'qty',
    countable_unit_id: 'countable_unit_id',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Item_units_meauresScalarFieldEnum = (typeof Item_units_meauresScalarFieldEnum)[keyof typeof Item_units_meauresScalarFieldEnum]


  export const ItemsScalarFieldEnum: {
    id: 'id',
    material_id: 'material_id',
    saleoffice_id: 'saleoffice_id',
    department_id: 'department_id',
    item_category_id: 'item_category_id',
    stock_location_id: 'stock_location_id',
    name_th: 'name_th',
    name_en: 'name_en',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type ItemsScalarFieldEnum = (typeof ItemsScalarFieldEnum)[keyof typeof ItemsScalarFieldEnum]


  export const Items_detailsScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    sale_office_id: 'sale_office_id',
    qr_code_number: 'qr_code_number',
    product_lot_number: 'product_lot_number',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Items_detailsScalarFieldEnum = (typeof Items_detailsScalarFieldEnum)[keyof typeof Items_detailsScalarFieldEnum]


  export const Item_categoriesScalarFieldEnum: {
    id: 'id',
    type_id: 'type_id',
    sale_office_id: 'sale_office_id',
    department_id: 'department_id',
    stock_location_id: 'stock_location_id',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Item_categoriesScalarFieldEnum = (typeof Item_categoriesScalarFieldEnum)[keyof typeof Item_categoriesScalarFieldEnum]


  export const TypesScalarFieldEnum: {
    id: 'id',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type TypesScalarFieldEnum = (typeof TypesScalarFieldEnum)[keyof typeof TypesScalarFieldEnum]


  export const Item_pricesScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    price: 'price',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Item_pricesScalarFieldEnum = (typeof Item_pricesScalarFieldEnum)[keyof typeof Item_pricesScalarFieldEnum]


  export const DirtiesScalarFieldEnum: {
    id: 'id',
    dirty_doc_no: 'dirty_doc_no',
    dirty_doc_date: 'dirty_doc_date',
    sale_office_id: 'sale_office_id',
    department_id: 'department_id',
    factory_id: 'factory_id',
    user_id: 'user_id',
    signature: 'signature',
    sign_factory: 'sign_factory',
    sign_factory_time: 'sign_factory_time',
    sign_NH: 'sign_NH',
    sign_NH_time: 'sign_NH_time',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type DirtiesScalarFieldEnum = (typeof DirtiesScalarFieldEnum)[keyof typeof DirtiesScalarFieldEnum]


  export const Dirty_detailsScalarFieldEnum: {
    id: 'id',
    dirty_id: 'dirty_id',
    department_id: 'department_id',
    item_id: 'item_id',
    unit_id: 'unit_id',
    user_id: 'user_id',
    qty: 'qty',
    receive_qty: 'receive_qty',
    weight: 'weight',
    is_cancel: 'is_cancel',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Dirty_detailsScalarFieldEnum = (typeof Dirty_detailsScalarFieldEnum)[keyof typeof Dirty_detailsScalarFieldEnum]


  export const Customer_group_typesScalarFieldEnum: {
    id: 'id',
    level: 'level',
    group: 'group',
    type: 'type',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Customer_group_typesScalarFieldEnum = (typeof Customer_group_typesScalarFieldEnum)[keyof typeof Customer_group_typesScalarFieldEnum]


  export const Customer_groupsScalarFieldEnum: {
    id: 'id',
    sale_office_id: 'sale_office_id',
    customer_group_type_id: 'customer_group_type_id',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Customer_groupsScalarFieldEnum = (typeof Customer_groupsScalarFieldEnum)[keyof typeof Customer_groupsScalarFieldEnum]


  export const Stock_locationsScalarFieldEnum: {
    id: 'id',
    department_id: 'department_id',
    sale_office_id: 'sale_office_id',
    site_short_code: 'site_short_code',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Stock_locationsScalarFieldEnum = (typeof Stock_locationsScalarFieldEnum)[keyof typeof Stock_locationsScalarFieldEnum]


  export const ShelfcountsScalarFieldEnum: {
    id: 'id',
    sale_office_id: 'sale_office_id',
    doc_no: 'doc_no',
    doc_date: 'doc_date',
    shelfcount_doc_no: 'shelfcount_doc_no',
    department_id: 'department_id',
    is_request: 'is_request',
    delivery_time: 'delivery_time',
    sc_time: 'sc_time',
    is_mobile: 'is_mobile',
    complete_user: 'complete_user',
    complete_date: 'complete_date',
    cancel_user_id: 'cancel_user_id',
    cancel_remark: 'cancel_remark',
    site_short_code: 'site_short_code',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type ShelfcountsScalarFieldEnum = (typeof ShelfcountsScalarFieldEnum)[keyof typeof ShelfcountsScalarFieldEnum]


  export const Shelfcount_detailsScalarFieldEnum: {
    id: 'id',
    shelfcount_id: 'shelfcount_id',
    item_id: 'item_id',
    unit_id: 'unit_id',
    par_qty: 'par_qty',
    cc_qty: 'cc_qty',
    total_qty: 'total_qty',
    over_par: 'over_par',
    short: 'short',
    over: 'over',
    weight: 'weight',
    price: 'price',
    category_price: 'category_price',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Shelfcount_detailsScalarFieldEnum = (typeof Shelfcount_detailsScalarFieldEnum)[keyof typeof Shelfcount_detailsScalarFieldEnum]


  export const DamagesScalarFieldEnum: {
    id: 'id',
    doc_no: 'doc_no',
    doc_date: 'doc_date',
    ref_doc_no: 'ref_doc_no',
    sale_office_id: 'sale_office_id',
    department_id: 'department_id',
    total: 'total',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH',
    sign_factory_time: 'sign_factory_time',
    sign_NH_time: 'sign_NH_time',
    factory_id: 'factory_id',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type DamagesScalarFieldEnum = (typeof DamagesScalarFieldEnum)[keyof typeof DamagesScalarFieldEnum]


  export const Damage_detailsScalarFieldEnum: {
    id: 'id',
    damage_id: 'damage_id',
    item_id: 'item_id',
    unit_id: 'unit_id',
    qty: 'qty',
    weight: 'weight',
    is_cancel: 'is_cancel',
    is_checklist: 'is_checklist',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Damage_detailsScalarFieldEnum = (typeof Damage_detailsScalarFieldEnum)[keyof typeof Damage_detailsScalarFieldEnum]


  export const ShipsScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    site_short_code: 'site_short_code',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type ShipsScalarFieldEnum = (typeof ShipsScalarFieldEnum)[keyof typeof ShipsScalarFieldEnum]


  export const New_linensScalarFieldEnum: {
    id: 'id',
    doc_no: 'doc_no',
    doc_date: 'doc_date',
    ref_doc_no: 'ref_doc_no',
    sale_office_id: 'sale_office_id',
    department_id: 'department_id',
    total: 'total',
    is_recive: 'is_recive',
    receive_date: 'receive_date',
    receive_detail: 'receive_detail',
    is_process: 'is_process',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH',
    sign_factory_time: 'sign_factory_time',
    sign_NH_time: 'sign_NH_time',
    factory_id: 'factory_id',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type New_linensScalarFieldEnum = (typeof New_linensScalarFieldEnum)[keyof typeof New_linensScalarFieldEnum]


  export const New_linen_detailsScalarFieldEnum: {
    id: 'id',
    new_linen_id: 'new_linen_id',
    department_id: 'department_id',
    item_id: 'item_id',
    unit_id: 'unit_id',
    qty: 'qty',
    receive_qty: 'receive_qty',
    weight: 'weight',
    is_cancel: 'is_cancel',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type New_linen_detailsScalarFieldEnum = (typeof New_linen_detailsScalarFieldEnum)[keyof typeof New_linen_detailsScalarFieldEnum]


  export const Repair_washsScalarFieldEnum: {
    id: 'id',
    doc_no: 'doc_no',
    doc_date: 'doc_date',
    ref_doc_no: 'ref_doc_no',
    sale_office_id: 'sale_office_id',
    department_id: 'department_id',
    clean_id: 'clean_id',
    total: 'total',
    is_recive: 'is_recive',
    receive_date: 'receive_date',
    receive_detail: 'receive_detail',
    is_process: 'is_process',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH',
    sign_factory_time: 'sign_factory_time',
    sign_NH_time: 'sign_NH_time',
    factory_id: 'factory_id',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Repair_washsScalarFieldEnum = (typeof Repair_washsScalarFieldEnum)[keyof typeof Repair_washsScalarFieldEnum]


  export const Repair_wash_detailsScalarFieldEnum: {
    id: 'id',
    repair_wash_id: 'repair_wash_id',
    item_id: 'item_id',
    unit_id: 'unit_id',
    qty: 'qty',
    receive_qty: 'receive_qty',
    weight: 'weight',
    is_cancel: 'is_cancel',
    is_checklist: 'is_checklist',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Repair_wash_detailsScalarFieldEnum = (typeof Repair_wash_detailsScalarFieldEnum)[keyof typeof Repair_wash_detailsScalarFieldEnum]


  export const CleansScalarFieldEnum: {
    id: 'id',
    clean_doc_no: 'clean_doc_no',
    doc_date: 'doc_date',
    sale_office_id: 'sale_office_id',
    department_id: 'department_id',
    dirty_id: 'dirty_id',
    user_id: 'user_id',
    signature: 'signature',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH',
    sign_factory_time: 'sign_factory_time',
    sign_NH_time: 'sign_NH_time',
    factory_id: 'factory_id',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type CleansScalarFieldEnum = (typeof CleansScalarFieldEnum)[keyof typeof CleansScalarFieldEnum]


  export const Clean_detailsScalarFieldEnum: {
    id: 'id',
    clean_id: 'clean_id',
    item_id: 'item_id',
    unit_id: 'unit_id',
    qty: 'qty',
    weight: 'weight',
    request_name: 'request_name',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Clean_detailsScalarFieldEnum = (typeof Clean_detailsScalarFieldEnum)[keyof typeof Clean_detailsScalarFieldEnum]


  export const Return_washsScalarFieldEnum: {
    id: 'id',
    doc_no: 'doc_no',
    doc_date: 'doc_date',
    ref_doc_no: 'ref_doc_no',
    sale_office_id: 'sale_office_id',
    department_id: 'department_id',
    total: 'total',
    dirty_id: 'dirty_id',
    user_id: 'user_id',
    signature: 'signature',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH',
    sign_factory_time: 'sign_factory_time',
    sign_NH_time: 'sign_NH_time',
    factory_id: 'factory_id',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Return_washsScalarFieldEnum = (typeof Return_washsScalarFieldEnum)[keyof typeof Return_washsScalarFieldEnum]


  export const Retrun_wash_detailsScalarFieldEnum: {
    id: 'id',
    return_wash_id: 'return_wash_id',
    item_id: 'item_id',
    unit_id: 'unit_id',
    qty: 'qty',
    weight: 'weight',
    is_cancel: 'is_cancel',
    is_checklist: 'is_checklist',
    request_name: 'request_name',
    description: 'description',
    status: 'status',
    create_at: 'create_at',
    update_at: 'update_at'
  };

  export type Retrun_wash_detailsScalarFieldEnum = (typeof Retrun_wash_detailsScalarFieldEnum)[keyof typeof Retrun_wash_detailsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const userOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    password: 'password',
    two_factor_secret: 'two_factor_secret',
    two_factor_recovery_codes: 'two_factor_recovery_codes',
    remember_token: 'remember_token'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  export const verification_tokenOrderByRelevanceFieldEnum: {
    email: 'email',
    token: 'token'
  };

  export type verification_tokenOrderByRelevanceFieldEnum = (typeof verification_tokenOrderByRelevanceFieldEnum)[keyof typeof verification_tokenOrderByRelevanceFieldEnum]


  export const password_reset_tokenOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token'
  };

  export type password_reset_tokenOrderByRelevanceFieldEnum = (typeof password_reset_tokenOrderByRelevanceFieldEnum)[keyof typeof password_reset_tokenOrderByRelevanceFieldEnum]


  export const notificationsOrderByRelevanceFieldEnum: {
    title: 'title',
    message: 'message',
    type: 'type'
  };

  export type notificationsOrderByRelevanceFieldEnum = (typeof notificationsOrderByRelevanceFieldEnum)[keyof typeof notificationsOrderByRelevanceFieldEnum]


  export const sale_officesOrderByRelevanceFieldEnum: {
    site_code: 'site_code',
    site_office_name_th: 'site_office_name_th',
    site_office_name_en: 'site_office_name_en'
  };

  export type sale_officesOrderByRelevanceFieldEnum = (typeof sale_officesOrderByRelevanceFieldEnum)[keyof typeof sale_officesOrderByRelevanceFieldEnum]


  export const departmentsOrderByRelevanceFieldEnum: {
    department_code: 'department_code',
    description: 'description',
    group_code: 'group_code',
    name_th: 'name_th',
    name_en: 'name_en'
  };

  export type departmentsOrderByRelevanceFieldEnum = (typeof departmentsOrderByRelevanceFieldEnum)[keyof typeof departmentsOrderByRelevanceFieldEnum]


  export const factoriesOrderByRelevanceFieldEnum: {
    address: 'address',
    post: 'post',
    tel: 'tel',
    name_th: 'name_th',
    name_en: 'name_en'
  };

  export type factoriesOrderByRelevanceFieldEnum = (typeof factoriesOrderByRelevanceFieldEnum)[keyof typeof factoriesOrderByRelevanceFieldEnum]


  export const contactOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type contactOrderByRelevanceFieldEnum = (typeof contactOrderByRelevanceFieldEnum)[keyof typeof contactOrderByRelevanceFieldEnum]


  export const materialsOrderByRelevanceFieldEnum: {
    material_name_th: 'material_name_th',
    material_name_en: 'material_name_en',
    long_meterial_name: 'long_meterial_name',
    description: 'description'
  };

  export type materialsOrderByRelevanceFieldEnum = (typeof materialsOrderByRelevanceFieldEnum)[keyof typeof materialsOrderByRelevanceFieldEnum]


  export const material_typesOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type material_typesOrderByRelevanceFieldEnum = (typeof material_typesOrderByRelevanceFieldEnum)[keyof typeof material_typesOrderByRelevanceFieldEnum]


  export const item_units_meauresOrderByRelevanceFieldEnum: {
    packing: 'packing',
    countable_unit_id: 'countable_unit_id',
    description: 'description'
  };

  export type item_units_meauresOrderByRelevanceFieldEnum = (typeof item_units_meauresOrderByRelevanceFieldEnum)[keyof typeof item_units_meauresOrderByRelevanceFieldEnum]


  export const itemsOrderByRelevanceFieldEnum: {
    name_th: 'name_th',
    name_en: 'name_en'
  };

  export type itemsOrderByRelevanceFieldEnum = (typeof itemsOrderByRelevanceFieldEnum)[keyof typeof itemsOrderByRelevanceFieldEnum]


  export const items_detailsOrderByRelevanceFieldEnum: {
    qr_code_number: 'qr_code_number',
    product_lot_number: 'product_lot_number',
    description: 'description'
  };

  export type items_detailsOrderByRelevanceFieldEnum = (typeof items_detailsOrderByRelevanceFieldEnum)[keyof typeof items_detailsOrderByRelevanceFieldEnum]


  export const item_categoriesOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type item_categoriesOrderByRelevanceFieldEnum = (typeof item_categoriesOrderByRelevanceFieldEnum)[keyof typeof item_categoriesOrderByRelevanceFieldEnum]


  export const typesOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type typesOrderByRelevanceFieldEnum = (typeof typesOrderByRelevanceFieldEnum)[keyof typeof typesOrderByRelevanceFieldEnum]


  export const item_pricesOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type item_pricesOrderByRelevanceFieldEnum = (typeof item_pricesOrderByRelevanceFieldEnum)[keyof typeof item_pricesOrderByRelevanceFieldEnum]


  export const dirtiesOrderByRelevanceFieldEnum: {
    dirty_doc_no: 'dirty_doc_no',
    signature: 'signature',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH'
  };

  export type dirtiesOrderByRelevanceFieldEnum = (typeof dirtiesOrderByRelevanceFieldEnum)[keyof typeof dirtiesOrderByRelevanceFieldEnum]


  export const customer_group_typesOrderByRelevanceFieldEnum: {
    level: 'level',
    group: 'group',
    type: 'type'
  };

  export type customer_group_typesOrderByRelevanceFieldEnum = (typeof customer_group_typesOrderByRelevanceFieldEnum)[keyof typeof customer_group_typesOrderByRelevanceFieldEnum]


  export const stock_locationsOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type stock_locationsOrderByRelevanceFieldEnum = (typeof stock_locationsOrderByRelevanceFieldEnum)[keyof typeof stock_locationsOrderByRelevanceFieldEnum]


  export const shelfcountsOrderByRelevanceFieldEnum: {
    shelfcount_doc_no: 'shelfcount_doc_no',
    complete_user: 'complete_user',
    cancel_remark: 'cancel_remark',
    description: 'description'
  };

  export type shelfcountsOrderByRelevanceFieldEnum = (typeof shelfcountsOrderByRelevanceFieldEnum)[keyof typeof shelfcountsOrderByRelevanceFieldEnum]


  export const damagesOrderByRelevanceFieldEnum: {
    doc_no: 'doc_no',
    ref_doc_no: 'ref_doc_no',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH'
  };

  export type damagesOrderByRelevanceFieldEnum = (typeof damagesOrderByRelevanceFieldEnum)[keyof typeof damagesOrderByRelevanceFieldEnum]


  export const damage_detailsOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type damage_detailsOrderByRelevanceFieldEnum = (typeof damage_detailsOrderByRelevanceFieldEnum)[keyof typeof damage_detailsOrderByRelevanceFieldEnum]


  export const shipsOrderByRelevanceFieldEnum: {
    site_short_code: 'site_short_code',
    description: 'description'
  };

  export type shipsOrderByRelevanceFieldEnum = (typeof shipsOrderByRelevanceFieldEnum)[keyof typeof shipsOrderByRelevanceFieldEnum]


  export const new_linensOrderByRelevanceFieldEnum: {
    doc_no: 'doc_no',
    ref_doc_no: 'ref_doc_no',
    receive_detail: 'receive_detail',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH'
  };

  export type new_linensOrderByRelevanceFieldEnum = (typeof new_linensOrderByRelevanceFieldEnum)[keyof typeof new_linensOrderByRelevanceFieldEnum]


  export const new_linen_detailsOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type new_linen_detailsOrderByRelevanceFieldEnum = (typeof new_linen_detailsOrderByRelevanceFieldEnum)[keyof typeof new_linen_detailsOrderByRelevanceFieldEnum]


  export const repair_washsOrderByRelevanceFieldEnum: {
    doc_no: 'doc_no',
    ref_doc_no: 'ref_doc_no',
    receive_detail: 'receive_detail',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH'
  };

  export type repair_washsOrderByRelevanceFieldEnum = (typeof repair_washsOrderByRelevanceFieldEnum)[keyof typeof repair_washsOrderByRelevanceFieldEnum]


  export const repair_wash_detailsOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type repair_wash_detailsOrderByRelevanceFieldEnum = (typeof repair_wash_detailsOrderByRelevanceFieldEnum)[keyof typeof repair_wash_detailsOrderByRelevanceFieldEnum]


  export const cleansOrderByRelevanceFieldEnum: {
    clean_doc_no: 'clean_doc_no',
    signature: 'signature',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH'
  };

  export type cleansOrderByRelevanceFieldEnum = (typeof cleansOrderByRelevanceFieldEnum)[keyof typeof cleansOrderByRelevanceFieldEnum]


  export const clean_detailsOrderByRelevanceFieldEnum: {
    request_name: 'request_name',
    description: 'description'
  };

  export type clean_detailsOrderByRelevanceFieldEnum = (typeof clean_detailsOrderByRelevanceFieldEnum)[keyof typeof clean_detailsOrderByRelevanceFieldEnum]


  export const return_washsOrderByRelevanceFieldEnum: {
    doc_no: 'doc_no',
    ref_doc_no: 'ref_doc_no',
    signature: 'signature',
    sign_factory: 'sign_factory',
    sign_NH: 'sign_NH'
  };

  export type return_washsOrderByRelevanceFieldEnum = (typeof return_washsOrderByRelevanceFieldEnum)[keyof typeof return_washsOrderByRelevanceFieldEnum]


  export const retrun_wash_detailsOrderByRelevanceFieldEnum: {
    request_name: 'request_name',
    description: 'description'
  };

  export type retrun_wash_detailsOrderByRelevanceFieldEnum = (typeof retrun_wash_detailsOrderByRelevanceFieldEnum)[keyof typeof retrun_wash_detailsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    name?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    permission_id?: IntFilter<"user"> | number
    email_verified_at?: DateTimeNullableFilter<"user"> | Date | string | null
    password?: StringFilter<"user"> | string
    two_factor_secret?: StringNullableFilter<"user"> | string | null
    two_factor_recovery_codes?: StringNullableFilter<"user"> | string | null
    two_factor_confirmed_at?: DateTimeNullableFilter<"user"> | Date | string | null
    is_two_factor_enabled?: BoolFilter<"user"> | boolean
    remember_token?: StringNullableFilter<"user"> | string | null
    create_at?: DateTimeFilter<"user"> | Date | string
    update_at?: DateTimeFilter<"user"> | Date | string
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    permission_id?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrderInput | SortOrder
    two_factor_recovery_codes?: SortOrderInput | SortOrder
    two_factor_confirmed_at?: SortOrderInput | SortOrder
    is_two_factor_enabled?: SortOrder
    remember_token?: SortOrderInput | SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringFilter<"user"> | string
    permission_id?: IntFilter<"user"> | number
    email_verified_at?: DateTimeNullableFilter<"user"> | Date | string | null
    password?: StringFilter<"user"> | string
    two_factor_secret?: StringNullableFilter<"user"> | string | null
    two_factor_recovery_codes?: StringNullableFilter<"user"> | string | null
    two_factor_confirmed_at?: DateTimeNullableFilter<"user"> | Date | string | null
    is_two_factor_enabled?: BoolFilter<"user"> | boolean
    remember_token?: StringNullableFilter<"user"> | string | null
    create_at?: DateTimeFilter<"user"> | Date | string
    update_at?: DateTimeFilter<"user"> | Date | string
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    permission_id?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrderInput | SortOrder
    two_factor_recovery_codes?: SortOrderInput | SortOrder
    two_factor_confirmed_at?: SortOrderInput | SortOrder
    is_two_factor_enabled?: SortOrder
    remember_token?: SortOrderInput | SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    name?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    permission_id?: IntWithAggregatesFilter<"user"> | number
    email_verified_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    password?: StringWithAggregatesFilter<"user"> | string
    two_factor_secret?: StringNullableWithAggregatesFilter<"user"> | string | null
    two_factor_recovery_codes?: StringNullableWithAggregatesFilter<"user"> | string | null
    two_factor_confirmed_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    is_two_factor_enabled?: BoolWithAggregatesFilter<"user"> | boolean
    remember_token?: StringNullableWithAggregatesFilter<"user"> | string | null
    create_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type verification_tokenWhereInput = {
    AND?: verification_tokenWhereInput | verification_tokenWhereInput[]
    OR?: verification_tokenWhereInput[]
    NOT?: verification_tokenWhereInput | verification_tokenWhereInput[]
    id?: IntFilter<"verification_token"> | number
    email?: StringFilter<"verification_token"> | string
    token?: StringFilter<"verification_token"> | string
    expires?: DateTimeFilter<"verification_token"> | Date | string
    create_at?: DateTimeFilter<"verification_token"> | Date | string
    update_at?: DateTimeFilter<"verification_token"> | Date | string
  }

  export type verification_tokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: verification_tokenOrderByRelevanceInput
  }

  export type verification_tokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    token?: string
    email_token?: verification_tokenEmailTokenCompoundUniqueInput
    AND?: verification_tokenWhereInput | verification_tokenWhereInput[]
    OR?: verification_tokenWhereInput[]
    NOT?: verification_tokenWhereInput | verification_tokenWhereInput[]
    expires?: DateTimeFilter<"verification_token"> | Date | string
    create_at?: DateTimeFilter<"verification_token"> | Date | string
    update_at?: DateTimeFilter<"verification_token"> | Date | string
  }, "id" | "email" | "token" | "email_token">

  export type verification_tokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: verification_tokenCountOrderByAggregateInput
    _avg?: verification_tokenAvgOrderByAggregateInput
    _max?: verification_tokenMaxOrderByAggregateInput
    _min?: verification_tokenMinOrderByAggregateInput
    _sum?: verification_tokenSumOrderByAggregateInput
  }

  export type verification_tokenScalarWhereWithAggregatesInput = {
    AND?: verification_tokenScalarWhereWithAggregatesInput | verification_tokenScalarWhereWithAggregatesInput[]
    OR?: verification_tokenScalarWhereWithAggregatesInput[]
    NOT?: verification_tokenScalarWhereWithAggregatesInput | verification_tokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"verification_token"> | number
    email?: StringWithAggregatesFilter<"verification_token"> | string
    token?: StringWithAggregatesFilter<"verification_token"> | string
    expires?: DateTimeWithAggregatesFilter<"verification_token"> | Date | string
    create_at?: DateTimeWithAggregatesFilter<"verification_token"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"verification_token"> | Date | string
  }

  export type password_reset_tokenWhereInput = {
    AND?: password_reset_tokenWhereInput | password_reset_tokenWhereInput[]
    OR?: password_reset_tokenWhereInput[]
    NOT?: password_reset_tokenWhereInput | password_reset_tokenWhereInput[]
    id?: StringFilter<"password_reset_token"> | string
    email?: StringFilter<"password_reset_token"> | string
    token?: StringFilter<"password_reset_token"> | string
    expires?: DateTimeFilter<"password_reset_token"> | Date | string
    create_at?: DateTimeFilter<"password_reset_token"> | Date | string
    update_at?: DateTimeFilter<"password_reset_token"> | Date | string
  }

  export type password_reset_tokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: password_reset_tokenOrderByRelevanceInput
  }

  export type password_reset_tokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: password_reset_tokenWhereInput | password_reset_tokenWhereInput[]
    OR?: password_reset_tokenWhereInput[]
    NOT?: password_reset_tokenWhereInput | password_reset_tokenWhereInput[]
    email?: StringFilter<"password_reset_token"> | string
    expires?: DateTimeFilter<"password_reset_token"> | Date | string
    create_at?: DateTimeFilter<"password_reset_token"> | Date | string
    update_at?: DateTimeFilter<"password_reset_token"> | Date | string
  }, "id" | "token">

  export type password_reset_tokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: password_reset_tokenCountOrderByAggregateInput
    _max?: password_reset_tokenMaxOrderByAggregateInput
    _min?: password_reset_tokenMinOrderByAggregateInput
  }

  export type password_reset_tokenScalarWhereWithAggregatesInput = {
    AND?: password_reset_tokenScalarWhereWithAggregatesInput | password_reset_tokenScalarWhereWithAggregatesInput[]
    OR?: password_reset_tokenScalarWhereWithAggregatesInput[]
    NOT?: password_reset_tokenScalarWhereWithAggregatesInput | password_reset_tokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"password_reset_token"> | string
    email?: StringWithAggregatesFilter<"password_reset_token"> | string
    token?: StringWithAggregatesFilter<"password_reset_token"> | string
    expires?: DateTimeWithAggregatesFilter<"password_reset_token"> | Date | string
    create_at?: DateTimeWithAggregatesFilter<"password_reset_token"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"password_reset_token"> | Date | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: IntFilter<"notifications"> | number
    user_id?: IntFilter<"notifications"> | number
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    type?: StringFilter<"notifications"> | string
    is_read?: BoolFilter<"notifications"> | boolean
    create_at?: DateTimeFilter<"notifications"> | Date | string
    update_at?: DateTimeFilter<"notifications"> | Date | string
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: notificationsOrderByRelevanceInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    user_id?: IntFilter<"notifications"> | number
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    type?: StringFilter<"notifications"> | string
    is_read?: BoolFilter<"notifications"> | boolean
    create_at?: DateTimeFilter<"notifications"> | Date | string
    update_at?: DateTimeFilter<"notifications"> | Date | string
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _avg?: notificationsAvgOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
    _sum?: notificationsSumOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notifications"> | number
    user_id?: IntWithAggregatesFilter<"notifications"> | number
    title?: StringWithAggregatesFilter<"notifications"> | string
    message?: StringWithAggregatesFilter<"notifications"> | string
    type?: StringWithAggregatesFilter<"notifications"> | string
    is_read?: BoolWithAggregatesFilter<"notifications"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
  }

  export type sale_officesWhereInput = {
    AND?: sale_officesWhereInput | sale_officesWhereInput[]
    OR?: sale_officesWhereInput[]
    NOT?: sale_officesWhereInput | sale_officesWhereInput[]
    id?: IntFilter<"sale_offices"> | number
    site_code?: StringFilter<"sale_offices"> | string
    site_office_name_th?: StringFilter<"sale_offices"> | string
    site_office_name_en?: StringFilter<"sale_offices"> | string
    status?: BoolFilter<"sale_offices"> | boolean
    create_at?: DateTimeFilter<"sale_offices"> | Date | string
    update_at?: DateTimeFilter<"sale_offices"> | Date | string
  }

  export type sale_officesOrderByWithRelationInput = {
    id?: SortOrder
    site_code?: SortOrder
    site_office_name_th?: SortOrder
    site_office_name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: sale_officesOrderByRelevanceInput
  }

  export type sale_officesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: sale_officesWhereInput | sale_officesWhereInput[]
    OR?: sale_officesWhereInput[]
    NOT?: sale_officesWhereInput | sale_officesWhereInput[]
    site_code?: StringFilter<"sale_offices"> | string
    site_office_name_th?: StringFilter<"sale_offices"> | string
    site_office_name_en?: StringFilter<"sale_offices"> | string
    status?: BoolFilter<"sale_offices"> | boolean
    create_at?: DateTimeFilter<"sale_offices"> | Date | string
    update_at?: DateTimeFilter<"sale_offices"> | Date | string
  }, "id">

  export type sale_officesOrderByWithAggregationInput = {
    id?: SortOrder
    site_code?: SortOrder
    site_office_name_th?: SortOrder
    site_office_name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: sale_officesCountOrderByAggregateInput
    _avg?: sale_officesAvgOrderByAggregateInput
    _max?: sale_officesMaxOrderByAggregateInput
    _min?: sale_officesMinOrderByAggregateInput
    _sum?: sale_officesSumOrderByAggregateInput
  }

  export type sale_officesScalarWhereWithAggregatesInput = {
    AND?: sale_officesScalarWhereWithAggregatesInput | sale_officesScalarWhereWithAggregatesInput[]
    OR?: sale_officesScalarWhereWithAggregatesInput[]
    NOT?: sale_officesScalarWhereWithAggregatesInput | sale_officesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sale_offices"> | number
    site_code?: StringWithAggregatesFilter<"sale_offices"> | string
    site_office_name_th?: StringWithAggregatesFilter<"sale_offices"> | string
    site_office_name_en?: StringWithAggregatesFilter<"sale_offices"> | string
    status?: BoolWithAggregatesFilter<"sale_offices"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"sale_offices"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"sale_offices"> | Date | string
  }

  export type departmentsWhereInput = {
    AND?: departmentsWhereInput | departmentsWhereInput[]
    OR?: departmentsWhereInput[]
    NOT?: departmentsWhereInput | departmentsWhereInput[]
    id?: IntFilter<"departments"> | number
    department_code?: StringFilter<"departments"> | string
    sale_office_id?: IntFilter<"departments"> | number
    description?: StringFilter<"departments"> | string
    group_code?: StringFilter<"departments"> | string
    ship_id?: IntFilter<"departments"> | number
    is_default?: BoolFilter<"departments"> | boolean
    name_th?: StringFilter<"departments"> | string
    name_en?: StringFilter<"departments"> | string
    status?: BoolFilter<"departments"> | boolean
    create_at?: DateTimeFilter<"departments"> | Date | string
    update_at?: DateTimeFilter<"departments"> | Date | string
  }

  export type departmentsOrderByWithRelationInput = {
    id?: SortOrder
    department_code?: SortOrder
    sale_office_id?: SortOrder
    description?: SortOrder
    group_code?: SortOrder
    ship_id?: SortOrder
    is_default?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: departmentsOrderByRelevanceInput
  }

  export type departmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: departmentsWhereInput | departmentsWhereInput[]
    OR?: departmentsWhereInput[]
    NOT?: departmentsWhereInput | departmentsWhereInput[]
    department_code?: StringFilter<"departments"> | string
    sale_office_id?: IntFilter<"departments"> | number
    description?: StringFilter<"departments"> | string
    group_code?: StringFilter<"departments"> | string
    ship_id?: IntFilter<"departments"> | number
    is_default?: BoolFilter<"departments"> | boolean
    name_th?: StringFilter<"departments"> | string
    name_en?: StringFilter<"departments"> | string
    status?: BoolFilter<"departments"> | boolean
    create_at?: DateTimeFilter<"departments"> | Date | string
    update_at?: DateTimeFilter<"departments"> | Date | string
  }, "id">

  export type departmentsOrderByWithAggregationInput = {
    id?: SortOrder
    department_code?: SortOrder
    sale_office_id?: SortOrder
    description?: SortOrder
    group_code?: SortOrder
    ship_id?: SortOrder
    is_default?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: departmentsCountOrderByAggregateInput
    _avg?: departmentsAvgOrderByAggregateInput
    _max?: departmentsMaxOrderByAggregateInput
    _min?: departmentsMinOrderByAggregateInput
    _sum?: departmentsSumOrderByAggregateInput
  }

  export type departmentsScalarWhereWithAggregatesInput = {
    AND?: departmentsScalarWhereWithAggregatesInput | departmentsScalarWhereWithAggregatesInput[]
    OR?: departmentsScalarWhereWithAggregatesInput[]
    NOT?: departmentsScalarWhereWithAggregatesInput | departmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"departments"> | number
    department_code?: StringWithAggregatesFilter<"departments"> | string
    sale_office_id?: IntWithAggregatesFilter<"departments"> | number
    description?: StringWithAggregatesFilter<"departments"> | string
    group_code?: StringWithAggregatesFilter<"departments"> | string
    ship_id?: IntWithAggregatesFilter<"departments"> | number
    is_default?: BoolWithAggregatesFilter<"departments"> | boolean
    name_th?: StringWithAggregatesFilter<"departments"> | string
    name_en?: StringWithAggregatesFilter<"departments"> | string
    status?: BoolWithAggregatesFilter<"departments"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"departments"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"departments"> | Date | string
  }

  export type factory_sale_officeWhereInput = {
    AND?: factory_sale_officeWhereInput | factory_sale_officeWhereInput[]
    OR?: factory_sale_officeWhereInput[]
    NOT?: factory_sale_officeWhereInput | factory_sale_officeWhereInput[]
    id?: IntFilter<"factory_sale_office"> | number
    sale_office_id?: IntFilter<"factory_sale_office"> | number
    factory_id?: IntFilter<"factory_sale_office"> | number
    status?: BoolFilter<"factory_sale_office"> | boolean
    create_at?: DateTimeFilter<"factory_sale_office"> | Date | string
    update_at?: DateTimeFilter<"factory_sale_office"> | Date | string
  }

  export type factory_sale_officeOrderByWithRelationInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type factory_sale_officeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: factory_sale_officeWhereInput | factory_sale_officeWhereInput[]
    OR?: factory_sale_officeWhereInput[]
    NOT?: factory_sale_officeWhereInput | factory_sale_officeWhereInput[]
    sale_office_id?: IntFilter<"factory_sale_office"> | number
    factory_id?: IntFilter<"factory_sale_office"> | number
    status?: BoolFilter<"factory_sale_office"> | boolean
    create_at?: DateTimeFilter<"factory_sale_office"> | Date | string
    update_at?: DateTimeFilter<"factory_sale_office"> | Date | string
  }, "id">

  export type factory_sale_officeOrderByWithAggregationInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: factory_sale_officeCountOrderByAggregateInput
    _avg?: factory_sale_officeAvgOrderByAggregateInput
    _max?: factory_sale_officeMaxOrderByAggregateInput
    _min?: factory_sale_officeMinOrderByAggregateInput
    _sum?: factory_sale_officeSumOrderByAggregateInput
  }

  export type factory_sale_officeScalarWhereWithAggregatesInput = {
    AND?: factory_sale_officeScalarWhereWithAggregatesInput | factory_sale_officeScalarWhereWithAggregatesInput[]
    OR?: factory_sale_officeScalarWhereWithAggregatesInput[]
    NOT?: factory_sale_officeScalarWhereWithAggregatesInput | factory_sale_officeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"factory_sale_office"> | number
    sale_office_id?: IntWithAggregatesFilter<"factory_sale_office"> | number
    factory_id?: IntWithAggregatesFilter<"factory_sale_office"> | number
    status?: BoolWithAggregatesFilter<"factory_sale_office"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"factory_sale_office"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"factory_sale_office"> | Date | string
  }

  export type factoriesWhereInput = {
    AND?: factoriesWhereInput | factoriesWhereInput[]
    OR?: factoriesWhereInput[]
    NOT?: factoriesWhereInput | factoriesWhereInput[]
    id?: IntFilter<"factories"> | number
    price?: FloatFilter<"factories"> | number
    address?: StringFilter<"factories"> | string
    post?: StringFilter<"factories"> | string
    tel?: StringFilter<"factories"> | string
    tax_id?: IntFilter<"factories"> | number
    name_th?: StringFilter<"factories"> | string
    name_en?: StringFilter<"factories"> | string
    status?: BoolFilter<"factories"> | boolean
    create_at?: DateTimeFilter<"factories"> | Date | string
    update_at?: DateTimeFilter<"factories"> | Date | string
  }

  export type factoriesOrderByWithRelationInput = {
    id?: SortOrder
    price?: SortOrder
    address?: SortOrder
    post?: SortOrder
    tel?: SortOrder
    tax_id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: factoriesOrderByRelevanceInput
  }

  export type factoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: factoriesWhereInput | factoriesWhereInput[]
    OR?: factoriesWhereInput[]
    NOT?: factoriesWhereInput | factoriesWhereInput[]
    price?: FloatFilter<"factories"> | number
    address?: StringFilter<"factories"> | string
    post?: StringFilter<"factories"> | string
    tel?: StringFilter<"factories"> | string
    tax_id?: IntFilter<"factories"> | number
    name_th?: StringFilter<"factories"> | string
    name_en?: StringFilter<"factories"> | string
    status?: BoolFilter<"factories"> | boolean
    create_at?: DateTimeFilter<"factories"> | Date | string
    update_at?: DateTimeFilter<"factories"> | Date | string
  }, "id">

  export type factoriesOrderByWithAggregationInput = {
    id?: SortOrder
    price?: SortOrder
    address?: SortOrder
    post?: SortOrder
    tel?: SortOrder
    tax_id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: factoriesCountOrderByAggregateInput
    _avg?: factoriesAvgOrderByAggregateInput
    _max?: factoriesMaxOrderByAggregateInput
    _min?: factoriesMinOrderByAggregateInput
    _sum?: factoriesSumOrderByAggregateInput
  }

  export type factoriesScalarWhereWithAggregatesInput = {
    AND?: factoriesScalarWhereWithAggregatesInput | factoriesScalarWhereWithAggregatesInput[]
    OR?: factoriesScalarWhereWithAggregatesInput[]
    NOT?: factoriesScalarWhereWithAggregatesInput | factoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"factories"> | number
    price?: FloatWithAggregatesFilter<"factories"> | number
    address?: StringWithAggregatesFilter<"factories"> | string
    post?: StringWithAggregatesFilter<"factories"> | string
    tel?: StringWithAggregatesFilter<"factories"> | string
    tax_id?: IntWithAggregatesFilter<"factories"> | number
    name_th?: StringWithAggregatesFilter<"factories"> | string
    name_en?: StringWithAggregatesFilter<"factories"> | string
    status?: BoolWithAggregatesFilter<"factories"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"factories"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"factories"> | Date | string
  }

  export type machinesWhereInput = {
    AND?: machinesWhereInput | machinesWhereInput[]
    OR?: machinesWhereInput[]
    NOT?: machinesWhereInput | machinesWhereInput[]
    id?: IntFilter<"machines"> | number
    facetory_id?: IntFilter<"machines"> | number
    status?: BoolFilter<"machines"> | boolean
    create_at?: DateTimeFilter<"machines"> | Date | string
    update_at?: DateTimeFilter<"machines"> | Date | string
  }

  export type machinesOrderByWithRelationInput = {
    id?: SortOrder
    facetory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type machinesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: machinesWhereInput | machinesWhereInput[]
    OR?: machinesWhereInput[]
    NOT?: machinesWhereInput | machinesWhereInput[]
    facetory_id?: IntFilter<"machines"> | number
    status?: BoolFilter<"machines"> | boolean
    create_at?: DateTimeFilter<"machines"> | Date | string
    update_at?: DateTimeFilter<"machines"> | Date | string
  }, "id">

  export type machinesOrderByWithAggregationInput = {
    id?: SortOrder
    facetory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: machinesCountOrderByAggregateInput
    _avg?: machinesAvgOrderByAggregateInput
    _max?: machinesMaxOrderByAggregateInput
    _min?: machinesMinOrderByAggregateInput
    _sum?: machinesSumOrderByAggregateInput
  }

  export type machinesScalarWhereWithAggregatesInput = {
    AND?: machinesScalarWhereWithAggregatesInput | machinesScalarWhereWithAggregatesInput[]
    OR?: machinesScalarWhereWithAggregatesInput[]
    NOT?: machinesScalarWhereWithAggregatesInput | machinesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"machines"> | number
    facetory_id?: IntWithAggregatesFilter<"machines"> | number
    status?: BoolWithAggregatesFilter<"machines"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"machines"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"machines"> | Date | string
  }

  export type contactWhereInput = {
    AND?: contactWhereInput | contactWhereInput[]
    OR?: contactWhereInput[]
    NOT?: contactWhereInput | contactWhereInput[]
    id?: IntFilter<"contact"> | number
    sale_office_id?: IntFilter<"contact"> | number
    factory_sale_office_id?: IntFilter<"contact"> | number
    description?: StringFilter<"contact"> | string
    status?: BoolFilter<"contact"> | boolean
    create_at?: DateTimeFilter<"contact"> | Date | string
    update_at?: DateTimeFilter<"contact"> | Date | string
  }

  export type contactOrderByWithRelationInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_sale_office_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: contactOrderByRelevanceInput
  }

  export type contactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: contactWhereInput | contactWhereInput[]
    OR?: contactWhereInput[]
    NOT?: contactWhereInput | contactWhereInput[]
    sale_office_id?: IntFilter<"contact"> | number
    factory_sale_office_id?: IntFilter<"contact"> | number
    description?: StringFilter<"contact"> | string
    status?: BoolFilter<"contact"> | boolean
    create_at?: DateTimeFilter<"contact"> | Date | string
    update_at?: DateTimeFilter<"contact"> | Date | string
  }, "id">

  export type contactOrderByWithAggregationInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_sale_office_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: contactCountOrderByAggregateInput
    _avg?: contactAvgOrderByAggregateInput
    _max?: contactMaxOrderByAggregateInput
    _min?: contactMinOrderByAggregateInput
    _sum?: contactSumOrderByAggregateInput
  }

  export type contactScalarWhereWithAggregatesInput = {
    AND?: contactScalarWhereWithAggregatesInput | contactScalarWhereWithAggregatesInput[]
    OR?: contactScalarWhereWithAggregatesInput[]
    NOT?: contactScalarWhereWithAggregatesInput | contactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"contact"> | number
    sale_office_id?: IntWithAggregatesFilter<"contact"> | number
    factory_sale_office_id?: IntWithAggregatesFilter<"contact"> | number
    description?: StringWithAggregatesFilter<"contact"> | string
    status?: BoolWithAggregatesFilter<"contact"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"contact"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"contact"> | Date | string
  }

  export type materialsWhereInput = {
    AND?: materialsWhereInput | materialsWhereInput[]
    OR?: materialsWhereInput[]
    NOT?: materialsWhereInput | materialsWhereInput[]
    id?: IntFilter<"materials"> | number
    material_code?: IntFilter<"materials"> | number
    material_name_th?: StringFilter<"materials"> | string
    material_name_en?: StringFilter<"materials"> | string
    long_meterial_name?: StringFilter<"materials"> | string
    material_type_id?: IntFilter<"materials"> | number
    material_unit_id?: IntFilter<"materials"> | number
    description?: StringFilter<"materials"> | string
    status?: BoolFilter<"materials"> | boolean
    create_at?: DateTimeFilter<"materials"> | Date | string
    update_at?: DateTimeFilter<"materials"> | Date | string
  }

  export type materialsOrderByWithRelationInput = {
    id?: SortOrder
    material_code?: SortOrder
    material_name_th?: SortOrder
    material_name_en?: SortOrder
    long_meterial_name?: SortOrder
    material_type_id?: SortOrder
    material_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: materialsOrderByRelevanceInput
  }

  export type materialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: materialsWhereInput | materialsWhereInput[]
    OR?: materialsWhereInput[]
    NOT?: materialsWhereInput | materialsWhereInput[]
    material_code?: IntFilter<"materials"> | number
    material_name_th?: StringFilter<"materials"> | string
    material_name_en?: StringFilter<"materials"> | string
    long_meterial_name?: StringFilter<"materials"> | string
    material_type_id?: IntFilter<"materials"> | number
    material_unit_id?: IntFilter<"materials"> | number
    description?: StringFilter<"materials"> | string
    status?: BoolFilter<"materials"> | boolean
    create_at?: DateTimeFilter<"materials"> | Date | string
    update_at?: DateTimeFilter<"materials"> | Date | string
  }, "id">

  export type materialsOrderByWithAggregationInput = {
    id?: SortOrder
    material_code?: SortOrder
    material_name_th?: SortOrder
    material_name_en?: SortOrder
    long_meterial_name?: SortOrder
    material_type_id?: SortOrder
    material_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: materialsCountOrderByAggregateInput
    _avg?: materialsAvgOrderByAggregateInput
    _max?: materialsMaxOrderByAggregateInput
    _min?: materialsMinOrderByAggregateInput
    _sum?: materialsSumOrderByAggregateInput
  }

  export type materialsScalarWhereWithAggregatesInput = {
    AND?: materialsScalarWhereWithAggregatesInput | materialsScalarWhereWithAggregatesInput[]
    OR?: materialsScalarWhereWithAggregatesInput[]
    NOT?: materialsScalarWhereWithAggregatesInput | materialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"materials"> | number
    material_code?: IntWithAggregatesFilter<"materials"> | number
    material_name_th?: StringWithAggregatesFilter<"materials"> | string
    material_name_en?: StringWithAggregatesFilter<"materials"> | string
    long_meterial_name?: StringWithAggregatesFilter<"materials"> | string
    material_type_id?: IntWithAggregatesFilter<"materials"> | number
    material_unit_id?: IntWithAggregatesFilter<"materials"> | number
    description?: StringWithAggregatesFilter<"materials"> | string
    status?: BoolWithAggregatesFilter<"materials"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"materials"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"materials"> | Date | string
  }

  export type material_typesWhereInput = {
    AND?: material_typesWhereInput | material_typesWhereInput[]
    OR?: material_typesWhereInput[]
    NOT?: material_typesWhereInput | material_typesWhereInput[]
    id?: IntFilter<"material_types"> | number
    description?: StringFilter<"material_types"> | string
    status?: BoolFilter<"material_types"> | boolean
    create_at?: DateTimeFilter<"material_types"> | Date | string
    update_at?: DateTimeFilter<"material_types"> | Date | string
  }

  export type material_typesOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: material_typesOrderByRelevanceInput
  }

  export type material_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: material_typesWhereInput | material_typesWhereInput[]
    OR?: material_typesWhereInput[]
    NOT?: material_typesWhereInput | material_typesWhereInput[]
    description?: StringFilter<"material_types"> | string
    status?: BoolFilter<"material_types"> | boolean
    create_at?: DateTimeFilter<"material_types"> | Date | string
    update_at?: DateTimeFilter<"material_types"> | Date | string
  }, "id">

  export type material_typesOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: material_typesCountOrderByAggregateInput
    _avg?: material_typesAvgOrderByAggregateInput
    _max?: material_typesMaxOrderByAggregateInput
    _min?: material_typesMinOrderByAggregateInput
    _sum?: material_typesSumOrderByAggregateInput
  }

  export type material_typesScalarWhereWithAggregatesInput = {
    AND?: material_typesScalarWhereWithAggregatesInput | material_typesScalarWhereWithAggregatesInput[]
    OR?: material_typesScalarWhereWithAggregatesInput[]
    NOT?: material_typesScalarWhereWithAggregatesInput | material_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"material_types"> | number
    description?: StringWithAggregatesFilter<"material_types"> | string
    status?: BoolWithAggregatesFilter<"material_types"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"material_types"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"material_types"> | Date | string
  }

  export type item_units_meauresWhereInput = {
    AND?: item_units_meauresWhereInput | item_units_meauresWhereInput[]
    OR?: item_units_meauresWhereInput[]
    NOT?: item_units_meauresWhereInput | item_units_meauresWhereInput[]
    id?: IntFilter<"item_units_meaures"> | number
    material_id?: IntFilter<"item_units_meaures"> | number
    packing?: StringFilter<"item_units_meaures"> | string
    qty?: FloatFilter<"item_units_meaures"> | number
    countable_unit_id?: StringFilter<"item_units_meaures"> | string
    description?: StringFilter<"item_units_meaures"> | string
    status?: BoolFilter<"item_units_meaures"> | boolean
    create_at?: DateTimeFilter<"item_units_meaures"> | Date | string
    update_at?: DateTimeFilter<"item_units_meaures"> | Date | string
  }

  export type item_units_meauresOrderByWithRelationInput = {
    id?: SortOrder
    material_id?: SortOrder
    packing?: SortOrder
    qty?: SortOrder
    countable_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: item_units_meauresOrderByRelevanceInput
  }

  export type item_units_meauresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: item_units_meauresWhereInput | item_units_meauresWhereInput[]
    OR?: item_units_meauresWhereInput[]
    NOT?: item_units_meauresWhereInput | item_units_meauresWhereInput[]
    material_id?: IntFilter<"item_units_meaures"> | number
    packing?: StringFilter<"item_units_meaures"> | string
    qty?: FloatFilter<"item_units_meaures"> | number
    countable_unit_id?: StringFilter<"item_units_meaures"> | string
    description?: StringFilter<"item_units_meaures"> | string
    status?: BoolFilter<"item_units_meaures"> | boolean
    create_at?: DateTimeFilter<"item_units_meaures"> | Date | string
    update_at?: DateTimeFilter<"item_units_meaures"> | Date | string
  }, "id">

  export type item_units_meauresOrderByWithAggregationInput = {
    id?: SortOrder
    material_id?: SortOrder
    packing?: SortOrder
    qty?: SortOrder
    countable_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: item_units_meauresCountOrderByAggregateInput
    _avg?: item_units_meauresAvgOrderByAggregateInput
    _max?: item_units_meauresMaxOrderByAggregateInput
    _min?: item_units_meauresMinOrderByAggregateInput
    _sum?: item_units_meauresSumOrderByAggregateInput
  }

  export type item_units_meauresScalarWhereWithAggregatesInput = {
    AND?: item_units_meauresScalarWhereWithAggregatesInput | item_units_meauresScalarWhereWithAggregatesInput[]
    OR?: item_units_meauresScalarWhereWithAggregatesInput[]
    NOT?: item_units_meauresScalarWhereWithAggregatesInput | item_units_meauresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"item_units_meaures"> | number
    material_id?: IntWithAggregatesFilter<"item_units_meaures"> | number
    packing?: StringWithAggregatesFilter<"item_units_meaures"> | string
    qty?: FloatWithAggregatesFilter<"item_units_meaures"> | number
    countable_unit_id?: StringWithAggregatesFilter<"item_units_meaures"> | string
    description?: StringWithAggregatesFilter<"item_units_meaures"> | string
    status?: BoolWithAggregatesFilter<"item_units_meaures"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"item_units_meaures"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"item_units_meaures"> | Date | string
  }

  export type itemsWhereInput = {
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    id?: IntFilter<"items"> | number
    material_id?: IntFilter<"items"> | number
    saleoffice_id?: IntFilter<"items"> | number
    department_id?: IntFilter<"items"> | number
    item_category_id?: IntFilter<"items"> | number
    stock_location_id?: IntFilter<"items"> | number
    name_th?: StringNullableFilter<"items"> | string | null
    name_en?: StringNullableFilter<"items"> | string | null
    status?: BoolFilter<"items"> | boolean
    create_at?: DateTimeFilter<"items"> | Date | string
    update_at?: DateTimeFilter<"items"> | Date | string
  }

  export type itemsOrderByWithRelationInput = {
    id?: SortOrder
    material_id?: SortOrder
    saleoffice_id?: SortOrder
    department_id?: SortOrder
    item_category_id?: SortOrder
    stock_location_id?: SortOrder
    name_th?: SortOrderInput | SortOrder
    name_en?: SortOrderInput | SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: itemsOrderByRelevanceInput
  }

  export type itemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: itemsWhereInput | itemsWhereInput[]
    OR?: itemsWhereInput[]
    NOT?: itemsWhereInput | itemsWhereInput[]
    material_id?: IntFilter<"items"> | number
    saleoffice_id?: IntFilter<"items"> | number
    department_id?: IntFilter<"items"> | number
    item_category_id?: IntFilter<"items"> | number
    stock_location_id?: IntFilter<"items"> | number
    name_th?: StringNullableFilter<"items"> | string | null
    name_en?: StringNullableFilter<"items"> | string | null
    status?: BoolFilter<"items"> | boolean
    create_at?: DateTimeFilter<"items"> | Date | string
    update_at?: DateTimeFilter<"items"> | Date | string
  }, "id">

  export type itemsOrderByWithAggregationInput = {
    id?: SortOrder
    material_id?: SortOrder
    saleoffice_id?: SortOrder
    department_id?: SortOrder
    item_category_id?: SortOrder
    stock_location_id?: SortOrder
    name_th?: SortOrderInput | SortOrder
    name_en?: SortOrderInput | SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: itemsCountOrderByAggregateInput
    _avg?: itemsAvgOrderByAggregateInput
    _max?: itemsMaxOrderByAggregateInput
    _min?: itemsMinOrderByAggregateInput
    _sum?: itemsSumOrderByAggregateInput
  }

  export type itemsScalarWhereWithAggregatesInput = {
    AND?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    OR?: itemsScalarWhereWithAggregatesInput[]
    NOT?: itemsScalarWhereWithAggregatesInput | itemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"items"> | number
    material_id?: IntWithAggregatesFilter<"items"> | number
    saleoffice_id?: IntWithAggregatesFilter<"items"> | number
    department_id?: IntWithAggregatesFilter<"items"> | number
    item_category_id?: IntWithAggregatesFilter<"items"> | number
    stock_location_id?: IntWithAggregatesFilter<"items"> | number
    name_th?: StringNullableWithAggregatesFilter<"items"> | string | null
    name_en?: StringNullableWithAggregatesFilter<"items"> | string | null
    status?: BoolWithAggregatesFilter<"items"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"items"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"items"> | Date | string
  }

  export type items_detailsWhereInput = {
    AND?: items_detailsWhereInput | items_detailsWhereInput[]
    OR?: items_detailsWhereInput[]
    NOT?: items_detailsWhereInput | items_detailsWhereInput[]
    id?: IntFilter<"items_details"> | number
    item_id?: IntFilter<"items_details"> | number
    sale_office_id?: IntFilter<"items_details"> | number
    qr_code_number?: StringFilter<"items_details"> | string
    product_lot_number?: StringFilter<"items_details"> | string
    description?: StringFilter<"items_details"> | string
    status?: BoolFilter<"items_details"> | boolean
    create_at?: DateTimeFilter<"items_details"> | Date | string
    update_at?: DateTimeFilter<"items_details"> | Date | string
  }

  export type items_detailsOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    sale_office_id?: SortOrder
    qr_code_number?: SortOrder
    product_lot_number?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: items_detailsOrderByRelevanceInput
  }

  export type items_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: items_detailsWhereInput | items_detailsWhereInput[]
    OR?: items_detailsWhereInput[]
    NOT?: items_detailsWhereInput | items_detailsWhereInput[]
    item_id?: IntFilter<"items_details"> | number
    sale_office_id?: IntFilter<"items_details"> | number
    qr_code_number?: StringFilter<"items_details"> | string
    product_lot_number?: StringFilter<"items_details"> | string
    description?: StringFilter<"items_details"> | string
    status?: BoolFilter<"items_details"> | boolean
    create_at?: DateTimeFilter<"items_details"> | Date | string
    update_at?: DateTimeFilter<"items_details"> | Date | string
  }, "id">

  export type items_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    sale_office_id?: SortOrder
    qr_code_number?: SortOrder
    product_lot_number?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: items_detailsCountOrderByAggregateInput
    _avg?: items_detailsAvgOrderByAggregateInput
    _max?: items_detailsMaxOrderByAggregateInput
    _min?: items_detailsMinOrderByAggregateInput
    _sum?: items_detailsSumOrderByAggregateInput
  }

  export type items_detailsScalarWhereWithAggregatesInput = {
    AND?: items_detailsScalarWhereWithAggregatesInput | items_detailsScalarWhereWithAggregatesInput[]
    OR?: items_detailsScalarWhereWithAggregatesInput[]
    NOT?: items_detailsScalarWhereWithAggregatesInput | items_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"items_details"> | number
    item_id?: IntWithAggregatesFilter<"items_details"> | number
    sale_office_id?: IntWithAggregatesFilter<"items_details"> | number
    qr_code_number?: StringWithAggregatesFilter<"items_details"> | string
    product_lot_number?: StringWithAggregatesFilter<"items_details"> | string
    description?: StringWithAggregatesFilter<"items_details"> | string
    status?: BoolWithAggregatesFilter<"items_details"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"items_details"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"items_details"> | Date | string
  }

  export type item_categoriesWhereInput = {
    AND?: item_categoriesWhereInput | item_categoriesWhereInput[]
    OR?: item_categoriesWhereInput[]
    NOT?: item_categoriesWhereInput | item_categoriesWhereInput[]
    id?: IntFilter<"item_categories"> | number
    type_id?: IntFilter<"item_categories"> | number
    sale_office_id?: IntFilter<"item_categories"> | number
    department_id?: IntFilter<"item_categories"> | number
    stock_location_id?: IntFilter<"item_categories"> | number
    description?: StringFilter<"item_categories"> | string
    status?: BoolFilter<"item_categories"> | boolean
    create_at?: DateTimeFilter<"item_categories"> | Date | string
    update_at?: DateTimeFilter<"item_categories"> | Date | string
  }

  export type item_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    type_id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    stock_location_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: item_categoriesOrderByRelevanceInput
  }

  export type item_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: item_categoriesWhereInput | item_categoriesWhereInput[]
    OR?: item_categoriesWhereInput[]
    NOT?: item_categoriesWhereInput | item_categoriesWhereInput[]
    type_id?: IntFilter<"item_categories"> | number
    sale_office_id?: IntFilter<"item_categories"> | number
    department_id?: IntFilter<"item_categories"> | number
    stock_location_id?: IntFilter<"item_categories"> | number
    description?: StringFilter<"item_categories"> | string
    status?: BoolFilter<"item_categories"> | boolean
    create_at?: DateTimeFilter<"item_categories"> | Date | string
    update_at?: DateTimeFilter<"item_categories"> | Date | string
  }, "id">

  export type item_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    type_id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    stock_location_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: item_categoriesCountOrderByAggregateInput
    _avg?: item_categoriesAvgOrderByAggregateInput
    _max?: item_categoriesMaxOrderByAggregateInput
    _min?: item_categoriesMinOrderByAggregateInput
    _sum?: item_categoriesSumOrderByAggregateInput
  }

  export type item_categoriesScalarWhereWithAggregatesInput = {
    AND?: item_categoriesScalarWhereWithAggregatesInput | item_categoriesScalarWhereWithAggregatesInput[]
    OR?: item_categoriesScalarWhereWithAggregatesInput[]
    NOT?: item_categoriesScalarWhereWithAggregatesInput | item_categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"item_categories"> | number
    type_id?: IntWithAggregatesFilter<"item_categories"> | number
    sale_office_id?: IntWithAggregatesFilter<"item_categories"> | number
    department_id?: IntWithAggregatesFilter<"item_categories"> | number
    stock_location_id?: IntWithAggregatesFilter<"item_categories"> | number
    description?: StringWithAggregatesFilter<"item_categories"> | string
    status?: BoolWithAggregatesFilter<"item_categories"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"item_categories"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"item_categories"> | Date | string
  }

  export type typesWhereInput = {
    AND?: typesWhereInput | typesWhereInput[]
    OR?: typesWhereInput[]
    NOT?: typesWhereInput | typesWhereInput[]
    id?: IntFilter<"types"> | number
    description?: StringFilter<"types"> | string
    status?: BoolFilter<"types"> | boolean
    create_at?: DateTimeFilter<"types"> | Date | string
    update_at?: DateTimeFilter<"types"> | Date | string
  }

  export type typesOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: typesOrderByRelevanceInput
  }

  export type typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: typesWhereInput | typesWhereInput[]
    OR?: typesWhereInput[]
    NOT?: typesWhereInput | typesWhereInput[]
    description?: StringFilter<"types"> | string
    status?: BoolFilter<"types"> | boolean
    create_at?: DateTimeFilter<"types"> | Date | string
    update_at?: DateTimeFilter<"types"> | Date | string
  }, "id">

  export type typesOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: typesCountOrderByAggregateInput
    _avg?: typesAvgOrderByAggregateInput
    _max?: typesMaxOrderByAggregateInput
    _min?: typesMinOrderByAggregateInput
    _sum?: typesSumOrderByAggregateInput
  }

  export type typesScalarWhereWithAggregatesInput = {
    AND?: typesScalarWhereWithAggregatesInput | typesScalarWhereWithAggregatesInput[]
    OR?: typesScalarWhereWithAggregatesInput[]
    NOT?: typesScalarWhereWithAggregatesInput | typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"types"> | number
    description?: StringWithAggregatesFilter<"types"> | string
    status?: BoolWithAggregatesFilter<"types"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"types"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"types"> | Date | string
  }

  export type item_pricesWhereInput = {
    AND?: item_pricesWhereInput | item_pricesWhereInput[]
    OR?: item_pricesWhereInput[]
    NOT?: item_pricesWhereInput | item_pricesWhereInput[]
    id?: IntFilter<"item_prices"> | number
    item_id?: IntFilter<"item_prices"> | number
    price?: FloatFilter<"item_prices"> | number
    description?: StringFilter<"item_prices"> | string
    status?: BoolFilter<"item_prices"> | boolean
    create_at?: DateTimeFilter<"item_prices"> | Date | string
    update_at?: DateTimeFilter<"item_prices"> | Date | string
  }

  export type item_pricesOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: item_pricesOrderByRelevanceInput
  }

  export type item_pricesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: item_pricesWhereInput | item_pricesWhereInput[]
    OR?: item_pricesWhereInput[]
    NOT?: item_pricesWhereInput | item_pricesWhereInput[]
    item_id?: IntFilter<"item_prices"> | number
    price?: FloatFilter<"item_prices"> | number
    description?: StringFilter<"item_prices"> | string
    status?: BoolFilter<"item_prices"> | boolean
    create_at?: DateTimeFilter<"item_prices"> | Date | string
    update_at?: DateTimeFilter<"item_prices"> | Date | string
  }, "id">

  export type item_pricesOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: item_pricesCountOrderByAggregateInput
    _avg?: item_pricesAvgOrderByAggregateInput
    _max?: item_pricesMaxOrderByAggregateInput
    _min?: item_pricesMinOrderByAggregateInput
    _sum?: item_pricesSumOrderByAggregateInput
  }

  export type item_pricesScalarWhereWithAggregatesInput = {
    AND?: item_pricesScalarWhereWithAggregatesInput | item_pricesScalarWhereWithAggregatesInput[]
    OR?: item_pricesScalarWhereWithAggregatesInput[]
    NOT?: item_pricesScalarWhereWithAggregatesInput | item_pricesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"item_prices"> | number
    item_id?: IntWithAggregatesFilter<"item_prices"> | number
    price?: FloatWithAggregatesFilter<"item_prices"> | number
    description?: StringWithAggregatesFilter<"item_prices"> | string
    status?: BoolWithAggregatesFilter<"item_prices"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"item_prices"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"item_prices"> | Date | string
  }

  export type dirtiesWhereInput = {
    AND?: dirtiesWhereInput | dirtiesWhereInput[]
    OR?: dirtiesWhereInput[]
    NOT?: dirtiesWhereInput | dirtiesWhereInput[]
    id?: IntFilter<"dirties"> | number
    dirty_doc_no?: StringFilter<"dirties"> | string
    dirty_doc_date?: DateTimeNullableFilter<"dirties"> | Date | string | null
    sale_office_id?: IntNullableFilter<"dirties"> | number | null
    department_id?: IntNullableFilter<"dirties"> | number | null
    factory_id?: IntNullableFilter<"dirties"> | number | null
    user_id?: IntNullableFilter<"dirties"> | number | null
    signature?: StringNullableFilter<"dirties"> | string | null
    sign_factory?: StringNullableFilter<"dirties"> | string | null
    sign_factory_time?: DateTimeNullableFilter<"dirties"> | Date | string | null
    sign_NH?: StringNullableFilter<"dirties"> | string | null
    sign_NH_time?: DateTimeNullableFilter<"dirties"> | Date | string | null
    status?: BoolFilter<"dirties"> | boolean
    create_at?: DateTimeFilter<"dirties"> | Date | string
    update_at?: DateTimeFilter<"dirties"> | Date | string
  }

  export type dirtiesOrderByWithRelationInput = {
    id?: SortOrder
    dirty_doc_no?: SortOrder
    dirty_doc_date?: SortOrderInput | SortOrder
    sale_office_id?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    factory_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    sign_factory?: SortOrderInput | SortOrder
    sign_factory_time?: SortOrderInput | SortOrder
    sign_NH?: SortOrderInput | SortOrder
    sign_NH_time?: SortOrderInput | SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: dirtiesOrderByRelevanceInput
  }

  export type dirtiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: dirtiesWhereInput | dirtiesWhereInput[]
    OR?: dirtiesWhereInput[]
    NOT?: dirtiesWhereInput | dirtiesWhereInput[]
    dirty_doc_no?: StringFilter<"dirties"> | string
    dirty_doc_date?: DateTimeNullableFilter<"dirties"> | Date | string | null
    sale_office_id?: IntNullableFilter<"dirties"> | number | null
    department_id?: IntNullableFilter<"dirties"> | number | null
    factory_id?: IntNullableFilter<"dirties"> | number | null
    user_id?: IntNullableFilter<"dirties"> | number | null
    signature?: StringNullableFilter<"dirties"> | string | null
    sign_factory?: StringNullableFilter<"dirties"> | string | null
    sign_factory_time?: DateTimeNullableFilter<"dirties"> | Date | string | null
    sign_NH?: StringNullableFilter<"dirties"> | string | null
    sign_NH_time?: DateTimeNullableFilter<"dirties"> | Date | string | null
    status?: BoolFilter<"dirties"> | boolean
    create_at?: DateTimeFilter<"dirties"> | Date | string
    update_at?: DateTimeFilter<"dirties"> | Date | string
  }, "id">

  export type dirtiesOrderByWithAggregationInput = {
    id?: SortOrder
    dirty_doc_no?: SortOrder
    dirty_doc_date?: SortOrderInput | SortOrder
    sale_office_id?: SortOrderInput | SortOrder
    department_id?: SortOrderInput | SortOrder
    factory_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    signature?: SortOrderInput | SortOrder
    sign_factory?: SortOrderInput | SortOrder
    sign_factory_time?: SortOrderInput | SortOrder
    sign_NH?: SortOrderInput | SortOrder
    sign_NH_time?: SortOrderInput | SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: dirtiesCountOrderByAggregateInput
    _avg?: dirtiesAvgOrderByAggregateInput
    _max?: dirtiesMaxOrderByAggregateInput
    _min?: dirtiesMinOrderByAggregateInput
    _sum?: dirtiesSumOrderByAggregateInput
  }

  export type dirtiesScalarWhereWithAggregatesInput = {
    AND?: dirtiesScalarWhereWithAggregatesInput | dirtiesScalarWhereWithAggregatesInput[]
    OR?: dirtiesScalarWhereWithAggregatesInput[]
    NOT?: dirtiesScalarWhereWithAggregatesInput | dirtiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"dirties"> | number
    dirty_doc_no?: StringWithAggregatesFilter<"dirties"> | string
    dirty_doc_date?: DateTimeNullableWithAggregatesFilter<"dirties"> | Date | string | null
    sale_office_id?: IntNullableWithAggregatesFilter<"dirties"> | number | null
    department_id?: IntNullableWithAggregatesFilter<"dirties"> | number | null
    factory_id?: IntNullableWithAggregatesFilter<"dirties"> | number | null
    user_id?: IntNullableWithAggregatesFilter<"dirties"> | number | null
    signature?: StringNullableWithAggregatesFilter<"dirties"> | string | null
    sign_factory?: StringNullableWithAggregatesFilter<"dirties"> | string | null
    sign_factory_time?: DateTimeNullableWithAggregatesFilter<"dirties"> | Date | string | null
    sign_NH?: StringNullableWithAggregatesFilter<"dirties"> | string | null
    sign_NH_time?: DateTimeNullableWithAggregatesFilter<"dirties"> | Date | string | null
    status?: BoolWithAggregatesFilter<"dirties"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"dirties"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"dirties"> | Date | string
  }

  export type dirty_detailsWhereInput = {
    AND?: dirty_detailsWhereInput | dirty_detailsWhereInput[]
    OR?: dirty_detailsWhereInput[]
    NOT?: dirty_detailsWhereInput | dirty_detailsWhereInput[]
    id?: IntFilter<"dirty_details"> | number
    dirty_id?: IntFilter<"dirty_details"> | number
    department_id?: IntFilter<"dirty_details"> | number
    item_id?: IntFilter<"dirty_details"> | number
    unit_id?: IntFilter<"dirty_details"> | number
    user_id?: IntFilter<"dirty_details"> | number
    qty?: FloatFilter<"dirty_details"> | number
    receive_qty?: FloatFilter<"dirty_details"> | number
    weight?: FloatFilter<"dirty_details"> | number
    is_cancel?: BoolFilter<"dirty_details"> | boolean
    status?: BoolFilter<"dirty_details"> | boolean
    create_at?: DateTimeFilter<"dirty_details"> | Date | string
    update_at?: DateTimeFilter<"dirty_details"> | Date | string
  }

  export type dirty_detailsOrderByWithRelationInput = {
    id?: SortOrder
    dirty_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type dirty_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: dirty_detailsWhereInput | dirty_detailsWhereInput[]
    OR?: dirty_detailsWhereInput[]
    NOT?: dirty_detailsWhereInput | dirty_detailsWhereInput[]
    dirty_id?: IntFilter<"dirty_details"> | number
    department_id?: IntFilter<"dirty_details"> | number
    item_id?: IntFilter<"dirty_details"> | number
    unit_id?: IntFilter<"dirty_details"> | number
    user_id?: IntFilter<"dirty_details"> | number
    qty?: FloatFilter<"dirty_details"> | number
    receive_qty?: FloatFilter<"dirty_details"> | number
    weight?: FloatFilter<"dirty_details"> | number
    is_cancel?: BoolFilter<"dirty_details"> | boolean
    status?: BoolFilter<"dirty_details"> | boolean
    create_at?: DateTimeFilter<"dirty_details"> | Date | string
    update_at?: DateTimeFilter<"dirty_details"> | Date | string
  }, "id">

  export type dirty_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    dirty_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: dirty_detailsCountOrderByAggregateInput
    _avg?: dirty_detailsAvgOrderByAggregateInput
    _max?: dirty_detailsMaxOrderByAggregateInput
    _min?: dirty_detailsMinOrderByAggregateInput
    _sum?: dirty_detailsSumOrderByAggregateInput
  }

  export type dirty_detailsScalarWhereWithAggregatesInput = {
    AND?: dirty_detailsScalarWhereWithAggregatesInput | dirty_detailsScalarWhereWithAggregatesInput[]
    OR?: dirty_detailsScalarWhereWithAggregatesInput[]
    NOT?: dirty_detailsScalarWhereWithAggregatesInput | dirty_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"dirty_details"> | number
    dirty_id?: IntWithAggregatesFilter<"dirty_details"> | number
    department_id?: IntWithAggregatesFilter<"dirty_details"> | number
    item_id?: IntWithAggregatesFilter<"dirty_details"> | number
    unit_id?: IntWithAggregatesFilter<"dirty_details"> | number
    user_id?: IntWithAggregatesFilter<"dirty_details"> | number
    qty?: FloatWithAggregatesFilter<"dirty_details"> | number
    receive_qty?: FloatWithAggregatesFilter<"dirty_details"> | number
    weight?: FloatWithAggregatesFilter<"dirty_details"> | number
    is_cancel?: BoolWithAggregatesFilter<"dirty_details"> | boolean
    status?: BoolWithAggregatesFilter<"dirty_details"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"dirty_details"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"dirty_details"> | Date | string
  }

  export type customer_group_typesWhereInput = {
    AND?: customer_group_typesWhereInput | customer_group_typesWhereInput[]
    OR?: customer_group_typesWhereInput[]
    NOT?: customer_group_typesWhereInput | customer_group_typesWhereInput[]
    id?: IntFilter<"customer_group_types"> | number
    level?: StringFilter<"customer_group_types"> | string
    group?: StringFilter<"customer_group_types"> | string
    type?: StringFilter<"customer_group_types"> | string
    status?: BoolFilter<"customer_group_types"> | boolean
    create_at?: DateTimeFilter<"customer_group_types"> | Date | string
    update_at?: DateTimeFilter<"customer_group_types"> | Date | string
  }

  export type customer_group_typesOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    group?: SortOrder
    type?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: customer_group_typesOrderByRelevanceInput
  }

  export type customer_group_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customer_group_typesWhereInput | customer_group_typesWhereInput[]
    OR?: customer_group_typesWhereInput[]
    NOT?: customer_group_typesWhereInput | customer_group_typesWhereInput[]
    level?: StringFilter<"customer_group_types"> | string
    group?: StringFilter<"customer_group_types"> | string
    type?: StringFilter<"customer_group_types"> | string
    status?: BoolFilter<"customer_group_types"> | boolean
    create_at?: DateTimeFilter<"customer_group_types"> | Date | string
    update_at?: DateTimeFilter<"customer_group_types"> | Date | string
  }, "id">

  export type customer_group_typesOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    group?: SortOrder
    type?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: customer_group_typesCountOrderByAggregateInput
    _avg?: customer_group_typesAvgOrderByAggregateInput
    _max?: customer_group_typesMaxOrderByAggregateInput
    _min?: customer_group_typesMinOrderByAggregateInput
    _sum?: customer_group_typesSumOrderByAggregateInput
  }

  export type customer_group_typesScalarWhereWithAggregatesInput = {
    AND?: customer_group_typesScalarWhereWithAggregatesInput | customer_group_typesScalarWhereWithAggregatesInput[]
    OR?: customer_group_typesScalarWhereWithAggregatesInput[]
    NOT?: customer_group_typesScalarWhereWithAggregatesInput | customer_group_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customer_group_types"> | number
    level?: StringWithAggregatesFilter<"customer_group_types"> | string
    group?: StringWithAggregatesFilter<"customer_group_types"> | string
    type?: StringWithAggregatesFilter<"customer_group_types"> | string
    status?: BoolWithAggregatesFilter<"customer_group_types"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"customer_group_types"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"customer_group_types"> | Date | string
  }

  export type customer_groupsWhereInput = {
    AND?: customer_groupsWhereInput | customer_groupsWhereInput[]
    OR?: customer_groupsWhereInput[]
    NOT?: customer_groupsWhereInput | customer_groupsWhereInput[]
    id?: IntFilter<"customer_groups"> | number
    sale_office_id?: IntFilter<"customer_groups"> | number
    customer_group_type_id?: IntFilter<"customer_groups"> | number
    status?: BoolFilter<"customer_groups"> | boolean
    create_at?: DateTimeFilter<"customer_groups"> | Date | string
    update_at?: DateTimeFilter<"customer_groups"> | Date | string
  }

  export type customer_groupsOrderByWithRelationInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    customer_group_type_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type customer_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: customer_groupsWhereInput | customer_groupsWhereInput[]
    OR?: customer_groupsWhereInput[]
    NOT?: customer_groupsWhereInput | customer_groupsWhereInput[]
    sale_office_id?: IntFilter<"customer_groups"> | number
    customer_group_type_id?: IntFilter<"customer_groups"> | number
    status?: BoolFilter<"customer_groups"> | boolean
    create_at?: DateTimeFilter<"customer_groups"> | Date | string
    update_at?: DateTimeFilter<"customer_groups"> | Date | string
  }, "id">

  export type customer_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    customer_group_type_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: customer_groupsCountOrderByAggregateInput
    _avg?: customer_groupsAvgOrderByAggregateInput
    _max?: customer_groupsMaxOrderByAggregateInput
    _min?: customer_groupsMinOrderByAggregateInput
    _sum?: customer_groupsSumOrderByAggregateInput
  }

  export type customer_groupsScalarWhereWithAggregatesInput = {
    AND?: customer_groupsScalarWhereWithAggregatesInput | customer_groupsScalarWhereWithAggregatesInput[]
    OR?: customer_groupsScalarWhereWithAggregatesInput[]
    NOT?: customer_groupsScalarWhereWithAggregatesInput | customer_groupsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"customer_groups"> | number
    sale_office_id?: IntWithAggregatesFilter<"customer_groups"> | number
    customer_group_type_id?: IntWithAggregatesFilter<"customer_groups"> | number
    status?: BoolWithAggregatesFilter<"customer_groups"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"customer_groups"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"customer_groups"> | Date | string
  }

  export type stock_locationsWhereInput = {
    AND?: stock_locationsWhereInput | stock_locationsWhereInput[]
    OR?: stock_locationsWhereInput[]
    NOT?: stock_locationsWhereInput | stock_locationsWhereInput[]
    id?: IntFilter<"stock_locations"> | number
    department_id?: IntFilter<"stock_locations"> | number
    sale_office_id?: IntFilter<"stock_locations"> | number
    site_short_code?: IntFilter<"stock_locations"> | number
    description?: StringFilter<"stock_locations"> | string
    status?: BoolFilter<"stock_locations"> | boolean
    create_at?: DateTimeFilter<"stock_locations"> | Date | string
    update_at?: DateTimeFilter<"stock_locations"> | Date | string
  }

  export type stock_locationsOrderByWithRelationInput = {
    id?: SortOrder
    department_id?: SortOrder
    sale_office_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: stock_locationsOrderByRelevanceInput
  }

  export type stock_locationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: stock_locationsWhereInput | stock_locationsWhereInput[]
    OR?: stock_locationsWhereInput[]
    NOT?: stock_locationsWhereInput | stock_locationsWhereInput[]
    department_id?: IntFilter<"stock_locations"> | number
    sale_office_id?: IntFilter<"stock_locations"> | number
    site_short_code?: IntFilter<"stock_locations"> | number
    description?: StringFilter<"stock_locations"> | string
    status?: BoolFilter<"stock_locations"> | boolean
    create_at?: DateTimeFilter<"stock_locations"> | Date | string
    update_at?: DateTimeFilter<"stock_locations"> | Date | string
  }, "id">

  export type stock_locationsOrderByWithAggregationInput = {
    id?: SortOrder
    department_id?: SortOrder
    sale_office_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: stock_locationsCountOrderByAggregateInput
    _avg?: stock_locationsAvgOrderByAggregateInput
    _max?: stock_locationsMaxOrderByAggregateInput
    _min?: stock_locationsMinOrderByAggregateInput
    _sum?: stock_locationsSumOrderByAggregateInput
  }

  export type stock_locationsScalarWhereWithAggregatesInput = {
    AND?: stock_locationsScalarWhereWithAggregatesInput | stock_locationsScalarWhereWithAggregatesInput[]
    OR?: stock_locationsScalarWhereWithAggregatesInput[]
    NOT?: stock_locationsScalarWhereWithAggregatesInput | stock_locationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"stock_locations"> | number
    department_id?: IntWithAggregatesFilter<"stock_locations"> | number
    sale_office_id?: IntWithAggregatesFilter<"stock_locations"> | number
    site_short_code?: IntWithAggregatesFilter<"stock_locations"> | number
    description?: StringWithAggregatesFilter<"stock_locations"> | string
    status?: BoolWithAggregatesFilter<"stock_locations"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"stock_locations"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"stock_locations"> | Date | string
  }

  export type shelfcountsWhereInput = {
    AND?: shelfcountsWhereInput | shelfcountsWhereInput[]
    OR?: shelfcountsWhereInput[]
    NOT?: shelfcountsWhereInput | shelfcountsWhereInput[]
    id?: IntFilter<"shelfcounts"> | number
    sale_office_id?: IntFilter<"shelfcounts"> | number
    doc_no?: IntFilter<"shelfcounts"> | number
    doc_date?: DateTimeFilter<"shelfcounts"> | Date | string
    shelfcount_doc_no?: StringFilter<"shelfcounts"> | string
    department_id?: IntFilter<"shelfcounts"> | number
    is_request?: BoolFilter<"shelfcounts"> | boolean
    delivery_time?: DateTimeFilter<"shelfcounts"> | Date | string
    sc_time?: DateTimeFilter<"shelfcounts"> | Date | string
    is_mobile?: BoolFilter<"shelfcounts"> | boolean
    complete_user?: StringFilter<"shelfcounts"> | string
    complete_date?: DateTimeFilter<"shelfcounts"> | Date | string
    cancel_user_id?: IntFilter<"shelfcounts"> | number
    cancel_remark?: StringFilter<"shelfcounts"> | string
    site_short_code?: IntFilter<"shelfcounts"> | number
    description?: StringFilter<"shelfcounts"> | string
    status?: BoolFilter<"shelfcounts"> | boolean
    create_at?: DateTimeFilter<"shelfcounts"> | Date | string
    update_at?: DateTimeFilter<"shelfcounts"> | Date | string
  }

  export type shelfcountsOrderByWithRelationInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    shelfcount_doc_no?: SortOrder
    department_id?: SortOrder
    is_request?: SortOrder
    delivery_time?: SortOrder
    sc_time?: SortOrder
    is_mobile?: SortOrder
    complete_user?: SortOrder
    complete_date?: SortOrder
    cancel_user_id?: SortOrder
    cancel_remark?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: shelfcountsOrderByRelevanceInput
  }

  export type shelfcountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: shelfcountsWhereInput | shelfcountsWhereInput[]
    OR?: shelfcountsWhereInput[]
    NOT?: shelfcountsWhereInput | shelfcountsWhereInput[]
    sale_office_id?: IntFilter<"shelfcounts"> | number
    doc_no?: IntFilter<"shelfcounts"> | number
    doc_date?: DateTimeFilter<"shelfcounts"> | Date | string
    shelfcount_doc_no?: StringFilter<"shelfcounts"> | string
    department_id?: IntFilter<"shelfcounts"> | number
    is_request?: BoolFilter<"shelfcounts"> | boolean
    delivery_time?: DateTimeFilter<"shelfcounts"> | Date | string
    sc_time?: DateTimeFilter<"shelfcounts"> | Date | string
    is_mobile?: BoolFilter<"shelfcounts"> | boolean
    complete_user?: StringFilter<"shelfcounts"> | string
    complete_date?: DateTimeFilter<"shelfcounts"> | Date | string
    cancel_user_id?: IntFilter<"shelfcounts"> | number
    cancel_remark?: StringFilter<"shelfcounts"> | string
    site_short_code?: IntFilter<"shelfcounts"> | number
    description?: StringFilter<"shelfcounts"> | string
    status?: BoolFilter<"shelfcounts"> | boolean
    create_at?: DateTimeFilter<"shelfcounts"> | Date | string
    update_at?: DateTimeFilter<"shelfcounts"> | Date | string
  }, "id">

  export type shelfcountsOrderByWithAggregationInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    shelfcount_doc_no?: SortOrder
    department_id?: SortOrder
    is_request?: SortOrder
    delivery_time?: SortOrder
    sc_time?: SortOrder
    is_mobile?: SortOrder
    complete_user?: SortOrder
    complete_date?: SortOrder
    cancel_user_id?: SortOrder
    cancel_remark?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: shelfcountsCountOrderByAggregateInput
    _avg?: shelfcountsAvgOrderByAggregateInput
    _max?: shelfcountsMaxOrderByAggregateInput
    _min?: shelfcountsMinOrderByAggregateInput
    _sum?: shelfcountsSumOrderByAggregateInput
  }

  export type shelfcountsScalarWhereWithAggregatesInput = {
    AND?: shelfcountsScalarWhereWithAggregatesInput | shelfcountsScalarWhereWithAggregatesInput[]
    OR?: shelfcountsScalarWhereWithAggregatesInput[]
    NOT?: shelfcountsScalarWhereWithAggregatesInput | shelfcountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"shelfcounts"> | number
    sale_office_id?: IntWithAggregatesFilter<"shelfcounts"> | number
    doc_no?: IntWithAggregatesFilter<"shelfcounts"> | number
    doc_date?: DateTimeWithAggregatesFilter<"shelfcounts"> | Date | string
    shelfcount_doc_no?: StringWithAggregatesFilter<"shelfcounts"> | string
    department_id?: IntWithAggregatesFilter<"shelfcounts"> | number
    is_request?: BoolWithAggregatesFilter<"shelfcounts"> | boolean
    delivery_time?: DateTimeWithAggregatesFilter<"shelfcounts"> | Date | string
    sc_time?: DateTimeWithAggregatesFilter<"shelfcounts"> | Date | string
    is_mobile?: BoolWithAggregatesFilter<"shelfcounts"> | boolean
    complete_user?: StringWithAggregatesFilter<"shelfcounts"> | string
    complete_date?: DateTimeWithAggregatesFilter<"shelfcounts"> | Date | string
    cancel_user_id?: IntWithAggregatesFilter<"shelfcounts"> | number
    cancel_remark?: StringWithAggregatesFilter<"shelfcounts"> | string
    site_short_code?: IntWithAggregatesFilter<"shelfcounts"> | number
    description?: StringWithAggregatesFilter<"shelfcounts"> | string
    status?: BoolWithAggregatesFilter<"shelfcounts"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"shelfcounts"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"shelfcounts"> | Date | string
  }

  export type shelfcount_detailsWhereInput = {
    AND?: shelfcount_detailsWhereInput | shelfcount_detailsWhereInput[]
    OR?: shelfcount_detailsWhereInput[]
    NOT?: shelfcount_detailsWhereInput | shelfcount_detailsWhereInput[]
    id?: IntFilter<"shelfcount_details"> | number
    shelfcount_id?: IntFilter<"shelfcount_details"> | number
    item_id?: IntFilter<"shelfcount_details"> | number
    unit_id?: IntFilter<"shelfcount_details"> | number
    par_qty?: FloatFilter<"shelfcount_details"> | number
    cc_qty?: FloatFilter<"shelfcount_details"> | number
    total_qty?: FloatFilter<"shelfcount_details"> | number
    over_par?: FloatFilter<"shelfcount_details"> | number
    short?: FloatFilter<"shelfcount_details"> | number
    over?: FloatFilter<"shelfcount_details"> | number
    weight?: FloatFilter<"shelfcount_details"> | number
    price?: FloatFilter<"shelfcount_details"> | number
    category_price?: FloatFilter<"shelfcount_details"> | number
    status?: BoolFilter<"shelfcount_details"> | boolean
    create_at?: DateTimeFilter<"shelfcount_details"> | Date | string
    update_at?: DateTimeFilter<"shelfcount_details"> | Date | string
  }

  export type shelfcount_detailsOrderByWithRelationInput = {
    id?: SortOrder
    shelfcount_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    par_qty?: SortOrder
    cc_qty?: SortOrder
    total_qty?: SortOrder
    over_par?: SortOrder
    short?: SortOrder
    over?: SortOrder
    weight?: SortOrder
    price?: SortOrder
    category_price?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shelfcount_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: shelfcount_detailsWhereInput | shelfcount_detailsWhereInput[]
    OR?: shelfcount_detailsWhereInput[]
    NOT?: shelfcount_detailsWhereInput | shelfcount_detailsWhereInput[]
    shelfcount_id?: IntFilter<"shelfcount_details"> | number
    item_id?: IntFilter<"shelfcount_details"> | number
    unit_id?: IntFilter<"shelfcount_details"> | number
    par_qty?: FloatFilter<"shelfcount_details"> | number
    cc_qty?: FloatFilter<"shelfcount_details"> | number
    total_qty?: FloatFilter<"shelfcount_details"> | number
    over_par?: FloatFilter<"shelfcount_details"> | number
    short?: FloatFilter<"shelfcount_details"> | number
    over?: FloatFilter<"shelfcount_details"> | number
    weight?: FloatFilter<"shelfcount_details"> | number
    price?: FloatFilter<"shelfcount_details"> | number
    category_price?: FloatFilter<"shelfcount_details"> | number
    status?: BoolFilter<"shelfcount_details"> | boolean
    create_at?: DateTimeFilter<"shelfcount_details"> | Date | string
    update_at?: DateTimeFilter<"shelfcount_details"> | Date | string
  }, "id">

  export type shelfcount_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    shelfcount_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    par_qty?: SortOrder
    cc_qty?: SortOrder
    total_qty?: SortOrder
    over_par?: SortOrder
    short?: SortOrder
    over?: SortOrder
    weight?: SortOrder
    price?: SortOrder
    category_price?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: shelfcount_detailsCountOrderByAggregateInput
    _avg?: shelfcount_detailsAvgOrderByAggregateInput
    _max?: shelfcount_detailsMaxOrderByAggregateInput
    _min?: shelfcount_detailsMinOrderByAggregateInput
    _sum?: shelfcount_detailsSumOrderByAggregateInput
  }

  export type shelfcount_detailsScalarWhereWithAggregatesInput = {
    AND?: shelfcount_detailsScalarWhereWithAggregatesInput | shelfcount_detailsScalarWhereWithAggregatesInput[]
    OR?: shelfcount_detailsScalarWhereWithAggregatesInput[]
    NOT?: shelfcount_detailsScalarWhereWithAggregatesInput | shelfcount_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"shelfcount_details"> | number
    shelfcount_id?: IntWithAggregatesFilter<"shelfcount_details"> | number
    item_id?: IntWithAggregatesFilter<"shelfcount_details"> | number
    unit_id?: IntWithAggregatesFilter<"shelfcount_details"> | number
    par_qty?: FloatWithAggregatesFilter<"shelfcount_details"> | number
    cc_qty?: FloatWithAggregatesFilter<"shelfcount_details"> | number
    total_qty?: FloatWithAggregatesFilter<"shelfcount_details"> | number
    over_par?: FloatWithAggregatesFilter<"shelfcount_details"> | number
    short?: FloatWithAggregatesFilter<"shelfcount_details"> | number
    over?: FloatWithAggregatesFilter<"shelfcount_details"> | number
    weight?: FloatWithAggregatesFilter<"shelfcount_details"> | number
    price?: FloatWithAggregatesFilter<"shelfcount_details"> | number
    category_price?: FloatWithAggregatesFilter<"shelfcount_details"> | number
    status?: BoolWithAggregatesFilter<"shelfcount_details"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"shelfcount_details"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"shelfcount_details"> | Date | string
  }

  export type damagesWhereInput = {
    AND?: damagesWhereInput | damagesWhereInput[]
    OR?: damagesWhereInput[]
    NOT?: damagesWhereInput | damagesWhereInput[]
    id?: IntFilter<"damages"> | number
    doc_no?: StringFilter<"damages"> | string
    doc_date?: DateTimeFilter<"damages"> | Date | string
    ref_doc_no?: StringFilter<"damages"> | string
    sale_office_id?: IntFilter<"damages"> | number
    department_id?: IntFilter<"damages"> | number
    total?: FloatFilter<"damages"> | number
    sign_factory?: StringFilter<"damages"> | string
    sign_NH?: StringFilter<"damages"> | string
    sign_factory_time?: DateTimeFilter<"damages"> | Date | string
    sign_NH_time?: DateTimeFilter<"damages"> | Date | string
    factory_id?: IntFilter<"damages"> | number
    status?: BoolFilter<"damages"> | boolean
    create_at?: DateTimeFilter<"damages"> | Date | string
    update_at?: DateTimeFilter<"damages"> | Date | string
  }

  export type damagesOrderByWithRelationInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: damagesOrderByRelevanceInput
  }

  export type damagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: damagesWhereInput | damagesWhereInput[]
    OR?: damagesWhereInput[]
    NOT?: damagesWhereInput | damagesWhereInput[]
    doc_no?: StringFilter<"damages"> | string
    doc_date?: DateTimeFilter<"damages"> | Date | string
    ref_doc_no?: StringFilter<"damages"> | string
    sale_office_id?: IntFilter<"damages"> | number
    department_id?: IntFilter<"damages"> | number
    total?: FloatFilter<"damages"> | number
    sign_factory?: StringFilter<"damages"> | string
    sign_NH?: StringFilter<"damages"> | string
    sign_factory_time?: DateTimeFilter<"damages"> | Date | string
    sign_NH_time?: DateTimeFilter<"damages"> | Date | string
    factory_id?: IntFilter<"damages"> | number
    status?: BoolFilter<"damages"> | boolean
    create_at?: DateTimeFilter<"damages"> | Date | string
    update_at?: DateTimeFilter<"damages"> | Date | string
  }, "id">

  export type damagesOrderByWithAggregationInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: damagesCountOrderByAggregateInput
    _avg?: damagesAvgOrderByAggregateInput
    _max?: damagesMaxOrderByAggregateInput
    _min?: damagesMinOrderByAggregateInput
    _sum?: damagesSumOrderByAggregateInput
  }

  export type damagesScalarWhereWithAggregatesInput = {
    AND?: damagesScalarWhereWithAggregatesInput | damagesScalarWhereWithAggregatesInput[]
    OR?: damagesScalarWhereWithAggregatesInput[]
    NOT?: damagesScalarWhereWithAggregatesInput | damagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"damages"> | number
    doc_no?: StringWithAggregatesFilter<"damages"> | string
    doc_date?: DateTimeWithAggregatesFilter<"damages"> | Date | string
    ref_doc_no?: StringWithAggregatesFilter<"damages"> | string
    sale_office_id?: IntWithAggregatesFilter<"damages"> | number
    department_id?: IntWithAggregatesFilter<"damages"> | number
    total?: FloatWithAggregatesFilter<"damages"> | number
    sign_factory?: StringWithAggregatesFilter<"damages"> | string
    sign_NH?: StringWithAggregatesFilter<"damages"> | string
    sign_factory_time?: DateTimeWithAggregatesFilter<"damages"> | Date | string
    sign_NH_time?: DateTimeWithAggregatesFilter<"damages"> | Date | string
    factory_id?: IntWithAggregatesFilter<"damages"> | number
    status?: BoolWithAggregatesFilter<"damages"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"damages"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"damages"> | Date | string
  }

  export type damage_detailsWhereInput = {
    AND?: damage_detailsWhereInput | damage_detailsWhereInput[]
    OR?: damage_detailsWhereInput[]
    NOT?: damage_detailsWhereInput | damage_detailsWhereInput[]
    id?: IntFilter<"damage_details"> | number
    damage_id?: IntFilter<"damage_details"> | number
    item_id?: IntFilter<"damage_details"> | number
    unit_id?: IntFilter<"damage_details"> | number
    qty?: FloatFilter<"damage_details"> | number
    weight?: FloatFilter<"damage_details"> | number
    is_cancel?: BoolFilter<"damage_details"> | boolean
    is_checklist?: BoolFilter<"damage_details"> | boolean
    description?: StringFilter<"damage_details"> | string
    status?: BoolFilter<"damage_details"> | boolean
    create_at?: DateTimeFilter<"damage_details"> | Date | string
    update_at?: DateTimeFilter<"damage_details"> | Date | string
  }

  export type damage_detailsOrderByWithRelationInput = {
    id?: SortOrder
    damage_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: damage_detailsOrderByRelevanceInput
  }

  export type damage_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: damage_detailsWhereInput | damage_detailsWhereInput[]
    OR?: damage_detailsWhereInput[]
    NOT?: damage_detailsWhereInput | damage_detailsWhereInput[]
    damage_id?: IntFilter<"damage_details"> | number
    item_id?: IntFilter<"damage_details"> | number
    unit_id?: IntFilter<"damage_details"> | number
    qty?: FloatFilter<"damage_details"> | number
    weight?: FloatFilter<"damage_details"> | number
    is_cancel?: BoolFilter<"damage_details"> | boolean
    is_checklist?: BoolFilter<"damage_details"> | boolean
    description?: StringFilter<"damage_details"> | string
    status?: BoolFilter<"damage_details"> | boolean
    create_at?: DateTimeFilter<"damage_details"> | Date | string
    update_at?: DateTimeFilter<"damage_details"> | Date | string
  }, "id">

  export type damage_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    damage_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: damage_detailsCountOrderByAggregateInput
    _avg?: damage_detailsAvgOrderByAggregateInput
    _max?: damage_detailsMaxOrderByAggregateInput
    _min?: damage_detailsMinOrderByAggregateInput
    _sum?: damage_detailsSumOrderByAggregateInput
  }

  export type damage_detailsScalarWhereWithAggregatesInput = {
    AND?: damage_detailsScalarWhereWithAggregatesInput | damage_detailsScalarWhereWithAggregatesInput[]
    OR?: damage_detailsScalarWhereWithAggregatesInput[]
    NOT?: damage_detailsScalarWhereWithAggregatesInput | damage_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"damage_details"> | number
    damage_id?: IntWithAggregatesFilter<"damage_details"> | number
    item_id?: IntWithAggregatesFilter<"damage_details"> | number
    unit_id?: IntWithAggregatesFilter<"damage_details"> | number
    qty?: FloatWithAggregatesFilter<"damage_details"> | number
    weight?: FloatWithAggregatesFilter<"damage_details"> | number
    is_cancel?: BoolWithAggregatesFilter<"damage_details"> | boolean
    is_checklist?: BoolWithAggregatesFilter<"damage_details"> | boolean
    description?: StringWithAggregatesFilter<"damage_details"> | string
    status?: BoolWithAggregatesFilter<"damage_details"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"damage_details"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"damage_details"> | Date | string
  }

  export type shipsWhereInput = {
    AND?: shipsWhereInput | shipsWhereInput[]
    OR?: shipsWhereInput[]
    NOT?: shipsWhereInput | shipsWhereInput[]
    id?: IntFilter<"ships"> | number
    item_id?: IntFilter<"ships"> | number
    site_short_code?: StringFilter<"ships"> | string
    description?: StringFilter<"ships"> | string
    status?: BoolFilter<"ships"> | boolean
    create_at?: DateTimeFilter<"ships"> | Date | string
    update_at?: DateTimeFilter<"ships"> | Date | string
  }

  export type shipsOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: shipsOrderByRelevanceInput
  }

  export type shipsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: shipsWhereInput | shipsWhereInput[]
    OR?: shipsWhereInput[]
    NOT?: shipsWhereInput | shipsWhereInput[]
    item_id?: IntFilter<"ships"> | number
    site_short_code?: StringFilter<"ships"> | string
    description?: StringFilter<"ships"> | string
    status?: BoolFilter<"ships"> | boolean
    create_at?: DateTimeFilter<"ships"> | Date | string
    update_at?: DateTimeFilter<"ships"> | Date | string
  }, "id">

  export type shipsOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: shipsCountOrderByAggregateInput
    _avg?: shipsAvgOrderByAggregateInput
    _max?: shipsMaxOrderByAggregateInput
    _min?: shipsMinOrderByAggregateInput
    _sum?: shipsSumOrderByAggregateInput
  }

  export type shipsScalarWhereWithAggregatesInput = {
    AND?: shipsScalarWhereWithAggregatesInput | shipsScalarWhereWithAggregatesInput[]
    OR?: shipsScalarWhereWithAggregatesInput[]
    NOT?: shipsScalarWhereWithAggregatesInput | shipsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ships"> | number
    item_id?: IntWithAggregatesFilter<"ships"> | number
    site_short_code?: StringWithAggregatesFilter<"ships"> | string
    description?: StringWithAggregatesFilter<"ships"> | string
    status?: BoolWithAggregatesFilter<"ships"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"ships"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"ships"> | Date | string
  }

  export type new_linensWhereInput = {
    AND?: new_linensWhereInput | new_linensWhereInput[]
    OR?: new_linensWhereInput[]
    NOT?: new_linensWhereInput | new_linensWhereInput[]
    id?: IntFilter<"new_linens"> | number
    doc_no?: StringFilter<"new_linens"> | string
    doc_date?: DateTimeFilter<"new_linens"> | Date | string
    ref_doc_no?: StringNullableFilter<"new_linens"> | string | null
    sale_office_id?: IntFilter<"new_linens"> | number
    department_id?: IntFilter<"new_linens"> | number
    total?: FloatFilter<"new_linens"> | number
    is_recive?: BoolNullableFilter<"new_linens"> | boolean | null
    receive_date?: DateTimeNullableFilter<"new_linens"> | Date | string | null
    receive_detail?: StringNullableFilter<"new_linens"> | string | null
    is_process?: BoolNullableFilter<"new_linens"> | boolean | null
    sign_factory?: StringNullableFilter<"new_linens"> | string | null
    sign_NH?: StringNullableFilter<"new_linens"> | string | null
    sign_factory_time?: DateTimeNullableFilter<"new_linens"> | Date | string | null
    sign_NH_time?: DateTimeNullableFilter<"new_linens"> | Date | string | null
    factory_id?: IntFilter<"new_linens"> | number
    status?: BoolFilter<"new_linens"> | boolean
    create_at?: DateTimeFilter<"new_linens"> | Date | string
    update_at?: DateTimeFilter<"new_linens"> | Date | string
  }

  export type new_linensOrderByWithRelationInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrderInput | SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrderInput | SortOrder
    receive_date?: SortOrderInput | SortOrder
    receive_detail?: SortOrderInput | SortOrder
    is_process?: SortOrderInput | SortOrder
    sign_factory?: SortOrderInput | SortOrder
    sign_NH?: SortOrderInput | SortOrder
    sign_factory_time?: SortOrderInput | SortOrder
    sign_NH_time?: SortOrderInput | SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: new_linensOrderByRelevanceInput
  }

  export type new_linensWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: new_linensWhereInput | new_linensWhereInput[]
    OR?: new_linensWhereInput[]
    NOT?: new_linensWhereInput | new_linensWhereInput[]
    doc_no?: StringFilter<"new_linens"> | string
    doc_date?: DateTimeFilter<"new_linens"> | Date | string
    ref_doc_no?: StringNullableFilter<"new_linens"> | string | null
    sale_office_id?: IntFilter<"new_linens"> | number
    department_id?: IntFilter<"new_linens"> | number
    total?: FloatFilter<"new_linens"> | number
    is_recive?: BoolNullableFilter<"new_linens"> | boolean | null
    receive_date?: DateTimeNullableFilter<"new_linens"> | Date | string | null
    receive_detail?: StringNullableFilter<"new_linens"> | string | null
    is_process?: BoolNullableFilter<"new_linens"> | boolean | null
    sign_factory?: StringNullableFilter<"new_linens"> | string | null
    sign_NH?: StringNullableFilter<"new_linens"> | string | null
    sign_factory_time?: DateTimeNullableFilter<"new_linens"> | Date | string | null
    sign_NH_time?: DateTimeNullableFilter<"new_linens"> | Date | string | null
    factory_id?: IntFilter<"new_linens"> | number
    status?: BoolFilter<"new_linens"> | boolean
    create_at?: DateTimeFilter<"new_linens"> | Date | string
    update_at?: DateTimeFilter<"new_linens"> | Date | string
  }, "id">

  export type new_linensOrderByWithAggregationInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrderInput | SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrderInput | SortOrder
    receive_date?: SortOrderInput | SortOrder
    receive_detail?: SortOrderInput | SortOrder
    is_process?: SortOrderInput | SortOrder
    sign_factory?: SortOrderInput | SortOrder
    sign_NH?: SortOrderInput | SortOrder
    sign_factory_time?: SortOrderInput | SortOrder
    sign_NH_time?: SortOrderInput | SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: new_linensCountOrderByAggregateInput
    _avg?: new_linensAvgOrderByAggregateInput
    _max?: new_linensMaxOrderByAggregateInput
    _min?: new_linensMinOrderByAggregateInput
    _sum?: new_linensSumOrderByAggregateInput
  }

  export type new_linensScalarWhereWithAggregatesInput = {
    AND?: new_linensScalarWhereWithAggregatesInput | new_linensScalarWhereWithAggregatesInput[]
    OR?: new_linensScalarWhereWithAggregatesInput[]
    NOT?: new_linensScalarWhereWithAggregatesInput | new_linensScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"new_linens"> | number
    doc_no?: StringWithAggregatesFilter<"new_linens"> | string
    doc_date?: DateTimeWithAggregatesFilter<"new_linens"> | Date | string
    ref_doc_no?: StringNullableWithAggregatesFilter<"new_linens"> | string | null
    sale_office_id?: IntWithAggregatesFilter<"new_linens"> | number
    department_id?: IntWithAggregatesFilter<"new_linens"> | number
    total?: FloatWithAggregatesFilter<"new_linens"> | number
    is_recive?: BoolNullableWithAggregatesFilter<"new_linens"> | boolean | null
    receive_date?: DateTimeNullableWithAggregatesFilter<"new_linens"> | Date | string | null
    receive_detail?: StringNullableWithAggregatesFilter<"new_linens"> | string | null
    is_process?: BoolNullableWithAggregatesFilter<"new_linens"> | boolean | null
    sign_factory?: StringNullableWithAggregatesFilter<"new_linens"> | string | null
    sign_NH?: StringNullableWithAggregatesFilter<"new_linens"> | string | null
    sign_factory_time?: DateTimeNullableWithAggregatesFilter<"new_linens"> | Date | string | null
    sign_NH_time?: DateTimeNullableWithAggregatesFilter<"new_linens"> | Date | string | null
    factory_id?: IntWithAggregatesFilter<"new_linens"> | number
    status?: BoolWithAggregatesFilter<"new_linens"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"new_linens"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"new_linens"> | Date | string
  }

  export type new_linen_detailsWhereInput = {
    AND?: new_linen_detailsWhereInput | new_linen_detailsWhereInput[]
    OR?: new_linen_detailsWhereInput[]
    NOT?: new_linen_detailsWhereInput | new_linen_detailsWhereInput[]
    id?: IntFilter<"new_linen_details"> | number
    new_linen_id?: IntFilter<"new_linen_details"> | number
    department_id?: IntFilter<"new_linen_details"> | number
    item_id?: IntFilter<"new_linen_details"> | number
    unit_id?: IntFilter<"new_linen_details"> | number
    qty?: FloatFilter<"new_linen_details"> | number
    receive_qty?: FloatFilter<"new_linen_details"> | number
    weight?: FloatFilter<"new_linen_details"> | number
    is_cancel?: BoolFilter<"new_linen_details"> | boolean
    description?: StringNullableFilter<"new_linen_details"> | string | null
    status?: BoolFilter<"new_linen_details"> | boolean
    create_at?: DateTimeFilter<"new_linen_details"> | Date | string
    update_at?: DateTimeFilter<"new_linen_details"> | Date | string
  }

  export type new_linen_detailsOrderByWithRelationInput = {
    id?: SortOrder
    new_linen_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: new_linen_detailsOrderByRelevanceInput
  }

  export type new_linen_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: new_linen_detailsWhereInput | new_linen_detailsWhereInput[]
    OR?: new_linen_detailsWhereInput[]
    NOT?: new_linen_detailsWhereInput | new_linen_detailsWhereInput[]
    new_linen_id?: IntFilter<"new_linen_details"> | number
    department_id?: IntFilter<"new_linen_details"> | number
    item_id?: IntFilter<"new_linen_details"> | number
    unit_id?: IntFilter<"new_linen_details"> | number
    qty?: FloatFilter<"new_linen_details"> | number
    receive_qty?: FloatFilter<"new_linen_details"> | number
    weight?: FloatFilter<"new_linen_details"> | number
    is_cancel?: BoolFilter<"new_linen_details"> | boolean
    description?: StringNullableFilter<"new_linen_details"> | string | null
    status?: BoolFilter<"new_linen_details"> | boolean
    create_at?: DateTimeFilter<"new_linen_details"> | Date | string
    update_at?: DateTimeFilter<"new_linen_details"> | Date | string
  }, "id">

  export type new_linen_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    new_linen_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: new_linen_detailsCountOrderByAggregateInput
    _avg?: new_linen_detailsAvgOrderByAggregateInput
    _max?: new_linen_detailsMaxOrderByAggregateInput
    _min?: new_linen_detailsMinOrderByAggregateInput
    _sum?: new_linen_detailsSumOrderByAggregateInput
  }

  export type new_linen_detailsScalarWhereWithAggregatesInput = {
    AND?: new_linen_detailsScalarWhereWithAggregatesInput | new_linen_detailsScalarWhereWithAggregatesInput[]
    OR?: new_linen_detailsScalarWhereWithAggregatesInput[]
    NOT?: new_linen_detailsScalarWhereWithAggregatesInput | new_linen_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"new_linen_details"> | number
    new_linen_id?: IntWithAggregatesFilter<"new_linen_details"> | number
    department_id?: IntWithAggregatesFilter<"new_linen_details"> | number
    item_id?: IntWithAggregatesFilter<"new_linen_details"> | number
    unit_id?: IntWithAggregatesFilter<"new_linen_details"> | number
    qty?: FloatWithAggregatesFilter<"new_linen_details"> | number
    receive_qty?: FloatWithAggregatesFilter<"new_linen_details"> | number
    weight?: FloatWithAggregatesFilter<"new_linen_details"> | number
    is_cancel?: BoolWithAggregatesFilter<"new_linen_details"> | boolean
    description?: StringNullableWithAggregatesFilter<"new_linen_details"> | string | null
    status?: BoolWithAggregatesFilter<"new_linen_details"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"new_linen_details"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"new_linen_details"> | Date | string
  }

  export type repair_washsWhereInput = {
    AND?: repair_washsWhereInput | repair_washsWhereInput[]
    OR?: repair_washsWhereInput[]
    NOT?: repair_washsWhereInput | repair_washsWhereInput[]
    id?: IntFilter<"repair_washs"> | number
    doc_no?: StringFilter<"repair_washs"> | string
    doc_date?: DateTimeFilter<"repair_washs"> | Date | string
    ref_doc_no?: StringFilter<"repair_washs"> | string
    sale_office_id?: IntFilter<"repair_washs"> | number
    department_id?: IntFilter<"repair_washs"> | number
    clean_id?: IntFilter<"repair_washs"> | number
    total?: FloatFilter<"repair_washs"> | number
    is_recive?: BoolFilter<"repair_washs"> | boolean
    receive_date?: DateTimeFilter<"repair_washs"> | Date | string
    receive_detail?: StringFilter<"repair_washs"> | string
    is_process?: BoolFilter<"repair_washs"> | boolean
    sign_factory?: StringFilter<"repair_washs"> | string
    sign_NH?: StringFilter<"repair_washs"> | string
    sign_factory_time?: DateTimeFilter<"repair_washs"> | Date | string
    sign_NH_time?: DateTimeFilter<"repair_washs"> | Date | string
    factory_id?: IntFilter<"repair_washs"> | number
    status?: BoolFilter<"repair_washs"> | boolean
    create_at?: DateTimeFilter<"repair_washs"> | Date | string
    update_at?: DateTimeFilter<"repair_washs"> | Date | string
  }

  export type repair_washsOrderByWithRelationInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    clean_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrder
    receive_date?: SortOrder
    receive_detail?: SortOrder
    is_process?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: repair_washsOrderByRelevanceInput
  }

  export type repair_washsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: repair_washsWhereInput | repair_washsWhereInput[]
    OR?: repair_washsWhereInput[]
    NOT?: repair_washsWhereInput | repair_washsWhereInput[]
    doc_no?: StringFilter<"repair_washs"> | string
    doc_date?: DateTimeFilter<"repair_washs"> | Date | string
    ref_doc_no?: StringFilter<"repair_washs"> | string
    sale_office_id?: IntFilter<"repair_washs"> | number
    department_id?: IntFilter<"repair_washs"> | number
    clean_id?: IntFilter<"repair_washs"> | number
    total?: FloatFilter<"repair_washs"> | number
    is_recive?: BoolFilter<"repair_washs"> | boolean
    receive_date?: DateTimeFilter<"repair_washs"> | Date | string
    receive_detail?: StringFilter<"repair_washs"> | string
    is_process?: BoolFilter<"repair_washs"> | boolean
    sign_factory?: StringFilter<"repair_washs"> | string
    sign_NH?: StringFilter<"repair_washs"> | string
    sign_factory_time?: DateTimeFilter<"repair_washs"> | Date | string
    sign_NH_time?: DateTimeFilter<"repair_washs"> | Date | string
    factory_id?: IntFilter<"repair_washs"> | number
    status?: BoolFilter<"repair_washs"> | boolean
    create_at?: DateTimeFilter<"repair_washs"> | Date | string
    update_at?: DateTimeFilter<"repair_washs"> | Date | string
  }, "id">

  export type repair_washsOrderByWithAggregationInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    clean_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrder
    receive_date?: SortOrder
    receive_detail?: SortOrder
    is_process?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: repair_washsCountOrderByAggregateInput
    _avg?: repair_washsAvgOrderByAggregateInput
    _max?: repair_washsMaxOrderByAggregateInput
    _min?: repair_washsMinOrderByAggregateInput
    _sum?: repair_washsSumOrderByAggregateInput
  }

  export type repair_washsScalarWhereWithAggregatesInput = {
    AND?: repair_washsScalarWhereWithAggregatesInput | repair_washsScalarWhereWithAggregatesInput[]
    OR?: repair_washsScalarWhereWithAggregatesInput[]
    NOT?: repair_washsScalarWhereWithAggregatesInput | repair_washsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"repair_washs"> | number
    doc_no?: StringWithAggregatesFilter<"repair_washs"> | string
    doc_date?: DateTimeWithAggregatesFilter<"repair_washs"> | Date | string
    ref_doc_no?: StringWithAggregatesFilter<"repair_washs"> | string
    sale_office_id?: IntWithAggregatesFilter<"repair_washs"> | number
    department_id?: IntWithAggregatesFilter<"repair_washs"> | number
    clean_id?: IntWithAggregatesFilter<"repair_washs"> | number
    total?: FloatWithAggregatesFilter<"repair_washs"> | number
    is_recive?: BoolWithAggregatesFilter<"repair_washs"> | boolean
    receive_date?: DateTimeWithAggregatesFilter<"repair_washs"> | Date | string
    receive_detail?: StringWithAggregatesFilter<"repair_washs"> | string
    is_process?: BoolWithAggregatesFilter<"repair_washs"> | boolean
    sign_factory?: StringWithAggregatesFilter<"repair_washs"> | string
    sign_NH?: StringWithAggregatesFilter<"repair_washs"> | string
    sign_factory_time?: DateTimeWithAggregatesFilter<"repair_washs"> | Date | string
    sign_NH_time?: DateTimeWithAggregatesFilter<"repair_washs"> | Date | string
    factory_id?: IntWithAggregatesFilter<"repair_washs"> | number
    status?: BoolWithAggregatesFilter<"repair_washs"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"repair_washs"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"repair_washs"> | Date | string
  }

  export type repair_wash_detailsWhereInput = {
    AND?: repair_wash_detailsWhereInput | repair_wash_detailsWhereInput[]
    OR?: repair_wash_detailsWhereInput[]
    NOT?: repair_wash_detailsWhereInput | repair_wash_detailsWhereInput[]
    id?: IntFilter<"repair_wash_details"> | number
    repair_wash_id?: IntFilter<"repair_wash_details"> | number
    item_id?: IntFilter<"repair_wash_details"> | number
    unit_id?: IntFilter<"repair_wash_details"> | number
    qty?: FloatFilter<"repair_wash_details"> | number
    receive_qty?: FloatFilter<"repair_wash_details"> | number
    weight?: FloatFilter<"repair_wash_details"> | number
    is_cancel?: BoolFilter<"repair_wash_details"> | boolean
    is_checklist?: BoolFilter<"repair_wash_details"> | boolean
    description?: StringFilter<"repair_wash_details"> | string
    status?: BoolFilter<"repair_wash_details"> | boolean
    create_at?: DateTimeFilter<"repair_wash_details"> | Date | string
    update_at?: DateTimeFilter<"repair_wash_details"> | Date | string
  }

  export type repair_wash_detailsOrderByWithRelationInput = {
    id?: SortOrder
    repair_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: repair_wash_detailsOrderByRelevanceInput
  }

  export type repair_wash_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: repair_wash_detailsWhereInput | repair_wash_detailsWhereInput[]
    OR?: repair_wash_detailsWhereInput[]
    NOT?: repair_wash_detailsWhereInput | repair_wash_detailsWhereInput[]
    repair_wash_id?: IntFilter<"repair_wash_details"> | number
    item_id?: IntFilter<"repair_wash_details"> | number
    unit_id?: IntFilter<"repair_wash_details"> | number
    qty?: FloatFilter<"repair_wash_details"> | number
    receive_qty?: FloatFilter<"repair_wash_details"> | number
    weight?: FloatFilter<"repair_wash_details"> | number
    is_cancel?: BoolFilter<"repair_wash_details"> | boolean
    is_checklist?: BoolFilter<"repair_wash_details"> | boolean
    description?: StringFilter<"repair_wash_details"> | string
    status?: BoolFilter<"repair_wash_details"> | boolean
    create_at?: DateTimeFilter<"repair_wash_details"> | Date | string
    update_at?: DateTimeFilter<"repair_wash_details"> | Date | string
  }, "id">

  export type repair_wash_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    repair_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: repair_wash_detailsCountOrderByAggregateInput
    _avg?: repair_wash_detailsAvgOrderByAggregateInput
    _max?: repair_wash_detailsMaxOrderByAggregateInput
    _min?: repair_wash_detailsMinOrderByAggregateInput
    _sum?: repair_wash_detailsSumOrderByAggregateInput
  }

  export type repair_wash_detailsScalarWhereWithAggregatesInput = {
    AND?: repair_wash_detailsScalarWhereWithAggregatesInput | repair_wash_detailsScalarWhereWithAggregatesInput[]
    OR?: repair_wash_detailsScalarWhereWithAggregatesInput[]
    NOT?: repair_wash_detailsScalarWhereWithAggregatesInput | repair_wash_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"repair_wash_details"> | number
    repair_wash_id?: IntWithAggregatesFilter<"repair_wash_details"> | number
    item_id?: IntWithAggregatesFilter<"repair_wash_details"> | number
    unit_id?: IntWithAggregatesFilter<"repair_wash_details"> | number
    qty?: FloatWithAggregatesFilter<"repair_wash_details"> | number
    receive_qty?: FloatWithAggregatesFilter<"repair_wash_details"> | number
    weight?: FloatWithAggregatesFilter<"repair_wash_details"> | number
    is_cancel?: BoolWithAggregatesFilter<"repair_wash_details"> | boolean
    is_checklist?: BoolWithAggregatesFilter<"repair_wash_details"> | boolean
    description?: StringWithAggregatesFilter<"repair_wash_details"> | string
    status?: BoolWithAggregatesFilter<"repair_wash_details"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"repair_wash_details"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"repair_wash_details"> | Date | string
  }

  export type cleansWhereInput = {
    AND?: cleansWhereInput | cleansWhereInput[]
    OR?: cleansWhereInput[]
    NOT?: cleansWhereInput | cleansWhereInput[]
    id?: IntFilter<"cleans"> | number
    clean_doc_no?: StringFilter<"cleans"> | string
    doc_date?: DateTimeFilter<"cleans"> | Date | string
    sale_office_id?: IntFilter<"cleans"> | number
    department_id?: IntFilter<"cleans"> | number
    dirty_id?: IntFilter<"cleans"> | number
    user_id?: IntFilter<"cleans"> | number
    signature?: StringFilter<"cleans"> | string
    sign_factory?: StringFilter<"cleans"> | string
    sign_NH?: StringFilter<"cleans"> | string
    sign_factory_time?: DateTimeFilter<"cleans"> | Date | string
    sign_NH_time?: DateTimeFilter<"cleans"> | Date | string
    factory_id?: IntFilter<"cleans"> | number
    status?: BoolFilter<"cleans"> | boolean
    create_at?: DateTimeFilter<"cleans"> | Date | string
    update_at?: DateTimeFilter<"cleans"> | Date | string
  }

  export type cleansOrderByWithRelationInput = {
    id?: SortOrder
    clean_doc_no?: SortOrder
    doc_date?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: cleansOrderByRelevanceInput
  }

  export type cleansWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cleansWhereInput | cleansWhereInput[]
    OR?: cleansWhereInput[]
    NOT?: cleansWhereInput | cleansWhereInput[]
    clean_doc_no?: StringFilter<"cleans"> | string
    doc_date?: DateTimeFilter<"cleans"> | Date | string
    sale_office_id?: IntFilter<"cleans"> | number
    department_id?: IntFilter<"cleans"> | number
    dirty_id?: IntFilter<"cleans"> | number
    user_id?: IntFilter<"cleans"> | number
    signature?: StringFilter<"cleans"> | string
    sign_factory?: StringFilter<"cleans"> | string
    sign_NH?: StringFilter<"cleans"> | string
    sign_factory_time?: DateTimeFilter<"cleans"> | Date | string
    sign_NH_time?: DateTimeFilter<"cleans"> | Date | string
    factory_id?: IntFilter<"cleans"> | number
    status?: BoolFilter<"cleans"> | boolean
    create_at?: DateTimeFilter<"cleans"> | Date | string
    update_at?: DateTimeFilter<"cleans"> | Date | string
  }, "id">

  export type cleansOrderByWithAggregationInput = {
    id?: SortOrder
    clean_doc_no?: SortOrder
    doc_date?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: cleansCountOrderByAggregateInput
    _avg?: cleansAvgOrderByAggregateInput
    _max?: cleansMaxOrderByAggregateInput
    _min?: cleansMinOrderByAggregateInput
    _sum?: cleansSumOrderByAggregateInput
  }

  export type cleansScalarWhereWithAggregatesInput = {
    AND?: cleansScalarWhereWithAggregatesInput | cleansScalarWhereWithAggregatesInput[]
    OR?: cleansScalarWhereWithAggregatesInput[]
    NOT?: cleansScalarWhereWithAggregatesInput | cleansScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cleans"> | number
    clean_doc_no?: StringWithAggregatesFilter<"cleans"> | string
    doc_date?: DateTimeWithAggregatesFilter<"cleans"> | Date | string
    sale_office_id?: IntWithAggregatesFilter<"cleans"> | number
    department_id?: IntWithAggregatesFilter<"cleans"> | number
    dirty_id?: IntWithAggregatesFilter<"cleans"> | number
    user_id?: IntWithAggregatesFilter<"cleans"> | number
    signature?: StringWithAggregatesFilter<"cleans"> | string
    sign_factory?: StringWithAggregatesFilter<"cleans"> | string
    sign_NH?: StringWithAggregatesFilter<"cleans"> | string
    sign_factory_time?: DateTimeWithAggregatesFilter<"cleans"> | Date | string
    sign_NH_time?: DateTimeWithAggregatesFilter<"cleans"> | Date | string
    factory_id?: IntWithAggregatesFilter<"cleans"> | number
    status?: BoolWithAggregatesFilter<"cleans"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"cleans"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"cleans"> | Date | string
  }

  export type clean_detailsWhereInput = {
    AND?: clean_detailsWhereInput | clean_detailsWhereInput[]
    OR?: clean_detailsWhereInput[]
    NOT?: clean_detailsWhereInput | clean_detailsWhereInput[]
    id?: IntFilter<"clean_details"> | number
    clean_id?: IntFilter<"clean_details"> | number
    item_id?: IntFilter<"clean_details"> | number
    unit_id?: IntFilter<"clean_details"> | number
    qty?: FloatFilter<"clean_details"> | number
    weight?: FloatFilter<"clean_details"> | number
    request_name?: StringFilter<"clean_details"> | string
    description?: StringFilter<"clean_details"> | string
    status?: BoolFilter<"clean_details"> | boolean
    create_at?: DateTimeFilter<"clean_details"> | Date | string
    update_at?: DateTimeFilter<"clean_details"> | Date | string
  }

  export type clean_detailsOrderByWithRelationInput = {
    id?: SortOrder
    clean_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: clean_detailsOrderByRelevanceInput
  }

  export type clean_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: clean_detailsWhereInput | clean_detailsWhereInput[]
    OR?: clean_detailsWhereInput[]
    NOT?: clean_detailsWhereInput | clean_detailsWhereInput[]
    clean_id?: IntFilter<"clean_details"> | number
    item_id?: IntFilter<"clean_details"> | number
    unit_id?: IntFilter<"clean_details"> | number
    qty?: FloatFilter<"clean_details"> | number
    weight?: FloatFilter<"clean_details"> | number
    request_name?: StringFilter<"clean_details"> | string
    description?: StringFilter<"clean_details"> | string
    status?: BoolFilter<"clean_details"> | boolean
    create_at?: DateTimeFilter<"clean_details"> | Date | string
    update_at?: DateTimeFilter<"clean_details"> | Date | string
  }, "id">

  export type clean_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    clean_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: clean_detailsCountOrderByAggregateInput
    _avg?: clean_detailsAvgOrderByAggregateInput
    _max?: clean_detailsMaxOrderByAggregateInput
    _min?: clean_detailsMinOrderByAggregateInput
    _sum?: clean_detailsSumOrderByAggregateInput
  }

  export type clean_detailsScalarWhereWithAggregatesInput = {
    AND?: clean_detailsScalarWhereWithAggregatesInput | clean_detailsScalarWhereWithAggregatesInput[]
    OR?: clean_detailsScalarWhereWithAggregatesInput[]
    NOT?: clean_detailsScalarWhereWithAggregatesInput | clean_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"clean_details"> | number
    clean_id?: IntWithAggregatesFilter<"clean_details"> | number
    item_id?: IntWithAggregatesFilter<"clean_details"> | number
    unit_id?: IntWithAggregatesFilter<"clean_details"> | number
    qty?: FloatWithAggregatesFilter<"clean_details"> | number
    weight?: FloatWithAggregatesFilter<"clean_details"> | number
    request_name?: StringWithAggregatesFilter<"clean_details"> | string
    description?: StringWithAggregatesFilter<"clean_details"> | string
    status?: BoolWithAggregatesFilter<"clean_details"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"clean_details"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"clean_details"> | Date | string
  }

  export type return_washsWhereInput = {
    AND?: return_washsWhereInput | return_washsWhereInput[]
    OR?: return_washsWhereInput[]
    NOT?: return_washsWhereInput | return_washsWhereInput[]
    id?: IntFilter<"return_washs"> | number
    doc_no?: StringFilter<"return_washs"> | string
    doc_date?: DateTimeFilter<"return_washs"> | Date | string
    ref_doc_no?: StringFilter<"return_washs"> | string
    sale_office_id?: IntFilter<"return_washs"> | number
    department_id?: IntFilter<"return_washs"> | number
    total?: FloatFilter<"return_washs"> | number
    dirty_id?: IntFilter<"return_washs"> | number
    user_id?: IntFilter<"return_washs"> | number
    signature?: StringFilter<"return_washs"> | string
    sign_factory?: StringFilter<"return_washs"> | string
    sign_NH?: StringFilter<"return_washs"> | string
    sign_factory_time?: DateTimeFilter<"return_washs"> | Date | string
    sign_NH_time?: DateTimeFilter<"return_washs"> | Date | string
    factory_id?: IntFilter<"return_washs"> | number
    status?: BoolFilter<"return_washs"> | boolean
    create_at?: DateTimeFilter<"return_washs"> | Date | string
    update_at?: DateTimeFilter<"return_washs"> | Date | string
  }

  export type return_washsOrderByWithRelationInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: return_washsOrderByRelevanceInput
  }

  export type return_washsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: return_washsWhereInput | return_washsWhereInput[]
    OR?: return_washsWhereInput[]
    NOT?: return_washsWhereInput | return_washsWhereInput[]
    doc_no?: StringFilter<"return_washs"> | string
    doc_date?: DateTimeFilter<"return_washs"> | Date | string
    ref_doc_no?: StringFilter<"return_washs"> | string
    sale_office_id?: IntFilter<"return_washs"> | number
    department_id?: IntFilter<"return_washs"> | number
    total?: FloatFilter<"return_washs"> | number
    dirty_id?: IntFilter<"return_washs"> | number
    user_id?: IntFilter<"return_washs"> | number
    signature?: StringFilter<"return_washs"> | string
    sign_factory?: StringFilter<"return_washs"> | string
    sign_NH?: StringFilter<"return_washs"> | string
    sign_factory_time?: DateTimeFilter<"return_washs"> | Date | string
    sign_NH_time?: DateTimeFilter<"return_washs"> | Date | string
    factory_id?: IntFilter<"return_washs"> | number
    status?: BoolFilter<"return_washs"> | boolean
    create_at?: DateTimeFilter<"return_washs"> | Date | string
    update_at?: DateTimeFilter<"return_washs"> | Date | string
  }, "id">

  export type return_washsOrderByWithAggregationInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: return_washsCountOrderByAggregateInput
    _avg?: return_washsAvgOrderByAggregateInput
    _max?: return_washsMaxOrderByAggregateInput
    _min?: return_washsMinOrderByAggregateInput
    _sum?: return_washsSumOrderByAggregateInput
  }

  export type return_washsScalarWhereWithAggregatesInput = {
    AND?: return_washsScalarWhereWithAggregatesInput | return_washsScalarWhereWithAggregatesInput[]
    OR?: return_washsScalarWhereWithAggregatesInput[]
    NOT?: return_washsScalarWhereWithAggregatesInput | return_washsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"return_washs"> | number
    doc_no?: StringWithAggregatesFilter<"return_washs"> | string
    doc_date?: DateTimeWithAggregatesFilter<"return_washs"> | Date | string
    ref_doc_no?: StringWithAggregatesFilter<"return_washs"> | string
    sale_office_id?: IntWithAggregatesFilter<"return_washs"> | number
    department_id?: IntWithAggregatesFilter<"return_washs"> | number
    total?: FloatWithAggregatesFilter<"return_washs"> | number
    dirty_id?: IntWithAggregatesFilter<"return_washs"> | number
    user_id?: IntWithAggregatesFilter<"return_washs"> | number
    signature?: StringWithAggregatesFilter<"return_washs"> | string
    sign_factory?: StringWithAggregatesFilter<"return_washs"> | string
    sign_NH?: StringWithAggregatesFilter<"return_washs"> | string
    sign_factory_time?: DateTimeWithAggregatesFilter<"return_washs"> | Date | string
    sign_NH_time?: DateTimeWithAggregatesFilter<"return_washs"> | Date | string
    factory_id?: IntWithAggregatesFilter<"return_washs"> | number
    status?: BoolWithAggregatesFilter<"return_washs"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"return_washs"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"return_washs"> | Date | string
  }

  export type retrun_wash_detailsWhereInput = {
    AND?: retrun_wash_detailsWhereInput | retrun_wash_detailsWhereInput[]
    OR?: retrun_wash_detailsWhereInput[]
    NOT?: retrun_wash_detailsWhereInput | retrun_wash_detailsWhereInput[]
    id?: IntFilter<"retrun_wash_details"> | number
    return_wash_id?: IntFilter<"retrun_wash_details"> | number
    item_id?: IntFilter<"retrun_wash_details"> | number
    unit_id?: IntFilter<"retrun_wash_details"> | number
    qty?: FloatFilter<"retrun_wash_details"> | number
    weight?: FloatFilter<"retrun_wash_details"> | number
    is_cancel?: BoolFilter<"retrun_wash_details"> | boolean
    is_checklist?: BoolFilter<"retrun_wash_details"> | boolean
    request_name?: StringFilter<"retrun_wash_details"> | string
    description?: StringFilter<"retrun_wash_details"> | string
    status?: BoolFilter<"retrun_wash_details"> | boolean
    create_at?: DateTimeFilter<"retrun_wash_details"> | Date | string
    update_at?: DateTimeFilter<"retrun_wash_details"> | Date | string
  }

  export type retrun_wash_detailsOrderByWithRelationInput = {
    id?: SortOrder
    return_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _relevance?: retrun_wash_detailsOrderByRelevanceInput
  }

  export type retrun_wash_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: retrun_wash_detailsWhereInput | retrun_wash_detailsWhereInput[]
    OR?: retrun_wash_detailsWhereInput[]
    NOT?: retrun_wash_detailsWhereInput | retrun_wash_detailsWhereInput[]
    return_wash_id?: IntFilter<"retrun_wash_details"> | number
    item_id?: IntFilter<"retrun_wash_details"> | number
    unit_id?: IntFilter<"retrun_wash_details"> | number
    qty?: FloatFilter<"retrun_wash_details"> | number
    weight?: FloatFilter<"retrun_wash_details"> | number
    is_cancel?: BoolFilter<"retrun_wash_details"> | boolean
    is_checklist?: BoolFilter<"retrun_wash_details"> | boolean
    request_name?: StringFilter<"retrun_wash_details"> | string
    description?: StringFilter<"retrun_wash_details"> | string
    status?: BoolFilter<"retrun_wash_details"> | boolean
    create_at?: DateTimeFilter<"retrun_wash_details"> | Date | string
    update_at?: DateTimeFilter<"retrun_wash_details"> | Date | string
  }, "id">

  export type retrun_wash_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    return_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
    _count?: retrun_wash_detailsCountOrderByAggregateInput
    _avg?: retrun_wash_detailsAvgOrderByAggregateInput
    _max?: retrun_wash_detailsMaxOrderByAggregateInput
    _min?: retrun_wash_detailsMinOrderByAggregateInput
    _sum?: retrun_wash_detailsSumOrderByAggregateInput
  }

  export type retrun_wash_detailsScalarWhereWithAggregatesInput = {
    AND?: retrun_wash_detailsScalarWhereWithAggregatesInput | retrun_wash_detailsScalarWhereWithAggregatesInput[]
    OR?: retrun_wash_detailsScalarWhereWithAggregatesInput[]
    NOT?: retrun_wash_detailsScalarWhereWithAggregatesInput | retrun_wash_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"retrun_wash_details"> | number
    return_wash_id?: IntWithAggregatesFilter<"retrun_wash_details"> | number
    item_id?: IntWithAggregatesFilter<"retrun_wash_details"> | number
    unit_id?: IntWithAggregatesFilter<"retrun_wash_details"> | number
    qty?: FloatWithAggregatesFilter<"retrun_wash_details"> | number
    weight?: FloatWithAggregatesFilter<"retrun_wash_details"> | number
    is_cancel?: BoolWithAggregatesFilter<"retrun_wash_details"> | boolean
    is_checklist?: BoolWithAggregatesFilter<"retrun_wash_details"> | boolean
    request_name?: StringWithAggregatesFilter<"retrun_wash_details"> | string
    description?: StringWithAggregatesFilter<"retrun_wash_details"> | string
    status?: BoolWithAggregatesFilter<"retrun_wash_details"> | boolean
    create_at?: DateTimeWithAggregatesFilter<"retrun_wash_details"> | Date | string
    update_at?: DateTimeWithAggregatesFilter<"retrun_wash_details"> | Date | string
  }

  export type userCreateInput = {
    name: string
    email: string
    permission_id: number
    email_verified_at?: Date | string | null
    password: string
    two_factor_secret?: string | null
    two_factor_recovery_codes?: string | null
    two_factor_confirmed_at?: Date | string | null
    is_two_factor_enabled?: boolean
    remember_token?: string | null
    create_at?: Date | string
    update_at?: Date | string
  }

  export type userUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    permission_id: number
    email_verified_at?: Date | string | null
    password: string
    two_factor_secret?: string | null
    two_factor_recovery_codes?: string | null
    two_factor_confirmed_at?: Date | string | null
    is_two_factor_enabled?: boolean
    remember_token?: string | null
    create_at?: Date | string
    update_at?: Date | string
  }

  export type userUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission_id?: IntFieldUpdateOperationsInput | number
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission_id?: IntFieldUpdateOperationsInput | number
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateManyInput = {
    id?: number
    name: string
    email: string
    permission_id: number
    email_verified_at?: Date | string | null
    password: string
    two_factor_secret?: string | null
    two_factor_recovery_codes?: string | null
    two_factor_confirmed_at?: Date | string | null
    is_two_factor_enabled?: boolean
    remember_token?: string | null
    create_at?: Date | string
    update_at?: Date | string
  }

  export type userUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission_id?: IntFieldUpdateOperationsInput | number
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission_id?: IntFieldUpdateOperationsInput | number
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    two_factor_secret?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_recovery_codes?: NullableStringFieldUpdateOperationsInput | string | null
    two_factor_confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_tokenCreateInput = {
    email: string
    token: string
    expires: Date | string
    create_at?: Date | string
    update_at?: Date | string
  }

  export type verification_tokenUncheckedCreateInput = {
    id?: number
    email: string
    token: string
    expires: Date | string
    create_at?: Date | string
    update_at?: Date | string
  }

  export type verification_tokenUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_tokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_tokenCreateManyInput = {
    id?: number
    email: string
    token: string
    expires: Date | string
    create_at?: Date | string
    update_at?: Date | string
  }

  export type verification_tokenUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type verification_tokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_reset_tokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    create_at?: Date | string
    update_at?: Date | string
  }

  export type password_reset_tokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    create_at?: Date | string
    update_at?: Date | string
  }

  export type password_reset_tokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_reset_tokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_reset_tokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    create_at?: Date | string
    update_at?: Date | string
  }

  export type password_reset_tokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_reset_tokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateInput = {
    user_id: number
    title: string
    message: string
    type: string
    is_read?: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type notificationsUncheckedCreateInput = {
    id?: number
    user_id: number
    title: string
    message: string
    type: string
    is_read?: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type notificationsUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateManyInput = {
    id?: number
    user_id: number
    title: string
    message: string
    type: string
    is_read?: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type notificationsUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sale_officesCreateInput = {
    site_code: string
    site_office_name_th: string
    site_office_name_en: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type sale_officesUncheckedCreateInput = {
    id?: number
    site_code: string
    site_office_name_th: string
    site_office_name_en: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type sale_officesUpdateInput = {
    site_code?: StringFieldUpdateOperationsInput | string
    site_office_name_th?: StringFieldUpdateOperationsInput | string
    site_office_name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sale_officesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_code?: StringFieldUpdateOperationsInput | string
    site_office_name_th?: StringFieldUpdateOperationsInput | string
    site_office_name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sale_officesCreateManyInput = {
    id?: number
    site_code: string
    site_office_name_th: string
    site_office_name_en: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type sale_officesUpdateManyMutationInput = {
    site_code?: StringFieldUpdateOperationsInput | string
    site_office_name_th?: StringFieldUpdateOperationsInput | string
    site_office_name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sale_officesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    site_code?: StringFieldUpdateOperationsInput | string
    site_office_name_th?: StringFieldUpdateOperationsInput | string
    site_office_name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentsCreateInput = {
    department_code: string
    sale_office_id: number
    description: string
    group_code: string
    ship_id: number
    is_default: boolean
    name_th: string
    name_en: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type departmentsUncheckedCreateInput = {
    id?: number
    department_code: string
    sale_office_id: number
    description: string
    group_code: string
    ship_id: number
    is_default: boolean
    name_th: string
    name_en: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type departmentsUpdateInput = {
    department_code?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    group_code?: StringFieldUpdateOperationsInput | string
    ship_id?: IntFieldUpdateOperationsInput | number
    is_default?: BoolFieldUpdateOperationsInput | boolean
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    department_code?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    group_code?: StringFieldUpdateOperationsInput | string
    ship_id?: IntFieldUpdateOperationsInput | number
    is_default?: BoolFieldUpdateOperationsInput | boolean
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentsCreateManyInput = {
    id?: number
    department_code: string
    sale_office_id: number
    description: string
    group_code: string
    ship_id: number
    is_default: boolean
    name_th: string
    name_en: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type departmentsUpdateManyMutationInput = {
    department_code?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    group_code?: StringFieldUpdateOperationsInput | string
    ship_id?: IntFieldUpdateOperationsInput | number
    is_default?: BoolFieldUpdateOperationsInput | boolean
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    department_code?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    group_code?: StringFieldUpdateOperationsInput | string
    ship_id?: IntFieldUpdateOperationsInput | number
    is_default?: BoolFieldUpdateOperationsInput | boolean
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type factory_sale_officeCreateInput = {
    sale_office_id: number
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type factory_sale_officeUncheckedCreateInput = {
    id?: number
    sale_office_id: number
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type factory_sale_officeUpdateInput = {
    sale_office_id?: IntFieldUpdateOperationsInput | number
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type factory_sale_officeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type factory_sale_officeCreateManyInput = {
    id?: number
    sale_office_id: number
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type factory_sale_officeUpdateManyMutationInput = {
    sale_office_id?: IntFieldUpdateOperationsInput | number
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type factory_sale_officeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type factoriesCreateInput = {
    price: number
    address: string
    post: string
    tel: string
    tax_id: number
    name_th: string
    name_en: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type factoriesUncheckedCreateInput = {
    id?: number
    price: number
    address: string
    post: string
    tel: string
    tax_id: number
    name_th: string
    name_en: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type factoriesUpdateInput = {
    price?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    tax_id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type factoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    tax_id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type factoriesCreateManyInput = {
    id?: number
    price: number
    address: string
    post: string
    tel: string
    tax_id: number
    name_th: string
    name_en: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type factoriesUpdateManyMutationInput = {
    price?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    tax_id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type factoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    post?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    tax_id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type machinesCreateInput = {
    facetory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type machinesUncheckedCreateInput = {
    id?: number
    facetory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type machinesUpdateInput = {
    facetory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type machinesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    facetory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type machinesCreateManyInput = {
    id?: number
    facetory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type machinesUpdateManyMutationInput = {
    facetory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type machinesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    facetory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactCreateInput = {
    sale_office_id: number
    factory_sale_office_id: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type contactUncheckedCreateInput = {
    id?: number
    sale_office_id: number
    factory_sale_office_id: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type contactUpdateInput = {
    sale_office_id?: IntFieldUpdateOperationsInput | number
    factory_sale_office_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    factory_sale_office_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactCreateManyInput = {
    id?: number
    sale_office_id: number
    factory_sale_office_id: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type contactUpdateManyMutationInput = {
    sale_office_id?: IntFieldUpdateOperationsInput | number
    factory_sale_office_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    factory_sale_office_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialsCreateInput = {
    material_code: number
    material_name_th: string
    material_name_en: string
    long_meterial_name: string
    material_type_id: number
    material_unit_id: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type materialsUncheckedCreateInput = {
    id?: number
    material_code: number
    material_name_th: string
    material_name_en: string
    long_meterial_name: string
    material_type_id: number
    material_unit_id: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type materialsUpdateInput = {
    material_code?: IntFieldUpdateOperationsInput | number
    material_name_th?: StringFieldUpdateOperationsInput | string
    material_name_en?: StringFieldUpdateOperationsInput | string
    long_meterial_name?: StringFieldUpdateOperationsInput | string
    material_type_id?: IntFieldUpdateOperationsInput | number
    material_unit_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    material_code?: IntFieldUpdateOperationsInput | number
    material_name_th?: StringFieldUpdateOperationsInput | string
    material_name_en?: StringFieldUpdateOperationsInput | string
    long_meterial_name?: StringFieldUpdateOperationsInput | string
    material_type_id?: IntFieldUpdateOperationsInput | number
    material_unit_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialsCreateManyInput = {
    id?: number
    material_code: number
    material_name_th: string
    material_name_en: string
    long_meterial_name: string
    material_type_id: number
    material_unit_id: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type materialsUpdateManyMutationInput = {
    material_code?: IntFieldUpdateOperationsInput | number
    material_name_th?: StringFieldUpdateOperationsInput | string
    material_name_en?: StringFieldUpdateOperationsInput | string
    long_meterial_name?: StringFieldUpdateOperationsInput | string
    material_type_id?: IntFieldUpdateOperationsInput | number
    material_unit_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type materialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    material_code?: IntFieldUpdateOperationsInput | number
    material_name_th?: StringFieldUpdateOperationsInput | string
    material_name_en?: StringFieldUpdateOperationsInput | string
    long_meterial_name?: StringFieldUpdateOperationsInput | string
    material_type_id?: IntFieldUpdateOperationsInput | number
    material_unit_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type material_typesCreateInput = {
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type material_typesUncheckedCreateInput = {
    id?: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type material_typesUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type material_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type material_typesCreateManyInput = {
    id?: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type material_typesUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type material_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_units_meauresCreateInput = {
    material_id: number
    packing: string
    qty: number
    countable_unit_id: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type item_units_meauresUncheckedCreateInput = {
    id?: number
    material_id: number
    packing: string
    qty: number
    countable_unit_id: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type item_units_meauresUpdateInput = {
    material_id?: IntFieldUpdateOperationsInput | number
    packing?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    countable_unit_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_units_meauresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    material_id?: IntFieldUpdateOperationsInput | number
    packing?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    countable_unit_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_units_meauresCreateManyInput = {
    id?: number
    material_id: number
    packing: string
    qty: number
    countable_unit_id: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type item_units_meauresUpdateManyMutationInput = {
    material_id?: IntFieldUpdateOperationsInput | number
    packing?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    countable_unit_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_units_meauresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    material_id?: IntFieldUpdateOperationsInput | number
    packing?: StringFieldUpdateOperationsInput | string
    qty?: FloatFieldUpdateOperationsInput | number
    countable_unit_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsCreateInput = {
    material_id: number
    saleoffice_id: number
    department_id: number
    item_category_id: number
    stock_location_id: number
    name_th?: string | null
    name_en?: string | null
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type itemsUncheckedCreateInput = {
    id?: number
    material_id: number
    saleoffice_id: number
    department_id: number
    item_category_id: number
    stock_location_id: number
    name_th?: string | null
    name_en?: string | null
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type itemsUpdateInput = {
    material_id?: IntFieldUpdateOperationsInput | number
    saleoffice_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_category_id?: IntFieldUpdateOperationsInput | number
    stock_location_id?: IntFieldUpdateOperationsInput | number
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    material_id?: IntFieldUpdateOperationsInput | number
    saleoffice_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_category_id?: IntFieldUpdateOperationsInput | number
    stock_location_id?: IntFieldUpdateOperationsInput | number
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsCreateManyInput = {
    id?: number
    material_id: number
    saleoffice_id: number
    department_id: number
    item_category_id: number
    stock_location_id: number
    name_th?: string | null
    name_en?: string | null
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type itemsUpdateManyMutationInput = {
    material_id?: IntFieldUpdateOperationsInput | number
    saleoffice_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_category_id?: IntFieldUpdateOperationsInput | number
    stock_location_id?: IntFieldUpdateOperationsInput | number
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type itemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    material_id?: IntFieldUpdateOperationsInput | number
    saleoffice_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_category_id?: IntFieldUpdateOperationsInput | number
    stock_location_id?: IntFieldUpdateOperationsInput | number
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type items_detailsCreateInput = {
    item_id: number
    sale_office_id: number
    qr_code_number: string
    product_lot_number: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type items_detailsUncheckedCreateInput = {
    id?: number
    item_id: number
    sale_office_id: number
    qr_code_number: string
    product_lot_number: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type items_detailsUpdateInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    qr_code_number?: StringFieldUpdateOperationsInput | string
    product_lot_number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type items_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    qr_code_number?: StringFieldUpdateOperationsInput | string
    product_lot_number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type items_detailsCreateManyInput = {
    id?: number
    item_id: number
    sale_office_id: number
    qr_code_number: string
    product_lot_number: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type items_detailsUpdateManyMutationInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    qr_code_number?: StringFieldUpdateOperationsInput | string
    product_lot_number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type items_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    qr_code_number?: StringFieldUpdateOperationsInput | string
    product_lot_number?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_categoriesCreateInput = {
    type_id: number
    sale_office_id: number
    department_id: number
    stock_location_id: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type item_categoriesUncheckedCreateInput = {
    id?: number
    type_id: number
    sale_office_id: number
    department_id: number
    stock_location_id: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type item_categoriesUpdateInput = {
    type_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    stock_location_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    stock_location_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_categoriesCreateManyInput = {
    id?: number
    type_id: number
    sale_office_id: number
    department_id: number
    stock_location_id: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type item_categoriesUpdateManyMutationInput = {
    type_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    stock_location_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    stock_location_id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type typesCreateInput = {
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type typesUncheckedCreateInput = {
    id?: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type typesUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type typesCreateManyInput = {
    id?: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type typesUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_pricesCreateInput = {
    item_id: number
    price: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type item_pricesUncheckedCreateInput = {
    id?: number
    item_id: number
    price: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type item_pricesUpdateInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_pricesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_pricesCreateManyInput = {
    id?: number
    item_id: number
    price: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type item_pricesUpdateManyMutationInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type item_pricesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dirtiesCreateInput = {
    dirty_doc_no: string
    dirty_doc_date?: Date | string | null
    sale_office_id?: number | null
    department_id?: number | null
    factory_id?: number | null
    user_id?: number | null
    signature?: string | null
    sign_factory?: string | null
    sign_factory_time?: Date | string | null
    sign_NH?: string | null
    sign_NH_time?: Date | string | null
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type dirtiesUncheckedCreateInput = {
    id?: number
    dirty_doc_no: string
    dirty_doc_date?: Date | string | null
    sale_office_id?: number | null
    department_id?: number | null
    factory_id?: number | null
    user_id?: number | null
    signature?: string | null
    sign_factory?: string | null
    sign_factory_time?: Date | string | null
    sign_NH?: string | null
    sign_NH_time?: Date | string | null
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type dirtiesUpdateInput = {
    dirty_doc_no?: StringFieldUpdateOperationsInput | string
    dirty_doc_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_office_id?: NullableIntFieldUpdateOperationsInput | number | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    factory_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign_NH?: NullableStringFieldUpdateOperationsInput | string | null
    sign_NH_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dirtiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dirty_doc_no?: StringFieldUpdateOperationsInput | string
    dirty_doc_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_office_id?: NullableIntFieldUpdateOperationsInput | number | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    factory_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign_NH?: NullableStringFieldUpdateOperationsInput | string | null
    sign_NH_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dirtiesCreateManyInput = {
    id?: number
    dirty_doc_no: string
    dirty_doc_date?: Date | string | null
    sale_office_id?: number | null
    department_id?: number | null
    factory_id?: number | null
    user_id?: number | null
    signature?: string | null
    sign_factory?: string | null
    sign_factory_time?: Date | string | null
    sign_NH?: string | null
    sign_NH_time?: Date | string | null
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type dirtiesUpdateManyMutationInput = {
    dirty_doc_no?: StringFieldUpdateOperationsInput | string
    dirty_doc_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_office_id?: NullableIntFieldUpdateOperationsInput | number | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    factory_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign_NH?: NullableStringFieldUpdateOperationsInput | string | null
    sign_NH_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dirtiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dirty_doc_no?: StringFieldUpdateOperationsInput | string
    dirty_doc_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sale_office_id?: NullableIntFieldUpdateOperationsInput | number | null
    department_id?: NullableIntFieldUpdateOperationsInput | number | null
    factory_id?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign_NH?: NullableStringFieldUpdateOperationsInput | string | null
    sign_NH_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dirty_detailsCreateInput = {
    dirty_id: number
    department_id: number
    item_id: number
    unit_id: number
    user_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type dirty_detailsUncheckedCreateInput = {
    id?: number
    dirty_id: number
    department_id: number
    item_id: number
    unit_id: number
    user_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type dirty_detailsUpdateInput = {
    dirty_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dirty_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dirty_detailsCreateManyInput = {
    id?: number
    dirty_id: number
    department_id: number
    item_id: number
    unit_id: number
    user_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type dirty_detailsUpdateManyMutationInput = {
    dirty_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dirty_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_group_typesCreateInput = {
    level: string
    group: string
    type: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type customer_group_typesUncheckedCreateInput = {
    id?: number
    level: string
    group: string
    type: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type customer_group_typesUpdateInput = {
    level?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_group_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_group_typesCreateManyInput = {
    id?: number
    level: string
    group: string
    type: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type customer_group_typesUpdateManyMutationInput = {
    level?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_group_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_groupsCreateInput = {
    sale_office_id: number
    customer_group_type_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type customer_groupsUncheckedCreateInput = {
    id?: number
    sale_office_id: number
    customer_group_type_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type customer_groupsUpdateInput = {
    sale_office_id?: IntFieldUpdateOperationsInput | number
    customer_group_type_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_groupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    customer_group_type_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_groupsCreateManyInput = {
    id?: number
    sale_office_id: number
    customer_group_type_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type customer_groupsUpdateManyMutationInput = {
    sale_office_id?: IntFieldUpdateOperationsInput | number
    customer_group_type_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customer_groupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    customer_group_type_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stock_locationsCreateInput = {
    department_id: number
    sale_office_id: number
    site_short_code: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type stock_locationsUncheckedCreateInput = {
    id?: number
    department_id: number
    sale_office_id: number
    site_short_code: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type stock_locationsUpdateInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    site_short_code?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stock_locationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    site_short_code?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stock_locationsCreateManyInput = {
    id?: number
    department_id: number
    sale_office_id: number
    site_short_code: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type stock_locationsUpdateManyMutationInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    site_short_code?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type stock_locationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    site_short_code?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shelfcountsCreateInput = {
    sale_office_id: number
    doc_no: number
    doc_date: Date | string
    shelfcount_doc_no: string
    department_id: number
    is_request: boolean
    delivery_time: Date | string
    sc_time: Date | string
    is_mobile: boolean
    complete_user: string
    complete_date: Date | string
    cancel_user_id: number
    cancel_remark: string
    site_short_code: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type shelfcountsUncheckedCreateInput = {
    id?: number
    sale_office_id: number
    doc_no: number
    doc_date: Date | string
    shelfcount_doc_no: string
    department_id: number
    is_request: boolean
    delivery_time: Date | string
    sc_time: Date | string
    is_mobile: boolean
    complete_user: string
    complete_date: Date | string
    cancel_user_id: number
    cancel_remark: string
    site_short_code: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type shelfcountsUpdateInput = {
    sale_office_id?: IntFieldUpdateOperationsInput | number
    doc_no?: IntFieldUpdateOperationsInput | number
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    shelfcount_doc_no?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_request?: BoolFieldUpdateOperationsInput | boolean
    delivery_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sc_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    complete_user?: StringFieldUpdateOperationsInput | string
    complete_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_user_id?: IntFieldUpdateOperationsInput | number
    cancel_remark?: StringFieldUpdateOperationsInput | string
    site_short_code?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shelfcountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    doc_no?: IntFieldUpdateOperationsInput | number
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    shelfcount_doc_no?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_request?: BoolFieldUpdateOperationsInput | boolean
    delivery_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sc_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    complete_user?: StringFieldUpdateOperationsInput | string
    complete_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_user_id?: IntFieldUpdateOperationsInput | number
    cancel_remark?: StringFieldUpdateOperationsInput | string
    site_short_code?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shelfcountsCreateManyInput = {
    id?: number
    sale_office_id: number
    doc_no: number
    doc_date: Date | string
    shelfcount_doc_no: string
    department_id: number
    is_request: boolean
    delivery_time: Date | string
    sc_time: Date | string
    is_mobile: boolean
    complete_user: string
    complete_date: Date | string
    cancel_user_id: number
    cancel_remark: string
    site_short_code: number
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type shelfcountsUpdateManyMutationInput = {
    sale_office_id?: IntFieldUpdateOperationsInput | number
    doc_no?: IntFieldUpdateOperationsInput | number
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    shelfcount_doc_no?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_request?: BoolFieldUpdateOperationsInput | boolean
    delivery_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sc_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    complete_user?: StringFieldUpdateOperationsInput | string
    complete_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_user_id?: IntFieldUpdateOperationsInput | number
    cancel_remark?: StringFieldUpdateOperationsInput | string
    site_short_code?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shelfcountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sale_office_id?: IntFieldUpdateOperationsInput | number
    doc_no?: IntFieldUpdateOperationsInput | number
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    shelfcount_doc_no?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    is_request?: BoolFieldUpdateOperationsInput | boolean
    delivery_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sc_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_mobile?: BoolFieldUpdateOperationsInput | boolean
    complete_user?: StringFieldUpdateOperationsInput | string
    complete_date?: DateTimeFieldUpdateOperationsInput | Date | string
    cancel_user_id?: IntFieldUpdateOperationsInput | number
    cancel_remark?: StringFieldUpdateOperationsInput | string
    site_short_code?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shelfcount_detailsCreateInput = {
    shelfcount_id: number
    item_id: number
    unit_id: number
    par_qty: number
    cc_qty: number
    total_qty: number
    over_par: number
    short: number
    over: number
    weight: number
    price: number
    category_price: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type shelfcount_detailsUncheckedCreateInput = {
    id?: number
    shelfcount_id: number
    item_id: number
    unit_id: number
    par_qty: number
    cc_qty: number
    total_qty: number
    over_par: number
    short: number
    over: number
    weight: number
    price: number
    category_price: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type shelfcount_detailsUpdateInput = {
    shelfcount_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    par_qty?: FloatFieldUpdateOperationsInput | number
    cc_qty?: FloatFieldUpdateOperationsInput | number
    total_qty?: FloatFieldUpdateOperationsInput | number
    over_par?: FloatFieldUpdateOperationsInput | number
    short?: FloatFieldUpdateOperationsInput | number
    over?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    category_price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shelfcount_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shelfcount_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    par_qty?: FloatFieldUpdateOperationsInput | number
    cc_qty?: FloatFieldUpdateOperationsInput | number
    total_qty?: FloatFieldUpdateOperationsInput | number
    over_par?: FloatFieldUpdateOperationsInput | number
    short?: FloatFieldUpdateOperationsInput | number
    over?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    category_price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shelfcount_detailsCreateManyInput = {
    id?: number
    shelfcount_id: number
    item_id: number
    unit_id: number
    par_qty: number
    cc_qty: number
    total_qty: number
    over_par: number
    short: number
    over: number
    weight: number
    price: number
    category_price: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type shelfcount_detailsUpdateManyMutationInput = {
    shelfcount_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    par_qty?: FloatFieldUpdateOperationsInput | number
    cc_qty?: FloatFieldUpdateOperationsInput | number
    total_qty?: FloatFieldUpdateOperationsInput | number
    over_par?: FloatFieldUpdateOperationsInput | number
    short?: FloatFieldUpdateOperationsInput | number
    over?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    category_price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shelfcount_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shelfcount_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    par_qty?: FloatFieldUpdateOperationsInput | number
    cc_qty?: FloatFieldUpdateOperationsInput | number
    total_qty?: FloatFieldUpdateOperationsInput | number
    over_par?: FloatFieldUpdateOperationsInput | number
    short?: FloatFieldUpdateOperationsInput | number
    over?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    category_price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type damagesCreateInput = {
    doc_no: string
    doc_date: Date | string
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    total: number
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type damagesUncheckedCreateInput = {
    id?: number
    doc_no: string
    doc_date: Date | string
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    total: number
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type damagesUpdateInput = {
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type damagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type damagesCreateManyInput = {
    id?: number
    doc_no: string
    doc_date: Date | string
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    total: number
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type damagesUpdateManyMutationInput = {
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type damagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type damage_detailsCreateInput = {
    damage_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type damage_detailsUncheckedCreateInput = {
    id?: number
    damage_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type damage_detailsUpdateInput = {
    damage_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type damage_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    damage_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type damage_detailsCreateManyInput = {
    id?: number
    damage_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type damage_detailsUpdateManyMutationInput = {
    damage_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type damage_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    damage_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shipsCreateInput = {
    item_id: number
    site_short_code: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type shipsUncheckedCreateInput = {
    id?: number
    item_id: number
    site_short_code: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type shipsUpdateInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    site_short_code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shipsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    site_short_code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shipsCreateManyInput = {
    id?: number
    item_id: number
    site_short_code: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type shipsUpdateManyMutationInput = {
    item_id?: IntFieldUpdateOperationsInput | number
    site_short_code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shipsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    site_short_code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type new_linensCreateInput = {
    doc_no: string
    doc_date: Date | string
    ref_doc_no?: string | null
    sale_office_id: number
    department_id: number
    total: number
    is_recive?: boolean | null
    receive_date?: Date | string | null
    receive_detail?: string | null
    is_process?: boolean | null
    sign_factory?: string | null
    sign_NH?: string | null
    sign_factory_time?: Date | string | null
    sign_NH_time?: Date | string | null
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type new_linensUncheckedCreateInput = {
    id?: number
    doc_no: string
    doc_date: Date | string
    ref_doc_no?: string | null
    sale_office_id: number
    department_id: number
    total: number
    is_recive?: boolean | null
    receive_date?: Date | string | null
    receive_detail?: string | null
    is_process?: boolean | null
    sign_factory?: string | null
    sign_NH?: string | null
    sign_factory_time?: Date | string | null
    sign_NH_time?: Date | string | null
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type new_linensUpdateInput = {
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: NullableStringFieldUpdateOperationsInput | string | null
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    is_recive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receive_detail?: NullableStringFieldUpdateOperationsInput | string | null
    is_process?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sign_factory?: NullableStringFieldUpdateOperationsInput | string | null
    sign_NH?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign_NH_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type new_linensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: NullableStringFieldUpdateOperationsInput | string | null
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    is_recive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receive_detail?: NullableStringFieldUpdateOperationsInput | string | null
    is_process?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sign_factory?: NullableStringFieldUpdateOperationsInput | string | null
    sign_NH?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign_NH_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type new_linensCreateManyInput = {
    id?: number
    doc_no: string
    doc_date: Date | string
    ref_doc_no?: string | null
    sale_office_id: number
    department_id: number
    total: number
    is_recive?: boolean | null
    receive_date?: Date | string | null
    receive_detail?: string | null
    is_process?: boolean | null
    sign_factory?: string | null
    sign_NH?: string | null
    sign_factory_time?: Date | string | null
    sign_NH_time?: Date | string | null
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type new_linensUpdateManyMutationInput = {
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: NullableStringFieldUpdateOperationsInput | string | null
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    is_recive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receive_detail?: NullableStringFieldUpdateOperationsInput | string | null
    is_process?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sign_factory?: NullableStringFieldUpdateOperationsInput | string | null
    sign_NH?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign_NH_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type new_linensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: NullableStringFieldUpdateOperationsInput | string | null
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    is_recive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receive_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receive_detail?: NullableStringFieldUpdateOperationsInput | string | null
    is_process?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sign_factory?: NullableStringFieldUpdateOperationsInput | string | null
    sign_NH?: NullableStringFieldUpdateOperationsInput | string | null
    sign_factory_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign_NH_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type new_linen_detailsCreateInput = {
    new_linen_id: number
    department_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    description?: string | null
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type new_linen_detailsUncheckedCreateInput = {
    id?: number
    new_linen_id: number
    department_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    description?: string | null
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type new_linen_detailsUpdateInput = {
    new_linen_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type new_linen_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    new_linen_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type new_linen_detailsCreateManyInput = {
    id?: number
    new_linen_id: number
    department_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    description?: string | null
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type new_linen_detailsUpdateManyMutationInput = {
    new_linen_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type new_linen_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    new_linen_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repair_washsCreateInput = {
    doc_no: string
    doc_date: Date | string
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    clean_id: number
    total: number
    is_recive: boolean
    receive_date: Date | string
    receive_detail: string
    is_process: boolean
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type repair_washsUncheckedCreateInput = {
    id?: number
    doc_no: string
    doc_date: Date | string
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    clean_id: number
    total: number
    is_recive: boolean
    receive_date: Date | string
    receive_detail: string
    is_process: boolean
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type repair_washsUpdateInput = {
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    clean_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    is_recive?: BoolFieldUpdateOperationsInput | boolean
    receive_date?: DateTimeFieldUpdateOperationsInput | Date | string
    receive_detail?: StringFieldUpdateOperationsInput | string
    is_process?: BoolFieldUpdateOperationsInput | boolean
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repair_washsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    clean_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    is_recive?: BoolFieldUpdateOperationsInput | boolean
    receive_date?: DateTimeFieldUpdateOperationsInput | Date | string
    receive_detail?: StringFieldUpdateOperationsInput | string
    is_process?: BoolFieldUpdateOperationsInput | boolean
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repair_washsCreateManyInput = {
    id?: number
    doc_no: string
    doc_date: Date | string
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    clean_id: number
    total: number
    is_recive: boolean
    receive_date: Date | string
    receive_detail: string
    is_process: boolean
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type repair_washsUpdateManyMutationInput = {
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    clean_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    is_recive?: BoolFieldUpdateOperationsInput | boolean
    receive_date?: DateTimeFieldUpdateOperationsInput | Date | string
    receive_detail?: StringFieldUpdateOperationsInput | string
    is_process?: BoolFieldUpdateOperationsInput | boolean
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repair_washsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    clean_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    is_recive?: BoolFieldUpdateOperationsInput | boolean
    receive_date?: DateTimeFieldUpdateOperationsInput | Date | string
    receive_detail?: StringFieldUpdateOperationsInput | string
    is_process?: BoolFieldUpdateOperationsInput | boolean
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repair_wash_detailsCreateInput = {
    repair_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type repair_wash_detailsUncheckedCreateInput = {
    id?: number
    repair_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type repair_wash_detailsUpdateInput = {
    repair_wash_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repair_wash_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    repair_wash_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repair_wash_detailsCreateManyInput = {
    id?: number
    repair_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    receive_qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type repair_wash_detailsUpdateManyMutationInput = {
    repair_wash_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type repair_wash_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    repair_wash_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    receive_qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cleansCreateInput = {
    clean_doc_no: string
    doc_date: Date | string
    sale_office_id: number
    department_id: number
    dirty_id: number
    user_id: number
    signature: string
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type cleansUncheckedCreateInput = {
    id?: number
    clean_doc_no: string
    doc_date: Date | string
    sale_office_id: number
    department_id: number
    dirty_id: number
    user_id: number
    signature: string
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type cleansUpdateInput = {
    clean_doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    signature?: StringFieldUpdateOperationsInput | string
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cleansUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clean_doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    signature?: StringFieldUpdateOperationsInput | string
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cleansCreateManyInput = {
    id?: number
    clean_doc_no: string
    doc_date: Date | string
    sale_office_id: number
    department_id: number
    dirty_id: number
    user_id: number
    signature: string
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type cleansUpdateManyMutationInput = {
    clean_doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    signature?: StringFieldUpdateOperationsInput | string
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cleansUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clean_doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    signature?: StringFieldUpdateOperationsInput | string
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clean_detailsCreateInput = {
    clean_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    request_name: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type clean_detailsUncheckedCreateInput = {
    id?: number
    clean_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    request_name: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type clean_detailsUpdateInput = {
    clean_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    request_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clean_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clean_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    request_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clean_detailsCreateManyInput = {
    id?: number
    clean_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    request_name: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type clean_detailsUpdateManyMutationInput = {
    clean_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    request_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clean_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clean_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    request_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type return_washsCreateInput = {
    doc_no: string
    doc_date: Date | string
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    total: number
    dirty_id: number
    user_id: number
    signature: string
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type return_washsUncheckedCreateInput = {
    id?: number
    doc_no: string
    doc_date: Date | string
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    total: number
    dirty_id: number
    user_id: number
    signature: string
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type return_washsUpdateInput = {
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    signature?: StringFieldUpdateOperationsInput | string
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type return_washsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    signature?: StringFieldUpdateOperationsInput | string
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type return_washsCreateManyInput = {
    id?: number
    doc_no: string
    doc_date: Date | string
    ref_doc_no: string
    sale_office_id: number
    department_id: number
    total: number
    dirty_id: number
    user_id: number
    signature: string
    sign_factory: string
    sign_NH: string
    sign_factory_time: Date | string
    sign_NH_time: Date | string
    factory_id: number
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type return_washsUpdateManyMutationInput = {
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    signature?: StringFieldUpdateOperationsInput | string
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type return_washsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_no?: StringFieldUpdateOperationsInput | string
    doc_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ref_doc_no?: StringFieldUpdateOperationsInput | string
    sale_office_id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    dirty_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    signature?: StringFieldUpdateOperationsInput | string
    sign_factory?: StringFieldUpdateOperationsInput | string
    sign_NH?: StringFieldUpdateOperationsInput | string
    sign_factory_time?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_NH_time?: DateTimeFieldUpdateOperationsInput | Date | string
    factory_id?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type retrun_wash_detailsCreateInput = {
    return_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    request_name: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type retrun_wash_detailsUncheckedCreateInput = {
    id?: number
    return_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    request_name: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type retrun_wash_detailsUpdateInput = {
    return_wash_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    request_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type retrun_wash_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    return_wash_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    request_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type retrun_wash_detailsCreateManyInput = {
    id?: number
    return_wash_id: number
    item_id: number
    unit_id: number
    qty: number
    weight: number
    is_cancel: boolean
    is_checklist: boolean
    request_name: string
    description: string
    status: boolean
    create_at?: Date | string
    update_at?: Date | string
  }

  export type retrun_wash_detailsUpdateManyMutationInput = {
    return_wash_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    request_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type retrun_wash_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    return_wash_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    unit_id?: IntFieldUpdateOperationsInput | number
    qty?: FloatFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    is_cancel?: BoolFieldUpdateOperationsInput | boolean
    is_checklist?: BoolFieldUpdateOperationsInput | boolean
    request_name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    create_at?: DateTimeFieldUpdateOperationsInput | Date | string
    update_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    permission_id?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrder
    two_factor_recovery_codes?: SortOrder
    two_factor_confirmed_at?: SortOrder
    is_two_factor_enabled?: SortOrder
    remember_token?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    permission_id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    permission_id?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrder
    two_factor_recovery_codes?: SortOrder
    two_factor_confirmed_at?: SortOrder
    is_two_factor_enabled?: SortOrder
    remember_token?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    permission_id?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    two_factor_secret?: SortOrder
    two_factor_recovery_codes?: SortOrder
    two_factor_confirmed_at?: SortOrder
    is_two_factor_enabled?: SortOrder
    remember_token?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    permission_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type verification_tokenOrderByRelevanceInput = {
    fields: verification_tokenOrderByRelevanceFieldEnum | verification_tokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type verification_tokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type verification_tokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type verification_tokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type verification_tokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type verification_tokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type verification_tokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type password_reset_tokenOrderByRelevanceInput = {
    fields: password_reset_tokenOrderByRelevanceFieldEnum | password_reset_tokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type password_reset_tokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type password_reset_tokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type password_reset_tokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type notificationsOrderByRelevanceInput = {
    fields: notificationsOrderByRelevanceFieldEnum | notificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type notificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type notificationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type sale_officesOrderByRelevanceInput = {
    fields: sale_officesOrderByRelevanceFieldEnum | sale_officesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sale_officesCountOrderByAggregateInput = {
    id?: SortOrder
    site_code?: SortOrder
    site_office_name_th?: SortOrder
    site_office_name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type sale_officesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sale_officesMaxOrderByAggregateInput = {
    id?: SortOrder
    site_code?: SortOrder
    site_office_name_th?: SortOrder
    site_office_name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type sale_officesMinOrderByAggregateInput = {
    id?: SortOrder
    site_code?: SortOrder
    site_office_name_th?: SortOrder
    site_office_name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type sale_officesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type departmentsOrderByRelevanceInput = {
    fields: departmentsOrderByRelevanceFieldEnum | departmentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type departmentsCountOrderByAggregateInput = {
    id?: SortOrder
    department_code?: SortOrder
    sale_office_id?: SortOrder
    description?: SortOrder
    group_code?: SortOrder
    ship_id?: SortOrder
    is_default?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type departmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    ship_id?: SortOrder
  }

  export type departmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    department_code?: SortOrder
    sale_office_id?: SortOrder
    description?: SortOrder
    group_code?: SortOrder
    ship_id?: SortOrder
    is_default?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type departmentsMinOrderByAggregateInput = {
    id?: SortOrder
    department_code?: SortOrder
    sale_office_id?: SortOrder
    description?: SortOrder
    group_code?: SortOrder
    ship_id?: SortOrder
    is_default?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type departmentsSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    ship_id?: SortOrder
  }

  export type factory_sale_officeCountOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type factory_sale_officeAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_id?: SortOrder
  }

  export type factory_sale_officeMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type factory_sale_officeMinOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type factory_sale_officeSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type factoriesOrderByRelevanceInput = {
    fields: factoriesOrderByRelevanceFieldEnum | factoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type factoriesCountOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    address?: SortOrder
    post?: SortOrder
    tel?: SortOrder
    tax_id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type factoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    tax_id?: SortOrder
  }

  export type factoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    address?: SortOrder
    post?: SortOrder
    tel?: SortOrder
    tax_id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type factoriesMinOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    address?: SortOrder
    post?: SortOrder
    tel?: SortOrder
    tax_id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type factoriesSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    tax_id?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type machinesCountOrderByAggregateInput = {
    id?: SortOrder
    facetory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type machinesAvgOrderByAggregateInput = {
    id?: SortOrder
    facetory_id?: SortOrder
  }

  export type machinesMaxOrderByAggregateInput = {
    id?: SortOrder
    facetory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type machinesMinOrderByAggregateInput = {
    id?: SortOrder
    facetory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type machinesSumOrderByAggregateInput = {
    id?: SortOrder
    facetory_id?: SortOrder
  }

  export type contactOrderByRelevanceInput = {
    fields: contactOrderByRelevanceFieldEnum | contactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type contactCountOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_sale_office_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type contactAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_sale_office_id?: SortOrder
  }

  export type contactMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_sale_office_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type contactMinOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_sale_office_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type contactSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    factory_sale_office_id?: SortOrder
  }

  export type materialsOrderByRelevanceInput = {
    fields: materialsOrderByRelevanceFieldEnum | materialsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type materialsCountOrderByAggregateInput = {
    id?: SortOrder
    material_code?: SortOrder
    material_name_th?: SortOrder
    material_name_en?: SortOrder
    long_meterial_name?: SortOrder
    material_type_id?: SortOrder
    material_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type materialsAvgOrderByAggregateInput = {
    id?: SortOrder
    material_code?: SortOrder
    material_type_id?: SortOrder
    material_unit_id?: SortOrder
  }

  export type materialsMaxOrderByAggregateInput = {
    id?: SortOrder
    material_code?: SortOrder
    material_name_th?: SortOrder
    material_name_en?: SortOrder
    long_meterial_name?: SortOrder
    material_type_id?: SortOrder
    material_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type materialsMinOrderByAggregateInput = {
    id?: SortOrder
    material_code?: SortOrder
    material_name_th?: SortOrder
    material_name_en?: SortOrder
    long_meterial_name?: SortOrder
    material_type_id?: SortOrder
    material_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type materialsSumOrderByAggregateInput = {
    id?: SortOrder
    material_code?: SortOrder
    material_type_id?: SortOrder
    material_unit_id?: SortOrder
  }

  export type material_typesOrderByRelevanceInput = {
    fields: material_typesOrderByRelevanceFieldEnum | material_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type material_typesCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type material_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type material_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type material_typesMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type material_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type item_units_meauresOrderByRelevanceInput = {
    fields: item_units_meauresOrderByRelevanceFieldEnum | item_units_meauresOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type item_units_meauresCountOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    packing?: SortOrder
    qty?: SortOrder
    countable_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type item_units_meauresAvgOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    qty?: SortOrder
  }

  export type item_units_meauresMaxOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    packing?: SortOrder
    qty?: SortOrder
    countable_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type item_units_meauresMinOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    packing?: SortOrder
    qty?: SortOrder
    countable_unit_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type item_units_meauresSumOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    qty?: SortOrder
  }

  export type itemsOrderByRelevanceInput = {
    fields: itemsOrderByRelevanceFieldEnum | itemsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type itemsCountOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    saleoffice_id?: SortOrder
    department_id?: SortOrder
    item_category_id?: SortOrder
    stock_location_id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type itemsAvgOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    saleoffice_id?: SortOrder
    department_id?: SortOrder
    item_category_id?: SortOrder
    stock_location_id?: SortOrder
  }

  export type itemsMaxOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    saleoffice_id?: SortOrder
    department_id?: SortOrder
    item_category_id?: SortOrder
    stock_location_id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type itemsMinOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    saleoffice_id?: SortOrder
    department_id?: SortOrder
    item_category_id?: SortOrder
    stock_location_id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type itemsSumOrderByAggregateInput = {
    id?: SortOrder
    material_id?: SortOrder
    saleoffice_id?: SortOrder
    department_id?: SortOrder
    item_category_id?: SortOrder
    stock_location_id?: SortOrder
  }

  export type items_detailsOrderByRelevanceInput = {
    fields: items_detailsOrderByRelevanceFieldEnum | items_detailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type items_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    sale_office_id?: SortOrder
    qr_code_number?: SortOrder
    product_lot_number?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type items_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    sale_office_id?: SortOrder
  }

  export type items_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    sale_office_id?: SortOrder
    qr_code_number?: SortOrder
    product_lot_number?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type items_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    sale_office_id?: SortOrder
    qr_code_number?: SortOrder
    product_lot_number?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type items_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    sale_office_id?: SortOrder
  }

  export type item_categoriesOrderByRelevanceInput = {
    fields: item_categoriesOrderByRelevanceFieldEnum | item_categoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type item_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    stock_location_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type item_categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    stock_location_id?: SortOrder
  }

  export type item_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    stock_location_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type item_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    stock_location_id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type item_categoriesSumOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    stock_location_id?: SortOrder
  }

  export type typesOrderByRelevanceInput = {
    fields: typesOrderByRelevanceFieldEnum | typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type typesCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type typesMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type typesMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type item_pricesOrderByRelevanceInput = {
    fields: item_pricesOrderByRelevanceFieldEnum | item_pricesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type item_pricesCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type item_pricesAvgOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    price?: SortOrder
  }

  export type item_pricesMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type item_pricesMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    price?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type item_pricesSumOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    price?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type dirtiesOrderByRelevanceInput = {
    fields: dirtiesOrderByRelevanceFieldEnum | dirtiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type dirtiesCountOrderByAggregateInput = {
    id?: SortOrder
    dirty_doc_no?: SortOrder
    dirty_doc_date?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    factory_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH?: SortOrder
    sign_NH_time?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type dirtiesAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    factory_id?: SortOrder
    user_id?: SortOrder
  }

  export type dirtiesMaxOrderByAggregateInput = {
    id?: SortOrder
    dirty_doc_no?: SortOrder
    dirty_doc_date?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    factory_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH?: SortOrder
    sign_NH_time?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type dirtiesMinOrderByAggregateInput = {
    id?: SortOrder
    dirty_doc_no?: SortOrder
    dirty_doc_date?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    factory_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH?: SortOrder
    sign_NH_time?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type dirtiesSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    factory_id?: SortOrder
    user_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type dirty_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    dirty_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type dirty_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    dirty_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
  }

  export type dirty_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    dirty_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type dirty_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    dirty_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type dirty_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    dirty_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    user_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
  }

  export type customer_group_typesOrderByRelevanceInput = {
    fields: customer_group_typesOrderByRelevanceFieldEnum | customer_group_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type customer_group_typesCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    group?: SortOrder
    type?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type customer_group_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type customer_group_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    group?: SortOrder
    type?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type customer_group_typesMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    group?: SortOrder
    type?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type customer_group_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type customer_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    customer_group_type_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type customer_groupsAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    customer_group_type_id?: SortOrder
  }

  export type customer_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    customer_group_type_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type customer_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    customer_group_type_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type customer_groupsSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    customer_group_type_id?: SortOrder
  }

  export type stock_locationsOrderByRelevanceInput = {
    fields: stock_locationsOrderByRelevanceFieldEnum | stock_locationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type stock_locationsCountOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    sale_office_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type stock_locationsAvgOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    sale_office_id?: SortOrder
    site_short_code?: SortOrder
  }

  export type stock_locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    sale_office_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type stock_locationsMinOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    sale_office_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type stock_locationsSumOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    sale_office_id?: SortOrder
    site_short_code?: SortOrder
  }

  export type shelfcountsOrderByRelevanceInput = {
    fields: shelfcountsOrderByRelevanceFieldEnum | shelfcountsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type shelfcountsCountOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    shelfcount_doc_no?: SortOrder
    department_id?: SortOrder
    is_request?: SortOrder
    delivery_time?: SortOrder
    sc_time?: SortOrder
    is_mobile?: SortOrder
    complete_user?: SortOrder
    complete_date?: SortOrder
    cancel_user_id?: SortOrder
    cancel_remark?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shelfcountsAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    doc_no?: SortOrder
    department_id?: SortOrder
    cancel_user_id?: SortOrder
    site_short_code?: SortOrder
  }

  export type shelfcountsMaxOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    shelfcount_doc_no?: SortOrder
    department_id?: SortOrder
    is_request?: SortOrder
    delivery_time?: SortOrder
    sc_time?: SortOrder
    is_mobile?: SortOrder
    complete_user?: SortOrder
    complete_date?: SortOrder
    cancel_user_id?: SortOrder
    cancel_remark?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shelfcountsMinOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    shelfcount_doc_no?: SortOrder
    department_id?: SortOrder
    is_request?: SortOrder
    delivery_time?: SortOrder
    sc_time?: SortOrder
    is_mobile?: SortOrder
    complete_user?: SortOrder
    complete_date?: SortOrder
    cancel_user_id?: SortOrder
    cancel_remark?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shelfcountsSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    doc_no?: SortOrder
    department_id?: SortOrder
    cancel_user_id?: SortOrder
    site_short_code?: SortOrder
  }

  export type shelfcount_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    shelfcount_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    par_qty?: SortOrder
    cc_qty?: SortOrder
    total_qty?: SortOrder
    over_par?: SortOrder
    short?: SortOrder
    over?: SortOrder
    weight?: SortOrder
    price?: SortOrder
    category_price?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shelfcount_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    shelfcount_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    par_qty?: SortOrder
    cc_qty?: SortOrder
    total_qty?: SortOrder
    over_par?: SortOrder
    short?: SortOrder
    over?: SortOrder
    weight?: SortOrder
    price?: SortOrder
    category_price?: SortOrder
  }

  export type shelfcount_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    shelfcount_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    par_qty?: SortOrder
    cc_qty?: SortOrder
    total_qty?: SortOrder
    over_par?: SortOrder
    short?: SortOrder
    over?: SortOrder
    weight?: SortOrder
    price?: SortOrder
    category_price?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shelfcount_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    shelfcount_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    par_qty?: SortOrder
    cc_qty?: SortOrder
    total_qty?: SortOrder
    over_par?: SortOrder
    short?: SortOrder
    over?: SortOrder
    weight?: SortOrder
    price?: SortOrder
    category_price?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shelfcount_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    shelfcount_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    par_qty?: SortOrder
    cc_qty?: SortOrder
    total_qty?: SortOrder
    over_par?: SortOrder
    short?: SortOrder
    over?: SortOrder
    weight?: SortOrder
    price?: SortOrder
    category_price?: SortOrder
  }

  export type damagesOrderByRelevanceInput = {
    fields: damagesOrderByRelevanceFieldEnum | damagesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type damagesCountOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type damagesAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    factory_id?: SortOrder
  }

  export type damagesMaxOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type damagesMinOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type damagesSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    factory_id?: SortOrder
  }

  export type damage_detailsOrderByRelevanceInput = {
    fields: damage_detailsOrderByRelevanceFieldEnum | damage_detailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type damage_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    damage_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type damage_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    damage_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
  }

  export type damage_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    damage_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type damage_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    damage_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type damage_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    damage_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
  }

  export type shipsOrderByRelevanceInput = {
    fields: shipsOrderByRelevanceFieldEnum | shipsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type shipsCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shipsAvgOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
  }

  export type shipsMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shipsMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    site_short_code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type shipsSumOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type new_linensOrderByRelevanceInput = {
    fields: new_linensOrderByRelevanceFieldEnum | new_linensOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type new_linensCountOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrder
    receive_date?: SortOrder
    receive_detail?: SortOrder
    is_process?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type new_linensAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    factory_id?: SortOrder
  }

  export type new_linensMaxOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrder
    receive_date?: SortOrder
    receive_detail?: SortOrder
    is_process?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type new_linensMinOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrder
    receive_date?: SortOrder
    receive_detail?: SortOrder
    is_process?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type new_linensSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    factory_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type new_linen_detailsOrderByRelevanceInput = {
    fields: new_linen_detailsOrderByRelevanceFieldEnum | new_linen_detailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type new_linen_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    new_linen_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type new_linen_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    new_linen_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
  }

  export type new_linen_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    new_linen_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type new_linen_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    new_linen_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type new_linen_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    new_linen_id?: SortOrder
    department_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
  }

  export type repair_washsOrderByRelevanceInput = {
    fields: repair_washsOrderByRelevanceFieldEnum | repair_washsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type repair_washsCountOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    clean_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrder
    receive_date?: SortOrder
    receive_detail?: SortOrder
    is_process?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type repair_washsAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    clean_id?: SortOrder
    total?: SortOrder
    factory_id?: SortOrder
  }

  export type repair_washsMaxOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    clean_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrder
    receive_date?: SortOrder
    receive_detail?: SortOrder
    is_process?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type repair_washsMinOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    clean_id?: SortOrder
    total?: SortOrder
    is_recive?: SortOrder
    receive_date?: SortOrder
    receive_detail?: SortOrder
    is_process?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type repair_washsSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    clean_id?: SortOrder
    total?: SortOrder
    factory_id?: SortOrder
  }

  export type repair_wash_detailsOrderByRelevanceInput = {
    fields: repair_wash_detailsOrderByRelevanceFieldEnum | repair_wash_detailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type repair_wash_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    repair_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type repair_wash_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    repair_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
  }

  export type repair_wash_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    repair_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type repair_wash_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    repair_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type repair_wash_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    repair_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    receive_qty?: SortOrder
    weight?: SortOrder
  }

  export type cleansOrderByRelevanceInput = {
    fields: cleansOrderByRelevanceFieldEnum | cleansOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cleansCountOrderByAggregateInput = {
    id?: SortOrder
    clean_doc_no?: SortOrder
    doc_date?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type cleansAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    factory_id?: SortOrder
  }

  export type cleansMaxOrderByAggregateInput = {
    id?: SortOrder
    clean_doc_no?: SortOrder
    doc_date?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type cleansMinOrderByAggregateInput = {
    id?: SortOrder
    clean_doc_no?: SortOrder
    doc_date?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type cleansSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    factory_id?: SortOrder
  }

  export type clean_detailsOrderByRelevanceInput = {
    fields: clean_detailsOrderByRelevanceFieldEnum | clean_detailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type clean_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    clean_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type clean_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    clean_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
  }

  export type clean_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    clean_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type clean_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    clean_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type clean_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    clean_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
  }

  export type return_washsOrderByRelevanceInput = {
    fields: return_washsOrderByRelevanceFieldEnum | return_washsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type return_washsCountOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type return_washsAvgOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    factory_id?: SortOrder
  }

  export type return_washsMaxOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type return_washsMinOrderByAggregateInput = {
    id?: SortOrder
    doc_no?: SortOrder
    doc_date?: SortOrder
    ref_doc_no?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    signature?: SortOrder
    sign_factory?: SortOrder
    sign_NH?: SortOrder
    sign_factory_time?: SortOrder
    sign_NH_time?: SortOrder
    factory_id?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type return_washsSumOrderByAggregateInput = {
    id?: SortOrder
    sale_office_id?: SortOrder
    department_id?: SortOrder
    total?: SortOrder
    dirty_id?: SortOrder
    user_id?: SortOrder
    factory_id?: SortOrder
  }

  export type retrun_wash_detailsOrderByRelevanceInput = {
    fields: retrun_wash_detailsOrderByRelevanceFieldEnum | retrun_wash_detailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type retrun_wash_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    return_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type retrun_wash_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
    return_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
  }

  export type retrun_wash_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    return_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type retrun_wash_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    return_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
    is_cancel?: SortOrder
    is_checklist?: SortOrder
    request_name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    create_at?: SortOrder
    update_at?: SortOrder
  }

  export type retrun_wash_detailsSumOrderByAggregateInput = {
    id?: SortOrder
    return_wash_id?: SortOrder
    item_id?: SortOrder
    unit_id?: SortOrder
    qty?: SortOrder
    weight?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}